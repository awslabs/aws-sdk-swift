//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct DeleteCapabilityOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePartnershipOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteProfileOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTransformerOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A conflict exception is thrown when you attempt to delete a resource (such as a profile or a capability) that is being used by other resources.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when an error occurs in the Amazon Web Services B2B Data Interchange service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The server attempts to retry a failed command.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// Occurs when the requested resource does not exist, or cannot be found. In some cases, the resource exists in a region other than the region specified in the API call.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Occurs when the calling command attempts to exceed one of the service quotas, for example trying to create a capability when you already have the maximum number of capabilities allowed.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota that was exceeded, which caused the exception.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID for the resource that exceeded the quota, which caused the exception.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type (profile, partnership, transformer, or capability) that exceeded the quota, which caused the exception.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The code responsible for exceeding the quota, which caused the exception.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// The request was denied due to throttling: the data speed and rendering may be limited depending on various parameters and conditions.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The server attempts to retry a command that was throttled.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// Occurs when a B2BI object cannot be validated against a request from another object.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension B2biClientTypes {

    public enum CapabilityDirection: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case inbound
        case outbound
        case sdkUnknown(Swift.String)

        public static var allCases: [CapabilityDirection] {
            return [
                .inbound,
                .outbound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .inbound: return "INBOUND"
            case .outbound: return "OUTBOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension B2biClientTypes {

    /// Specifies the details for the Amazon S3 file location that is being used with Amazon Web Services B2B Data Interchange. File locations in Amazon S3 are identified using a combination of the bucket and key.
    public struct S3Location: Swift.Sendable {
        /// Specifies the name of the Amazon S3 bucket.
        public var bucketName: Swift.String?
        /// Specifies the Amazon S3 key for the file location.
        public var key: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.key = key
        }
    }
}

extension B2biClientTypes {

    public enum X12TransactionSet: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case x12110
        case x12180
        case x12204
        case x12210
        case x12211
        case x12214
        case x12215
        case x12259
        case x12260
        case x12266
        case x12269
        case x12270
        case x12270X279
        case x12271
        case x12271X279
        case x12274
        case x12275
        case x12275X210
        case x12275X211
        case x12276
        case x12276X212
        case x12277
        case x12277X212
        case x12277X214
        case x12277X364
        case x12278
        case x12278X217
        case x12310
        case x12315
        case x12322
        case x12404
        case x12410
        case x12417
        case x12421
        case x12426
        case x12810
        case x12820
        case x12820X218
        case x12820X306
        case x12824
        case x12824X186
        case x12830
        case x12832
        case x12834
        case x12834X220
        case x12834X307
        case x12834X318
        case x12835
        case x12835X221
        case x12837
        case x12837X222
        case x12837X223
        case x12837X224
        case x12837X291
        case x12837X292
        case x12837X298
        case x12844
        case x12846
        case x12849
        case x12850
        case x12852
        case x12855
        case x12856
        case x12860
        case x12861
        case x12864
        case x12865
        case x12869
        case x12870
        case x12940
        case x12945
        case x12990
        case x12997
        case x12999
        case x12999X231
        case sdkUnknown(Swift.String)

        public static var allCases: [X12TransactionSet] {
            return [
                .x12110,
                .x12180,
                .x12204,
                .x12210,
                .x12211,
                .x12214,
                .x12215,
                .x12259,
                .x12260,
                .x12266,
                .x12269,
                .x12270,
                .x12270X279,
                .x12271,
                .x12271X279,
                .x12274,
                .x12275,
                .x12275X210,
                .x12275X211,
                .x12276,
                .x12276X212,
                .x12277,
                .x12277X212,
                .x12277X214,
                .x12277X364,
                .x12278,
                .x12278X217,
                .x12310,
                .x12315,
                .x12322,
                .x12404,
                .x12410,
                .x12417,
                .x12421,
                .x12426,
                .x12810,
                .x12820,
                .x12820X218,
                .x12820X306,
                .x12824,
                .x12824X186,
                .x12830,
                .x12832,
                .x12834,
                .x12834X220,
                .x12834X307,
                .x12834X318,
                .x12835,
                .x12835X221,
                .x12837,
                .x12837X222,
                .x12837X223,
                .x12837X224,
                .x12837X291,
                .x12837X292,
                .x12837X298,
                .x12844,
                .x12846,
                .x12849,
                .x12850,
                .x12852,
                .x12855,
                .x12856,
                .x12860,
                .x12861,
                .x12864,
                .x12865,
                .x12869,
                .x12870,
                .x12940,
                .x12945,
                .x12990,
                .x12997,
                .x12999,
                .x12999X231
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .x12110: return "X12_110"
            case .x12180: return "X12_180"
            case .x12204: return "X12_204"
            case .x12210: return "X12_210"
            case .x12211: return "X12_211"
            case .x12214: return "X12_214"
            case .x12215: return "X12_215"
            case .x12259: return "X12_259"
            case .x12260: return "X12_260"
            case .x12266: return "X12_266"
            case .x12269: return "X12_269"
            case .x12270: return "X12_270"
            case .x12270X279: return "X12_270_X279"
            case .x12271: return "X12_271"
            case .x12271X279: return "X12_271_X279"
            case .x12274: return "X12_274"
            case .x12275: return "X12_275"
            case .x12275X210: return "X12_275_X210"
            case .x12275X211: return "X12_275_X211"
            case .x12276: return "X12_276"
            case .x12276X212: return "X12_276_X212"
            case .x12277: return "X12_277"
            case .x12277X212: return "X12_277_X212"
            case .x12277X214: return "X12_277_X214"
            case .x12277X364: return "X12_277_X364"
            case .x12278: return "X12_278"
            case .x12278X217: return "X12_278_X217"
            case .x12310: return "X12_310"
            case .x12315: return "X12_315"
            case .x12322: return "X12_322"
            case .x12404: return "X12_404"
            case .x12410: return "X12_410"
            case .x12417: return "X12_417"
            case .x12421: return "X12_421"
            case .x12426: return "X12_426"
            case .x12810: return "X12_810"
            case .x12820: return "X12_820"
            case .x12820X218: return "X12_820_X218"
            case .x12820X306: return "X12_820_X306"
            case .x12824: return "X12_824"
            case .x12824X186: return "X12_824_X186"
            case .x12830: return "X12_830"
            case .x12832: return "X12_832"
            case .x12834: return "X12_834"
            case .x12834X220: return "X12_834_X220"
            case .x12834X307: return "X12_834_X307"
            case .x12834X318: return "X12_834_X318"
            case .x12835: return "X12_835"
            case .x12835X221: return "X12_835_X221"
            case .x12837: return "X12_837"
            case .x12837X222: return "X12_837_X222"
            case .x12837X223: return "X12_837_X223"
            case .x12837X224: return "X12_837_X224"
            case .x12837X291: return "X12_837_X291"
            case .x12837X292: return "X12_837_X292"
            case .x12837X298: return "X12_837_X298"
            case .x12844: return "X12_844"
            case .x12846: return "X12_846"
            case .x12849: return "X12_849"
            case .x12850: return "X12_850"
            case .x12852: return "X12_852"
            case .x12855: return "X12_855"
            case .x12856: return "X12_856"
            case .x12860: return "X12_860"
            case .x12861: return "X12_861"
            case .x12864: return "X12_864"
            case .x12865: return "X12_865"
            case .x12869: return "X12_869"
            case .x12870: return "X12_870"
            case .x12940: return "X12_940"
            case .x12945: return "X12_945"
            case .x12990: return "X12_990"
            case .x12997: return "X12_997"
            case .x12999: return "X12_999"
            case .x12999X231: return "X12_999_X231"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension B2biClientTypes {

    public enum X12Version: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case version4010
        case version4030
        case version5010
        case version5010Hipaa
        case sdkUnknown(Swift.String)

        public static var allCases: [X12Version] {
            return [
                .version4010,
                .version4030,
                .version5010,
                .version5010Hipaa
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .version4010: return "VERSION_4010"
            case .version4030: return "VERSION_4030"
            case .version5010: return "VERSION_5010"
            case .version5010Hipaa: return "VERSION_5010_HIPAA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension B2biClientTypes {

    /// A structure that contains the X12 transaction set and version. The X12 structure is used when the system transforms an EDI (electronic data interchange) file. If an EDI input file contains more than one transaction, each transaction must have the same transaction set and version, for example 214/4010. If not, the transformer cannot parse the file.
    public struct X12Details: Swift.Sendable {
        /// Returns an enumerated type where each value identifies an X12 transaction set. Transaction sets are maintained by the X12 Accredited Standards Committee.
        public var transactionSet: B2biClientTypes.X12TransactionSet?
        /// Returns the version to use for the specified X12 transaction set.
        public var version: B2biClientTypes.X12Version?

        public init(
            transactionSet: B2biClientTypes.X12TransactionSet? = nil,
            version: B2biClientTypes.X12Version? = nil
        )
        {
            self.transactionSet = transactionSet
            self.version = version
        }
    }
}

extension B2biClientTypes {

    /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    public enum EdiType: Swift.Sendable {
        /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        case x12details(B2biClientTypes.X12Details)
        case sdkUnknown(Swift.String)
    }
}

extension B2biClientTypes {

    /// Specifies the details for the EDI (electronic data interchange) transformation.
    public struct EdiConfiguration: Swift.Sendable {
        /// Specifies whether this is capability is for inbound or outbound transformations.
        public var capabilityDirection: B2biClientTypes.CapabilityDirection?
        /// Contains the Amazon S3 bucket and prefix for the location of the input file, which is contained in an S3Location object.
        /// This member is required.
        public var inputLocation: B2biClientTypes.S3Location?
        /// Contains the Amazon S3 bucket and prefix for the location of the output file, which is contained in an S3Location object.
        /// This member is required.
        public var outputLocation: B2biClientTypes.S3Location?
        /// Returns the system-assigned unique identifier for the transformer.
        /// This member is required.
        public var transformerId: Swift.String?
        /// Returns the type of the capability. Currently, only edi is supported.
        /// This member is required.
        public var type: B2biClientTypes.EdiType?

        public init(
            capabilityDirection: B2biClientTypes.CapabilityDirection? = nil,
            inputLocation: B2biClientTypes.S3Location? = nil,
            outputLocation: B2biClientTypes.S3Location? = nil,
            transformerId: Swift.String? = nil,
            type: B2biClientTypes.EdiType? = nil
        )
        {
            self.capabilityDirection = capabilityDirection
            self.inputLocation = inputLocation
            self.outputLocation = outputLocation
            self.transformerId = transformerId
            self.type = type
        }
    }
}

extension B2biClientTypes {

    /// A capability object. Currently, only EDI (electronic data interchange) capabilities are supported. A trading capability contains the information required to transform incoming EDI documents into JSON or XML outputs.
    public enum CapabilityConfiguration: Swift.Sendable {
        /// An EDI (electronic data interchange) configuration object.
        case edi(B2biClientTypes.EdiConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension B2biClientTypes {

    /// Creates a key-value pair for a specific resource. Tags are metadata that you can use to search for and group a resource for various purposes. You can apply tags to capabilities, partnerships, profiles and transformers. A tag key can take more than one value. For example, to group capabilities for accounting purposes, you might create a tag called Group and assign the values Research and Accounting to that group.
    public struct Tag: Swift.Sendable {
        /// Specifies the name assigned to the tag that you create.
        /// This member is required.
        public var key: Swift.String?
        /// Contains one or more values that you assigned to the key name that you create.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension B2biClientTypes {

    public enum CapabilityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case edi
        case sdkUnknown(Swift.String)

        public static var allCases: [CapabilityType] {
            return [
                .edi
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .edi: return "edi"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateCapabilityInput: Swift.Sendable {
    /// Reserved for future use.
    public var clientToken: Swift.String?
    /// Specifies a structure that contains the details for a capability.
    /// This member is required.
    public var configuration: B2biClientTypes.CapabilityConfiguration?
    /// Specifies one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
    public var instructionsDocuments: [B2biClientTypes.S3Location]?
    /// Specifies the name of the capability, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    public var tags: [B2biClientTypes.Tag]?
    /// Specifies the type of the capability. Currently, only edi is supported.
    /// This member is required.
    public var type: B2biClientTypes.CapabilityType?

    public init(
        clientToken: Swift.String? = nil,
        configuration: B2biClientTypes.CapabilityConfiguration? = nil,
        instructionsDocuments: [B2biClientTypes.S3Location]? = nil,
        name: Swift.String? = nil,
        tags: [B2biClientTypes.Tag]? = nil,
        type: B2biClientTypes.CapabilityType? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.instructionsDocuments = instructionsDocuments
        self.name = name
        self.tags = tags
        self.type = type
    }
}

public struct CreateCapabilityOutput: Swift.Sendable {
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var capabilityArn: Swift.String?
    /// Returns a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?
    /// Returns a structure that contains the details for a capability.
    /// This member is required.
    public var configuration: B2biClientTypes.CapabilityConfiguration?
    /// Returns a timestamp for creation date and time of the capability.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
    public var instructionsDocuments: [B2biClientTypes.S3Location]?
    /// Returns the name of the capability used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the type of the capability. Currently, only edi is supported.
    /// This member is required.
    public var type: B2biClientTypes.CapabilityType?

    public init(
        capabilityArn: Swift.String? = nil,
        capabilityId: Swift.String? = nil,
        configuration: B2biClientTypes.CapabilityConfiguration? = nil,
        createdAt: Foundation.Date? = nil,
        instructionsDocuments: [B2biClientTypes.S3Location]? = nil,
        name: Swift.String? = nil,
        type: B2biClientTypes.CapabilityType? = nil
    )
    {
        self.capabilityArn = capabilityArn
        self.capabilityId = capabilityId
        self.configuration = configuration
        self.createdAt = createdAt
        self.instructionsDocuments = instructionsDocuments
        self.name = name
        self.type = type
    }
}

public struct DeleteCapabilityInput: Swift.Sendable {
    /// Specifies a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?

    public init(
        capabilityId: Swift.String? = nil
    )
    {
        self.capabilityId = capabilityId
    }
}

public struct GetCapabilityInput: Swift.Sendable {
    /// Specifies a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?

    public init(
        capabilityId: Swift.String? = nil
    )
    {
        self.capabilityId = capabilityId
    }
}

public struct GetCapabilityOutput: Swift.Sendable {
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var capabilityArn: Swift.String?
    /// Returns a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?
    /// Returns a structure that contains the details for a capability.
    /// This member is required.
    public var configuration: B2biClientTypes.CapabilityConfiguration?
    /// Returns a timestamp for creation date and time of the capability.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
    public var instructionsDocuments: [B2biClientTypes.S3Location]?
    /// Returns a timestamp for last time the capability was modified.
    public var modifiedAt: Foundation.Date?
    /// Returns the name of the capability, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the type of the capability. Currently, only edi is supported.
    /// This member is required.
    public var type: B2biClientTypes.CapabilityType?

    public init(
        capabilityArn: Swift.String? = nil,
        capabilityId: Swift.String? = nil,
        configuration: B2biClientTypes.CapabilityConfiguration? = nil,
        createdAt: Foundation.Date? = nil,
        instructionsDocuments: [B2biClientTypes.S3Location]? = nil,
        modifiedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        type: B2biClientTypes.CapabilityType? = nil
    )
    {
        self.capabilityArn = capabilityArn
        self.capabilityId = capabilityId
        self.configuration = configuration
        self.createdAt = createdAt
        self.instructionsDocuments = instructionsDocuments
        self.modifiedAt = modifiedAt
        self.name = name
        self.type = type
    }
}

public struct ListCapabilitiesInput: Swift.Sendable {
    /// Specifies the maximum number of capabilities to return.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension B2biClientTypes {

    /// Returns the capability summary details. A trading capability contains the information required to transform incoming EDI documents into JSON or XML outputs.
    public struct CapabilitySummary: Swift.Sendable {
        /// Returns a system-assigned unique identifier for the capability.
        /// This member is required.
        public var capabilityId: Swift.String?
        /// Returns a timestamp for creation date and time of the capability.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// Returns a timestamp that identifies the most recent date and time that the capability was modified.
        public var modifiedAt: Foundation.Date?
        /// The display name of the capability.
        /// This member is required.
        public var name: Swift.String?
        /// Returns the type of the capability. Currently, only edi is supported.
        /// This member is required.
        public var type: B2biClientTypes.CapabilityType?

        public init(
            capabilityId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            modifiedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            type: B2biClientTypes.CapabilityType? = nil
        )
        {
            self.capabilityId = capabilityId
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.type = type
        }
    }
}

public struct ListCapabilitiesOutput: Swift.Sendable {
    /// Returns one or more capabilities associated with this partnership.
    /// This member is required.
    public var capabilities: [B2biClientTypes.CapabilitySummary]?
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?

    public init(
        capabilities: [B2biClientTypes.CapabilitySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.nextToken = nextToken
    }
}

public struct UpdateCapabilityInput: Swift.Sendable {
    /// Specifies a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?
    /// Specifies a structure that contains the details for a capability.
    public var configuration: B2biClientTypes.CapabilityConfiguration?
    /// Specifies one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
    public var instructionsDocuments: [B2biClientTypes.S3Location]?
    /// Specifies a new name for the capability, to replace the existing name.
    public var name: Swift.String?

    public init(
        capabilityId: Swift.String? = nil,
        configuration: B2biClientTypes.CapabilityConfiguration? = nil,
        instructionsDocuments: [B2biClientTypes.S3Location]? = nil,
        name: Swift.String? = nil
    )
    {
        self.capabilityId = capabilityId
        self.configuration = configuration
        self.instructionsDocuments = instructionsDocuments
        self.name = name
    }
}

public struct UpdateCapabilityOutput: Swift.Sendable {
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var capabilityArn: Swift.String?
    /// Returns a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?
    /// Returns a structure that contains the details for a capability.
    /// This member is required.
    public var configuration: B2biClientTypes.CapabilityConfiguration?
    /// Returns a timestamp for creation date and time of the capability.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
    public var instructionsDocuments: [B2biClientTypes.S3Location]?
    /// Returns a timestamp for last time the capability was modified.
    public var modifiedAt: Foundation.Date?
    /// Returns the name of the capability, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the type of the capability. Currently, only edi is supported.
    /// This member is required.
    public var type: B2biClientTypes.CapabilityType?

    public init(
        capabilityArn: Swift.String? = nil,
        capabilityId: Swift.String? = nil,
        configuration: B2biClientTypes.CapabilityConfiguration? = nil,
        createdAt: Foundation.Date? = nil,
        instructionsDocuments: [B2biClientTypes.S3Location]? = nil,
        modifiedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        type: B2biClientTypes.CapabilityType? = nil
    )
    {
        self.capabilityArn = capabilityArn
        self.capabilityId = capabilityId
        self.configuration = configuration
        self.createdAt = createdAt
        self.instructionsDocuments = instructionsDocuments
        self.modifiedAt = modifiedAt
        self.name = name
        self.type = type
    }
}

extension B2biClientTypes {

    public enum MappingType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jsonata
        case xslt
        case sdkUnknown(Swift.String)

        public static var allCases: [MappingType] {
            return [
                .jsonata,
                .xslt
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jsonata: return "JSONATA"
            case .xslt: return "XSLT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension B2biClientTypes {

    /// A data structure that contains the information to use when generating a mapping template.
    public enum TemplateDetails: Swift.Sendable {
        /// A structure that contains the X12 transaction set and version. The X12 structure is used when the system transforms an EDI (electronic data interchange) file. If an EDI input file contains more than one transaction, each transaction must have the same transaction set and version, for example 214/4010. If not, the transformer cannot parse the file.
        case x12(B2biClientTypes.X12Details)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateStarterMappingTemplateInput: Swift.Sendable {
    /// Specify the format for the mapping template: either JSONATA or XSLT.
    /// This member is required.
    public var mappingType: B2biClientTypes.MappingType?
    /// Specify the location of the sample EDI file that is used to generate the mapping template.
    public var outputSampleLocation: B2biClientTypes.S3Location?
    /// Describes the details needed for generating the template. Specify the X12 transaction set and version for which the template is used: currently, we only support X12.
    /// This member is required.
    public var templateDetails: B2biClientTypes.TemplateDetails?

    public init(
        mappingType: B2biClientTypes.MappingType? = nil,
        outputSampleLocation: B2biClientTypes.S3Location? = nil,
        templateDetails: B2biClientTypes.TemplateDetails? = nil
    )
    {
        self.mappingType = mappingType
        self.outputSampleLocation = outputSampleLocation
        self.templateDetails = templateDetails
    }
}

public struct CreateStarterMappingTemplateOutput: Swift.Sendable {
    /// Returns a string that represents the mapping template.
    /// This member is required.
    public var mappingTemplate: Swift.String?

    public init(
        mappingTemplate: Swift.String? = nil
    )
    {
        self.mappingTemplate = mappingTemplate
    }
}

public struct GetTransformerJobInput: Swift.Sendable {
    /// Specifies the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?
    /// Specifies the unique, system-generated identifier for a transformer run.
    /// This member is required.
    public var transformerJobId: Swift.String?

    public init(
        transformerId: Swift.String? = nil,
        transformerJobId: Swift.String? = nil
    )
    {
        self.transformerId = transformerId
        self.transformerJobId = transformerJobId
    }
}

extension B2biClientTypes {

    public enum TransformerJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [TransformerJobStatus] {
            return [
                .failed,
                .running,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "failed"
            case .running: return "running"
            case .succeeded: return "succeeded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetTransformerJobOutput: Swift.Sendable {
    /// Returns an optional error message, which gets populated when the job is not run successfully.
    public var message: Swift.String?
    /// Returns the location for the output files. If the caller specified a directory for the output, then this contains the full path to the output file, including the file name generated by the service.
    public var outputFiles: [B2biClientTypes.S3Location]?
    /// Returns the current state of the transformer job, either running, succeeded, or failed.
    /// This member is required.
    public var status: B2biClientTypes.TransformerJobStatus?

    public init(
        message: Swift.String? = nil,
        outputFiles: [B2biClientTypes.S3Location]? = nil,
        status: B2biClientTypes.TransformerJobStatus? = nil
    )
    {
        self.message = message
        self.outputFiles = outputFiles
        self.status = status
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// Requests the tags associated with a particular Amazon Resource Name (ARN). An ARN is an identifier for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Returns the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    public var tags: [B2biClientTypes.Tag]?

    public init(
        tags: [B2biClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

extension B2biClientTypes {

    /// In X12 EDI messages, delimiters are used to mark the end of segments or elements, and are defined in the interchange control header. The delimiters are part of the message's syntax and divide up its different elements.
    public struct X12Delimiters: Swift.Sendable {
        /// The component, or sub-element, separator. The default value is : (colon).
        public var componentSeparator: Swift.String?
        /// The data element separator. The default value is * (asterisk).
        public var dataElementSeparator: Swift.String?
        /// The segment terminator. The default value is ~ (tilde).
        public var segmentTerminator: Swift.String?

        public init(
            componentSeparator: Swift.String? = nil,
            dataElementSeparator: Swift.String? = nil,
            segmentTerminator: Swift.String? = nil
        )
        {
            self.componentSeparator = componentSeparator
            self.dataElementSeparator = dataElementSeparator
            self.segmentTerminator = segmentTerminator
        }
    }
}

extension B2biClientTypes {

    /// Part of the X12 message structure. These are the functional group headers for the X12 EDI object.
    public struct X12FunctionalGroupHeaders: Swift.Sendable {
        /// A value representing the code used to identify the party receiving a message, at position GS-03.
        public var applicationReceiverCode: Swift.String?
        /// A value representing the code used to identify the party transmitting a message, at position GS-02.
        public var applicationSenderCode: Swift.String?
        /// A code that identifies the issuer of the standard, at position GS-07.
        public var responsibleAgencyCode: Swift.String?

        public init(
            applicationReceiverCode: Swift.String? = nil,
            applicationSenderCode: Swift.String? = nil,
            responsibleAgencyCode: Swift.String? = nil
        )
        {
            self.applicationReceiverCode = applicationReceiverCode
            self.applicationSenderCode = applicationSenderCode
            self.responsibleAgencyCode = responsibleAgencyCode
        }
    }
}

extension B2biClientTypes {

    /// In X12, the Interchange Control Header is the first segment of an EDI document and is part of the Interchange Envelope. It contains information about the sender and receiver, the date and time of transmission, and the X12 version being used. It also includes delivery information, such as the sender and receiver IDs.
    public struct X12InterchangeControlHeaders: Swift.Sendable {
        /// Located at position ISA-14 in the header. The value "1" indicates that the sender is requesting an interchange acknowledgment at receipt of the interchange. The value "0" is used otherwise.
        public var acknowledgmentRequestedCode: Swift.String?
        /// Located at position ISA-08 in the header. This value (along with the receiverIdQualifier) identifies the intended recipient of the interchange.
        public var receiverId: Swift.String?
        /// Located at position ISA-07 in the header. Qualifier for the receiver ID. Together, the ID and qualifier uniquely identify the receiving trading partner.
        public var receiverIdQualifier: Swift.String?
        /// Located at position ISA-11 in the header. This string makes it easier when you need to group similar adjacent element values together without using extra segments. This parameter is only honored for version greater than 401 (VERSION_4010 and higher). For versions less than 401, this field is called [StandardsId](https://www.stedi.com/edi/x12-004010/segment/ISA#ISA-11), in which case our service sets the value to U.
        public var repetitionSeparator: Swift.String?
        /// Located at position ISA-06 in the header. This value (along with the senderIdQualifier) identifies the sender of the interchange.
        public var senderId: Swift.String?
        /// Located at position ISA-05 in the header. Qualifier for the sender ID. Together, the ID and qualifier uniquely identify the sending trading partner.
        public var senderIdQualifier: Swift.String?
        /// Located at position ISA-15 in the header. Specifies how this interchange is being used:
        ///
        /// * T indicates this interchange is for testing.
        ///
        /// * P indicates this interchange is for production.
        ///
        /// * I indicates this interchange is informational.
        public var usageIndicatorCode: Swift.String?

        public init(
            acknowledgmentRequestedCode: Swift.String? = nil,
            receiverId: Swift.String? = nil,
            receiverIdQualifier: Swift.String? = nil,
            repetitionSeparator: Swift.String? = nil,
            senderId: Swift.String? = nil,
            senderIdQualifier: Swift.String? = nil,
            usageIndicatorCode: Swift.String? = nil
        )
        {
            self.acknowledgmentRequestedCode = acknowledgmentRequestedCode
            self.receiverId = receiverId
            self.receiverIdQualifier = receiverIdQualifier
            self.repetitionSeparator = repetitionSeparator
            self.senderId = senderId
            self.senderIdQualifier = senderIdQualifier
            self.usageIndicatorCode = usageIndicatorCode
        }
    }
}

extension B2biClientTypes {

    /// A structure containing the details for an outbound EDI object.
    public struct X12OutboundEdiHeaders: Swift.Sendable {
        /// The delimiters, for example semicolon (;), that separates sections of the headers for the X12 object.
        public var delimiters: B2biClientTypes.X12Delimiters?
        /// The functional group headers for the X12 object.
        public var functionalGroupHeaders: B2biClientTypes.X12FunctionalGroupHeaders?
        /// In X12 EDI messages, delimiters are used to mark the end of segments or elements, and are defined in the interchange control header.
        public var interchangeControlHeaders: B2biClientTypes.X12InterchangeControlHeaders?
        /// Specifies whether or not to validate the EDI for this X12 object: TRUE or FALSE.
        public var validateEdi: Swift.Bool?

        public init(
            delimiters: B2biClientTypes.X12Delimiters? = nil,
            functionalGroupHeaders: B2biClientTypes.X12FunctionalGroupHeaders? = nil,
            interchangeControlHeaders: B2biClientTypes.X12InterchangeControlHeaders? = nil,
            validateEdi: Swift.Bool? = nil
        )
        {
            self.delimiters = delimiters
            self.functionalGroupHeaders = functionalGroupHeaders
            self.interchangeControlHeaders = interchangeControlHeaders
            self.validateEdi = validateEdi
        }
    }
}

extension B2biClientTypes {

    /// A wrapper structure for an X12 definition object. the X12 envelope ensures the integrity of the data and the efficiency of the information exchange. The X12 message structure has hierarchical levels. From highest to the lowest, they are:
    ///
    /// * Interchange Envelope
    ///
    /// * Functional Group
    ///
    /// * Transaction Set
    public struct X12Envelope: Swift.Sendable {
        /// A container for the X12 outbound EDI headers.
        public var common: B2biClientTypes.X12OutboundEdiHeaders?

        public init(
            common: B2biClientTypes.X12OutboundEdiHeaders? = nil
        )
        {
            self.common = common
        }
    }
}

extension B2biClientTypes {

    /// A container for outbound EDI options.
    public enum OutboundEdiOptions: Swift.Sendable {
        /// A structure that contains an X12 envelope structure.
        case x12(B2biClientTypes.X12Envelope)
        case sdkUnknown(Swift.String)
    }
}

extension B2biClientTypes {

    /// Contains the details for an Outbound EDI capability.
    public struct CapabilityOptions: Swift.Sendable {
        /// A structure that contains the outbound EDI options.
        public var outboundEdi: B2biClientTypes.OutboundEdiOptions?

        public init(
            outboundEdi: B2biClientTypes.OutboundEdiOptions? = nil
        )
        {
            self.outboundEdi = outboundEdi
        }
    }
}

public struct CreatePartnershipInput: Swift.Sendable {
    /// Specifies a list of the capabilities associated with this partnership.
    /// This member is required.
    public var capabilities: [Swift.String]?
    /// Specify the structure that contains the details for the associated capabilities.
    public var capabilityOptions: B2biClientTypes.CapabilityOptions?
    /// Reserved for future use.
    public var clientToken: Swift.String?
    /// Specifies the email address associated with this trading partner.
    /// This member is required.
    public var email: Swift.String?
    /// Specifies a descriptive name for the partnership.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the phone number associated with the partnership.
    public var phone: Swift.String?
    /// Specifies the unique, system-generated identifier for the profile connected to this partnership.
    /// This member is required.
    public var profileId: Swift.String?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    public var tags: [B2biClientTypes.Tag]?

    public init(
        capabilities: [Swift.String]? = nil,
        capabilityOptions: B2biClientTypes.CapabilityOptions? = nil,
        clientToken: Swift.String? = nil,
        email: Swift.String? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileId: Swift.String? = nil,
        tags: [B2biClientTypes.Tag]? = nil
    )
    {
        self.capabilities = capabilities
        self.capabilityOptions = capabilityOptions
        self.clientToken = clientToken
        self.email = email
        self.name = name
        self.phone = phone
        self.profileId = profileId
        self.tags = tags
    }
}

extension CreatePartnershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePartnershipInput(capabilities: \(Swift.String(describing: capabilities)), capabilityOptions: \(Swift.String(describing: capabilityOptions)), clientToken: \(Swift.String(describing: clientToken)), name: \(Swift.String(describing: name)), profileId: \(Swift.String(describing: profileId)), tags: \(Swift.String(describing: tags)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

public struct CreatePartnershipOutput: Swift.Sendable {
    /// Returns one or more capabilities associated with this partnership.
    public var capabilities: [Swift.String]?
    /// Returns the structure that contains the details for the associated capabilities.
    public var capabilityOptions: B2biClientTypes.CapabilityOptions?
    /// Returns a timestamp for creation date and time of the partnership.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the email address associated with this trading partner.
    public var email: Swift.String?
    /// Returns a descriptive name for the partnership.
    public var name: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var partnershipArn: Swift.String?
    /// Returns the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?
    /// Returns the phone number associated with the partnership.
    public var phone: Swift.String?
    /// Returns the unique, system-generated identifier for the profile connected to this partnership.
    /// This member is required.
    public var profileId: Swift.String?
    /// Returns the unique, system-generated identifier for a trading partner.
    public var tradingPartnerId: Swift.String?

    public init(
        capabilities: [Swift.String]? = nil,
        capabilityOptions: B2biClientTypes.CapabilityOptions? = nil,
        createdAt: Foundation.Date? = nil,
        email: Swift.String? = nil,
        name: Swift.String? = nil,
        partnershipArn: Swift.String? = nil,
        partnershipId: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileId: Swift.String? = nil,
        tradingPartnerId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.capabilityOptions = capabilityOptions
        self.createdAt = createdAt
        self.email = email
        self.name = name
        self.partnershipArn = partnershipArn
        self.partnershipId = partnershipId
        self.phone = phone
        self.profileId = profileId
        self.tradingPartnerId = tradingPartnerId
    }
}

extension CreatePartnershipOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePartnershipOutput(capabilities: \(Swift.String(describing: capabilities)), capabilityOptions: \(Swift.String(describing: capabilityOptions)), createdAt: \(Swift.String(describing: createdAt)), name: \(Swift.String(describing: name)), partnershipArn: \(Swift.String(describing: partnershipArn)), partnershipId: \(Swift.String(describing: partnershipId)), profileId: \(Swift.String(describing: profileId)), tradingPartnerId: \(Swift.String(describing: tradingPartnerId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

public struct DeletePartnershipInput: Swift.Sendable {
    /// Specifies the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?

    public init(
        partnershipId: Swift.String? = nil
    )
    {
        self.partnershipId = partnershipId
    }
}

public struct GetPartnershipInput: Swift.Sendable {
    /// Specifies the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?

    public init(
        partnershipId: Swift.String? = nil
    )
    {
        self.partnershipId = partnershipId
    }
}

public struct GetPartnershipOutput: Swift.Sendable {
    /// Returns one or more capabilities associated with this partnership.
    public var capabilities: [Swift.String]?
    /// Contains the details for an Outbound EDI capability.
    public var capabilityOptions: B2biClientTypes.CapabilityOptions?
    /// Returns a timestamp for creation date and time of the partnership.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the email address associated with this trading partner.
    public var email: Swift.String?
    /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
    public var modifiedAt: Foundation.Date?
    /// Returns the display name of the partnership
    public var name: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var partnershipArn: Swift.String?
    /// Returns the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?
    /// Returns the phone number associated with the partnership.
    public var phone: Swift.String?
    /// Returns the unique, system-generated identifier for the profile connected to this partnership.
    /// This member is required.
    public var profileId: Swift.String?
    /// Returns the unique identifier for the partner for this partnership.
    public var tradingPartnerId: Swift.String?

    public init(
        capabilities: [Swift.String]? = nil,
        capabilityOptions: B2biClientTypes.CapabilityOptions? = nil,
        createdAt: Foundation.Date? = nil,
        email: Swift.String? = nil,
        modifiedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        partnershipArn: Swift.String? = nil,
        partnershipId: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileId: Swift.String? = nil,
        tradingPartnerId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.capabilityOptions = capabilityOptions
        self.createdAt = createdAt
        self.email = email
        self.modifiedAt = modifiedAt
        self.name = name
        self.partnershipArn = partnershipArn
        self.partnershipId = partnershipId
        self.phone = phone
        self.profileId = profileId
        self.tradingPartnerId = tradingPartnerId
    }
}

extension GetPartnershipOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPartnershipOutput(capabilities: \(Swift.String(describing: capabilities)), capabilityOptions: \(Swift.String(describing: capabilityOptions)), createdAt: \(Swift.String(describing: createdAt)), modifiedAt: \(Swift.String(describing: modifiedAt)), name: \(Swift.String(describing: name)), partnershipArn: \(Swift.String(describing: partnershipArn)), partnershipId: \(Swift.String(describing: partnershipId)), profileId: \(Swift.String(describing: profileId)), tradingPartnerId: \(Swift.String(describing: tradingPartnerId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

public struct ListPartnershipsInput: Swift.Sendable {
    /// Specifies the maximum number of capabilities to return.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?
    /// Specifies the unique, system-generated identifier for the profile connected to this partnership.
    public var profileId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profileId = profileId
    }
}

extension B2biClientTypes {

    /// A structure that contains the details for a partnership. A partnership represents the connection between you and your trading partner. It ties together a profile and one or more trading capabilities.
    public struct PartnershipSummary: Swift.Sendable {
        /// Returns one or more capabilities associated with this partnership.
        public var capabilities: [Swift.String]?
        /// Contains the details for an Outbound EDI capability.
        public var capabilityOptions: B2biClientTypes.CapabilityOptions?
        /// Returns a timestamp for creation date and time of the partnership.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
        public var modifiedAt: Foundation.Date?
        /// Returns the name of the partnership.
        public var name: Swift.String?
        /// Returns the unique, system-generated identifier for a partnership.
        /// This member is required.
        public var partnershipId: Swift.String?
        /// Returns the unique, system-generated identifier for the profile connected to this partnership.
        /// This member is required.
        public var profileId: Swift.String?
        /// Returns the unique, system-generated identifier for a trading partner.
        public var tradingPartnerId: Swift.String?

        public init(
            capabilities: [Swift.String]? = nil,
            capabilityOptions: B2biClientTypes.CapabilityOptions? = nil,
            createdAt: Foundation.Date? = nil,
            modifiedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            partnershipId: Swift.String? = nil,
            profileId: Swift.String? = nil,
            tradingPartnerId: Swift.String? = nil
        )
        {
            self.capabilities = capabilities
            self.capabilityOptions = capabilityOptions
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.partnershipId = partnershipId
            self.profileId = profileId
            self.tradingPartnerId = tradingPartnerId
        }
    }
}

public struct ListPartnershipsOutput: Swift.Sendable {
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?
    /// Specifies a list of your partnerships.
    /// This member is required.
    public var partnerships: [B2biClientTypes.PartnershipSummary]?

    public init(
        nextToken: Swift.String? = nil,
        partnerships: [B2biClientTypes.PartnershipSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.partnerships = partnerships
    }
}

public struct UpdatePartnershipInput: Swift.Sendable {
    /// List of the capabilities associated with this partnership.
    public var capabilities: [Swift.String]?
    /// To update, specify the structure that contains the details for the associated capabilities.
    public var capabilityOptions: B2biClientTypes.CapabilityOptions?
    /// The name of the partnership, used to identify it.
    public var name: Swift.String?
    /// Specifies the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?

    public init(
        capabilities: [Swift.String]? = nil,
        capabilityOptions: B2biClientTypes.CapabilityOptions? = nil,
        name: Swift.String? = nil,
        partnershipId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.capabilityOptions = capabilityOptions
        self.name = name
        self.partnershipId = partnershipId
    }
}

public struct UpdatePartnershipOutput: Swift.Sendable {
    /// Returns one or more capabilities associated with this partnership.
    public var capabilities: [Swift.String]?
    /// Returns the structure that contains the details for the associated capabilities.
    public var capabilityOptions: B2biClientTypes.CapabilityOptions?
    /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the email address associated with this trading partner.
    public var email: Swift.String?
    /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
    public var modifiedAt: Foundation.Date?
    /// The name of the partnership, used to identify it.
    public var name: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var partnershipArn: Swift.String?
    /// Returns the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?
    /// Returns the phone number associated with the partnership.
    public var phone: Swift.String?
    /// Returns the unique, system-generated identifier for the profile connected to this partnership.
    /// This member is required.
    public var profileId: Swift.String?
    /// Returns the unique, system-generated identifier for a trading partner.
    public var tradingPartnerId: Swift.String?

    public init(
        capabilities: [Swift.String]? = nil,
        capabilityOptions: B2biClientTypes.CapabilityOptions? = nil,
        createdAt: Foundation.Date? = nil,
        email: Swift.String? = nil,
        modifiedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        partnershipArn: Swift.String? = nil,
        partnershipId: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileId: Swift.String? = nil,
        tradingPartnerId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.capabilityOptions = capabilityOptions
        self.createdAt = createdAt
        self.email = email
        self.modifiedAt = modifiedAt
        self.name = name
        self.partnershipArn = partnershipArn
        self.partnershipId = partnershipId
        self.phone = phone
        self.profileId = profileId
        self.tradingPartnerId = tradingPartnerId
    }
}

extension UpdatePartnershipOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePartnershipOutput(capabilities: \(Swift.String(describing: capabilities)), capabilityOptions: \(Swift.String(describing: capabilityOptions)), createdAt: \(Swift.String(describing: createdAt)), modifiedAt: \(Swift.String(describing: modifiedAt)), name: \(Swift.String(describing: name)), partnershipArn: \(Swift.String(describing: partnershipArn)), partnershipId: \(Swift.String(describing: partnershipId)), profileId: \(Swift.String(describing: profileId)), tradingPartnerId: \(Swift.String(describing: tradingPartnerId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

extension B2biClientTypes {

    public enum Logging: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [Logging] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateProfileInput: Swift.Sendable {
    /// Specifies the name for the business associated with this profile.
    /// This member is required.
    public var businessName: Swift.String?
    /// Reserved for future use.
    public var clientToken: Swift.String?
    /// Specifies the email address associated with this customer profile.
    public var email: Swift.String?
    /// Specifies whether or not logging is enabled for this profile.
    /// This member is required.
    public var logging: B2biClientTypes.Logging?
    /// Specifies the name of the profile.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the phone number associated with the profile.
    /// This member is required.
    public var phone: Swift.String?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    public var tags: [B2biClientTypes.Tag]?

    public init(
        businessName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        email: Swift.String? = nil,
        logging: B2biClientTypes.Logging? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        tags: [B2biClientTypes.Tag]? = nil
    )
    {
        self.businessName = businessName
        self.clientToken = clientToken
        self.email = email
        self.logging = logging
        self.name = name
        self.phone = phone
        self.tags = tags
    }
}

extension CreateProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProfileInput(businessName: \(Swift.String(describing: businessName)), clientToken: \(Swift.String(describing: clientToken)), logging: \(Swift.String(describing: logging)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

public struct CreateProfileOutput: Swift.Sendable {
    /// Returns the name for the business associated with this profile.
    /// This member is required.
    public var businessName: Swift.String?
    /// Returns a timestamp representing the time the profile was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the email address associated with this customer profile.
    public var email: Swift.String?
    /// Returns the name of the logging group.
    public var logGroupName: Swift.String?
    /// Returns whether or not logging is turned on for this profile.
    public var logging: B2biClientTypes.Logging?
    /// Returns the name of the profile, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the phone number associated with the profile.
    /// This member is required.
    public var phone: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for the profile.
    /// This member is required.
    public var profileArn: Swift.String?
    /// Returns the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        businessName: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        email: Swift.String? = nil,
        logGroupName: Swift.String? = nil,
        logging: B2biClientTypes.Logging? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.businessName = businessName
        self.createdAt = createdAt
        self.email = email
        self.logGroupName = logGroupName
        self.logging = logging
        self.name = name
        self.phone = phone
        self.profileArn = profileArn
        self.profileId = profileId
    }
}

extension CreateProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProfileOutput(businessName: \(Swift.String(describing: businessName)), createdAt: \(Swift.String(describing: createdAt)), logGroupName: \(Swift.String(describing: logGroupName)), logging: \(Swift.String(describing: logging)), name: \(Swift.String(describing: name)), profileArn: \(Swift.String(describing: profileArn)), profileId: \(Swift.String(describing: profileId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

public struct DeleteProfileInput: Swift.Sendable {
    /// Specifies the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

public struct GetProfileInput: Swift.Sendable {
    /// Specifies the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

public struct GetProfileOutput: Swift.Sendable {
    /// Returns the name for the business associated with this profile.
    /// This member is required.
    public var businessName: Swift.String?
    /// Returns a timestamp for creation date and time of the transformer.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the email address associated with this customer profile.
    public var email: Swift.String?
    /// Returns the name of the logging group.
    public var logGroupName: Swift.String?
    /// Returns whether or not logging is enabled for this profile.
    public var logging: B2biClientTypes.Logging?
    /// Returns a timestamp for last time the profile was modified.
    public var modifiedAt: Foundation.Date?
    /// Returns the name of the profile, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the phone number associated with the profile.
    /// This member is required.
    public var phone: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var profileArn: Swift.String?
    /// Returns the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        businessName: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        email: Swift.String? = nil,
        logGroupName: Swift.String? = nil,
        logging: B2biClientTypes.Logging? = nil,
        modifiedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.businessName = businessName
        self.createdAt = createdAt
        self.email = email
        self.logGroupName = logGroupName
        self.logging = logging
        self.modifiedAt = modifiedAt
        self.name = name
        self.phone = phone
        self.profileArn = profileArn
        self.profileId = profileId
    }
}

extension GetProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProfileOutput(businessName: \(Swift.String(describing: businessName)), createdAt: \(Swift.String(describing: createdAt)), logGroupName: \(Swift.String(describing: logGroupName)), logging: \(Swift.String(describing: logging)), modifiedAt: \(Swift.String(describing: modifiedAt)), name: \(Swift.String(describing: name)), profileArn: \(Swift.String(describing: profileArn)), profileId: \(Swift.String(describing: profileId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

public struct ListProfilesInput: Swift.Sendable {
    /// Specifies the maximum number of profiles to return.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension B2biClientTypes {

    /// Contains the details for a profile. A profile is the mechanism used to create the concept of a private network.
    public struct ProfileSummary: Swift.Sendable {
        /// Returns the name for the business associated with this profile.
        /// This member is required.
        public var businessName: Swift.String?
        /// Returns the timestamp for creation date and time of the profile.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// Returns the name of the logging group.
        public var logGroupName: Swift.String?
        /// Specifies whether or not logging is enabled for this profile.
        public var logging: B2biClientTypes.Logging?
        /// Returns the timestamp that identifies the most recent date and time that the profile was modified.
        public var modifiedAt: Foundation.Date?
        /// Returns the display name for profile.
        /// This member is required.
        public var name: Swift.String?
        /// Returns the unique, system-generated identifier for the profile.
        /// This member is required.
        public var profileId: Swift.String?

        public init(
            businessName: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            logGroupName: Swift.String? = nil,
            logging: B2biClientTypes.Logging? = nil,
            modifiedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            profileId: Swift.String? = nil
        )
        {
            self.businessName = businessName
            self.createdAt = createdAt
            self.logGroupName = logGroupName
            self.logging = logging
            self.modifiedAt = modifiedAt
            self.name = name
            self.profileId = profileId
        }
    }
}

public struct ListProfilesOutput: Swift.Sendable {
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?
    /// Returns an array of ProfileSummary objects.
    /// This member is required.
    public var profiles: [B2biClientTypes.ProfileSummary]?

    public init(
        nextToken: Swift.String? = nil,
        profiles: [B2biClientTypes.ProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
    }
}

public struct UpdateProfileInput: Swift.Sendable {
    /// Specifies the name for the business associated with this profile.
    public var businessName: Swift.String?
    /// Specifies the email address associated with this customer profile.
    public var email: Swift.String?
    /// The name of the profile, used to identify it.
    public var name: Swift.String?
    /// Specifies the phone number associated with the profile.
    public var phone: Swift.String?
    /// Specifies the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        businessName: Swift.String? = nil,
        email: Swift.String? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.businessName = businessName
        self.email = email
        self.name = name
        self.phone = phone
        self.profileId = profileId
    }
}

extension UpdateProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProfileInput(businessName: \(Swift.String(describing: businessName)), name: \(Swift.String(describing: name)), profileId: \(Swift.String(describing: profileId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

public struct UpdateProfileOutput: Swift.Sendable {
    /// Returns the name for the business associated with this profile.
    /// This member is required.
    public var businessName: Swift.String?
    /// Returns a timestamp for creation date and time of the profile.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the email address associated with this customer profile.
    public var email: Swift.String?
    /// Returns the name of the logging group.
    public var logGroupName: Swift.String?
    /// Specifies whether or not logging is enabled for this profile.
    public var logging: B2biClientTypes.Logging?
    /// Returns a timestamp for last time the profile was modified.
    public var modifiedAt: Foundation.Date?
    /// Returns the name of the profile.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the phone number associated with the profile.
    /// This member is required.
    public var phone: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for the profile.
    /// This member is required.
    public var profileArn: Swift.String?
    /// Returns the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        businessName: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        email: Swift.String? = nil,
        logGroupName: Swift.String? = nil,
        logging: B2biClientTypes.Logging? = nil,
        modifiedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.businessName = businessName
        self.createdAt = createdAt
        self.email = email
        self.logGroupName = logGroupName
        self.logging = logging
        self.modifiedAt = modifiedAt
        self.name = name
        self.phone = phone
        self.profileArn = profileArn
        self.profileId = profileId
    }
}

extension UpdateProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProfileOutput(businessName: \(Swift.String(describing: businessName)), createdAt: \(Swift.String(describing: createdAt)), logGroupName: \(Swift.String(describing: logGroupName)), logging: \(Swift.String(describing: logging)), modifiedAt: \(Swift.String(describing: modifiedAt)), name: \(Swift.String(describing: name)), profileArn: \(Swift.String(describing: profileArn)), profileId: \(Swift.String(describing: profileId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

public struct StartTransformerJobInput: Swift.Sendable {
    /// Reserved for future use.
    public var clientToken: Swift.String?
    /// Specifies the location of the input file for the transformation. The location consists of an Amazon S3 bucket and prefix.
    /// This member is required.
    public var inputFile: B2biClientTypes.S3Location?
    /// Specifies the location of the output file for the transformation. The location consists of an Amazon S3 bucket and prefix.
    /// This member is required.
    public var outputLocation: B2biClientTypes.S3Location?
    /// Specifies the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        inputFile: B2biClientTypes.S3Location? = nil,
        outputLocation: B2biClientTypes.S3Location? = nil,
        transformerId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.inputFile = inputFile
        self.outputLocation = outputLocation
        self.transformerId = transformerId
    }
}

public struct StartTransformerJobOutput: Swift.Sendable {
    /// Returns the unique, system-generated identifier for a transformer run.
    /// This member is required.
    public var transformerJobId: Swift.String?

    public init(
        transformerJobId: Swift.String? = nil
    )
    {
        self.transformerJobId = transformerJobId
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// Specifies an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    /// This member is required.
    public var tags: [B2biClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [B2biClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

extension B2biClientTypes {

    public enum ConversionSourceFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case xml
        case sdkUnknown(Swift.String)

        public static var allCases: [ConversionSourceFormat] {
            return [
                .json,
                .xml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .xml: return "XML"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension B2biClientTypes {

    /// The input file to use for an outbound transformation.
    public enum InputFileSource: Swift.Sendable {
        /// Specify the input contents, as a string, for the source of an outbound transformation.
        case filecontent(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension B2biClientTypes {

    /// Describes the input for an outbound transformation.
    public struct ConversionSource: Swift.Sendable {
        /// The format for the input file: either JSON or XML.
        /// This member is required.
        public var fileFormat: B2biClientTypes.ConversionSourceFormat?
        /// File to be converted
        /// This member is required.
        public var inputFile: B2biClientTypes.InputFileSource?

        public init(
            fileFormat: B2biClientTypes.ConversionSourceFormat? = nil,
            inputFile: B2biClientTypes.InputFileSource? = nil
        )
        {
            self.fileFormat = fileFormat
            self.inputFile = inputFile
        }
    }
}

extension B2biClientTypes {

    public enum ConversionTargetFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case x12
        case sdkUnknown(Swift.String)

        public static var allCases: [ConversionTargetFormat] {
            return [
                .x12
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .x12: return "X12"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension B2biClientTypes {

    /// Contains a structure describing the X12 details for the conversion target.
    public enum ConversionTargetFormatDetails: Swift.Sendable {
        /// A structure that contains the X12 transaction set and version. The X12 structure is used when the system transforms an EDI (electronic data interchange) file. If an EDI input file contains more than one transaction, each transaction must have the same transaction set and version, for example 214/4010. If not, the transformer cannot parse the file.
        case x12(B2biClientTypes.X12Details)
        case sdkUnknown(Swift.String)
    }
}

extension B2biClientTypes {

    /// Container for the location of a sample file used for outbound transformations.
    public enum OutputSampleFileSource: Swift.Sendable {
        /// Specifies the details for the Amazon S3 file location that is being used with Amazon Web Services B2B Data Interchange. File locations in Amazon S3 are identified using a combination of the bucket and key.
        case filelocation(B2biClientTypes.S3Location)
        case sdkUnknown(Swift.String)
    }
}

extension B2biClientTypes {

    /// Provide a sample of what the output of the transformation should look like.
    public struct ConversionTarget: Swift.Sendable {
        /// Currently, only X12 format is supported.
        /// This member is required.
        public var fileFormat: B2biClientTypes.ConversionTargetFormat?
        /// A structure that contains the formatting details for the conversion target.
        public var formatDetails: B2biClientTypes.ConversionTargetFormatDetails?
        /// Customer uses this to provide a sample on what should file look like after conversion X12 EDI use case around this would be discovering the file syntax
        public var outputSampleFile: B2biClientTypes.OutputSampleFileSource?

        public init(
            fileFormat: B2biClientTypes.ConversionTargetFormat? = nil,
            formatDetails: B2biClientTypes.ConversionTargetFormatDetails? = nil,
            outputSampleFile: B2biClientTypes.OutputSampleFileSource? = nil
        )
        {
            self.fileFormat = fileFormat
            self.formatDetails = formatDetails
            self.outputSampleFile = outputSampleFile
        }
    }
}

public struct TestConversionInput: Swift.Sendable {
    /// Specify the source file for an outbound EDI request.
    /// This member is required.
    public var source: B2biClientTypes.ConversionSource?
    /// Specify the format (X12 is the only currently supported format), and other details for the conversion target.
    /// This member is required.
    public var target: B2biClientTypes.ConversionTarget?

    public init(
        source: B2biClientTypes.ConversionSource? = nil,
        target: B2biClientTypes.ConversionTarget? = nil
    )
    {
        self.source = source
        self.target = target
    }
}

public struct TestConversionOutput: Swift.Sendable {
    /// Returns the converted file content.
    /// This member is required.
    public var convertedFileContent: Swift.String?
    /// Returns an array of strings, each containing a message that Amazon Web Services B2B Data Interchange generates during the conversion.
    public var validationMessages: [Swift.String]?

    public init(
        convertedFileContent: Swift.String? = nil,
        validationMessages: [Swift.String]? = nil
    )
    {
        self.convertedFileContent = convertedFileContent
        self.validationMessages = validationMessages
    }
}

extension B2biClientTypes {

    public enum FileFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case notUsed
        case xml
        case sdkUnknown(Swift.String)

        public static var allCases: [FileFormat] {
            return [
                .json,
                .notUsed,
                .xml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .notUsed: return "NOT_USED"
            case .xml: return "XML"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct TestMappingInput: Swift.Sendable {
    /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
    /// This member is required.
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Specify the contents of the EDI (electronic data interchange) XML or JSON file that is used as input for the transform.
    /// This member is required.
    public var inputFileContent: Swift.String?
    /// Specifies the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT. This parameter is available for backwards compatibility. Use the [Mapping](https://docs.aws.amazon.com/b2bi/latest/APIReference/API_Mapping.html) data type instead.
    /// This member is required.
    public var mappingTemplate: Swift.String?

    public init(
        fileFormat: B2biClientTypes.FileFormat? = nil,
        inputFileContent: Swift.String? = nil,
        mappingTemplate: Swift.String? = nil
    )
    {
        self.fileFormat = fileFormat
        self.inputFileContent = inputFileContent
        self.mappingTemplate = mappingTemplate
    }
}

public struct TestMappingOutput: Swift.Sendable {
    /// Returns a string for the mapping that can be used to identify the mapping. Similar to a fingerprint
    /// This member is required.
    public var mappedFileContent: Swift.String?

    public init(
        mappedFileContent: Swift.String? = nil
    )
    {
        self.mappedFileContent = mappedFileContent
    }
}

public struct TestParsingInput: Swift.Sendable {
    /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    /// This member is required.
    public var ediType: B2biClientTypes.EdiType?
    /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
    /// This member is required.
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Specifies an S3Location object, which contains the Amazon S3 bucket and prefix for the location of the input file.
    /// This member is required.
    public var inputFile: B2biClientTypes.S3Location?

    public init(
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = nil,
        inputFile: B2biClientTypes.S3Location? = nil
    )
    {
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.inputFile = inputFile
    }
}

public struct TestParsingOutput: Swift.Sendable {
    /// Returns the contents of the input file being tested, parsed according to the specified EDI (electronic data interchange) type.
    /// This member is required.
    public var parsedFileContent: Swift.String?

    public init(
        parsedFileContent: Swift.String? = nil
    )
    {
        self.parsedFileContent = parsedFileContent
    }
}

extension B2biClientTypes {

    /// A structure that contains the X12 transaction set and version.
    public enum FormatOptions: Swift.Sendable {
        /// A structure that contains the X12 transaction set and version. The X12 structure is used when the system transforms an EDI (electronic data interchange) file. If an EDI input file contains more than one transaction, each transaction must have the same transaction set and version, for example 214/4010. If not, the transformer cannot parse the file.
        case x12(B2biClientTypes.X12Details)
        case sdkUnknown(Swift.String)
    }
}

extension B2biClientTypes {

    public enum FromFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case x12
        case sdkUnknown(Swift.String)

        public static var allCases: [FromFormat] {
            return [
                .x12
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .x12: return "X12"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension B2biClientTypes {

    /// Contains the input formatting options for an inbound transformer (takes an X12-formatted EDI document as input and converts it to JSON or XML.
    public struct InputConversion: Swift.Sendable {
        /// A structure that contains the formatting options for an inbound transformer.
        public var formatOptions: B2biClientTypes.FormatOptions?
        /// The format for the transformer input: currently on X12 is supported.
        /// This member is required.
        public var fromFormat: B2biClientTypes.FromFormat?

        public init(
            formatOptions: B2biClientTypes.FormatOptions? = nil,
            fromFormat: B2biClientTypes.FromFormat? = nil
        )
        {
            self.formatOptions = formatOptions
            self.fromFormat = fromFormat
        }
    }
}

extension B2biClientTypes {

    public enum MappingTemplateLanguage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jsonata
        case xslt
        case sdkUnknown(Swift.String)

        public static var allCases: [MappingTemplateLanguage] {
            return [
                .jsonata,
                .xslt
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jsonata: return "JSONATA"
            case .xslt: return "XSLT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension B2biClientTypes {

    /// Specifies the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.
    public struct Mapping: Swift.Sendable {
        /// A string that represents the mapping template, in the transformation language specified in templateLanguage.
        public var template: Swift.String?
        /// The transformation language for the template, either XSLT or JSONATA.
        /// This member is required.
        public var templateLanguage: B2biClientTypes.MappingTemplateLanguage?

        public init(
            template: Swift.String? = nil,
            templateLanguage: B2biClientTypes.MappingTemplateLanguage? = nil
        )
        {
            self.template = template
            self.templateLanguage = templateLanguage
        }
    }
}

extension B2biClientTypes {

    public enum ToFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case x12
        case sdkUnknown(Swift.String)

        public static var allCases: [ToFormat] {
            return [
                .x12
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .x12: return "X12"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension B2biClientTypes {

    /// Contains the formatting options for an outbound transformer (takes JSON or XML as input and converts it to an EDI document (currently only X12 format is supported).
    public struct OutputConversion: Swift.Sendable {
        /// A structure that contains the X12 transaction set and version for the transformer output.
        public var formatOptions: B2biClientTypes.FormatOptions?
        /// The format for the output from an outbound transformer: only X12 is currently supported.
        /// This member is required.
        public var toFormat: B2biClientTypes.ToFormat?

        public init(
            formatOptions: B2biClientTypes.FormatOptions? = nil,
            toFormat: B2biClientTypes.ToFormat? = nil
        )
        {
            self.formatOptions = formatOptions
            self.toFormat = toFormat
        }
    }
}

extension B2biClientTypes {

    /// An array of the Amazon S3 keys used to identify the location for your sample documents.
    public struct SampleDocumentKeys: Swift.Sendable {
        /// An array of keys for your input sample documents.
        public var input: Swift.String?
        /// An array of keys for your output sample documents.
        public var output: Swift.String?

        public init(
            input: Swift.String? = nil,
            output: Swift.String? = nil
        )
        {
            self.input = input
            self.output = output
        }
    }
}

extension B2biClientTypes {

    /// Describes a structure that contains the Amazon S3 bucket and an array of the corresponding keys used to identify the location for your sample documents.
    public struct SampleDocuments: Swift.Sendable {
        /// Contains the Amazon S3 bucket that is used to hold your sample documents.
        /// This member is required.
        public var bucketName: Swift.String?
        /// Contains an array of the Amazon S3 keys used to identify the location for your sample documents.
        /// This member is required.
        public var keys: [B2biClientTypes.SampleDocumentKeys]?

        public init(
            bucketName: Swift.String? = nil,
            keys: [B2biClientTypes.SampleDocumentKeys]? = nil
        )
        {
            self.bucketName = bucketName
            self.keys = keys
        }
    }
}

public struct CreateTransformerInput: Swift.Sendable {
    /// Reserved for future use.
    public var clientToken: Swift.String?
    /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var ediType: B2biClientTypes.EdiType?
    /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Specify the InputConversion object, which contains the format options for the inbound transformation.
    public var inputConversion: B2biClientTypes.InputConversion?
    /// Specify the structure that contains the mapping template and its language (either XSLT or JSONATA).
    public var mapping: B2biClientTypes.Mapping?
    /// Specifies the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT. This parameter is available for backwards compatibility. Use the [Mapping](https://docs.aws.amazon.com/b2bi/latest/APIReference/API_Mapping.html) data type instead.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var mappingTemplate: Swift.String?
    /// Specifies the name of the transformer, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// A structure that contains the OutputConversion object, which contains the format options for the outbound transformation.
    public var outputConversion: B2biClientTypes.OutputConversion?
    /// Specifies a sample EDI document that is used by a transformer as a guide for processing the EDI data.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var sampleDocument: Swift.String?
    /// Specify a structure that contains the Amazon S3 bucket and an array of the corresponding keys used to identify the location for your sample documents.
    public var sampleDocuments: B2biClientTypes.SampleDocuments?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    public var tags: [B2biClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = nil,
        inputConversion: B2biClientTypes.InputConversion? = nil,
        mapping: B2biClientTypes.Mapping? = nil,
        mappingTemplate: Swift.String? = nil,
        name: Swift.String? = nil,
        outputConversion: B2biClientTypes.OutputConversion? = nil,
        sampleDocument: Swift.String? = nil,
        sampleDocuments: B2biClientTypes.SampleDocuments? = nil,
        tags: [B2biClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.inputConversion = inputConversion
        self.mapping = mapping
        self.mappingTemplate = mappingTemplate
        self.name = name
        self.outputConversion = outputConversion
        self.sampleDocument = sampleDocument
        self.sampleDocuments = sampleDocuments
        self.tags = tags
    }
}

extension B2biClientTypes {

    public enum TransformerStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [TransformerStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "active"
            case .inactive: return "inactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateTransformerOutput: Swift.Sendable {
    /// Returns a timestamp for creation date and time of the transformer.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var ediType: B2biClientTypes.EdiType?
    /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Returns the InputConversion object, which contains the format options for the inbound transformation.
    public var inputConversion: B2biClientTypes.InputConversion?
    /// Returns the structure that contains the mapping template and its language (either XSLT or JSONATA).
    public var mapping: B2biClientTypes.Mapping?
    /// Returns the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var mappingTemplate: Swift.String?
    /// Returns the name of the transformer, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the OutputConversion object, which contains the format options for the outbound transformation.
    public var outputConversion: B2biClientTypes.OutputConversion?
    /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var sampleDocument: Swift.String?
    /// Returns a structure that contains the Amazon S3 bucket and an array of the corresponding keys used to identify the location for your sample documents.
    public var sampleDocuments: B2biClientTypes.SampleDocuments?
    /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
    /// This member is required.
    public var status: B2biClientTypes.TransformerStatus?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var transformerArn: Swift.String?
    /// Returns the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = .notUsed,
        inputConversion: B2biClientTypes.InputConversion? = nil,
        mapping: B2biClientTypes.Mapping? = nil,
        mappingTemplate: Swift.String? = "NOT_USED",
        name: Swift.String? = nil,
        outputConversion: B2biClientTypes.OutputConversion? = nil,
        sampleDocument: Swift.String? = nil,
        sampleDocuments: B2biClientTypes.SampleDocuments? = nil,
        status: B2biClientTypes.TransformerStatus? = nil,
        transformerArn: Swift.String? = nil,
        transformerId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.inputConversion = inputConversion
        self.mapping = mapping
        self.mappingTemplate = mappingTemplate
        self.name = name
        self.outputConversion = outputConversion
        self.sampleDocument = sampleDocument
        self.sampleDocuments = sampleDocuments
        self.status = status
        self.transformerArn = transformerArn
        self.transformerId = transformerId
    }
}

public struct DeleteTransformerInput: Swift.Sendable {
    /// Specifies the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        transformerId: Swift.String? = nil
    )
    {
        self.transformerId = transformerId
    }
}

public struct GetTransformerInput: Swift.Sendable {
    /// Specifies the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        transformerId: Swift.String? = nil
    )
    {
        self.transformerId = transformerId
    }
}

public struct GetTransformerOutput: Swift.Sendable {
    /// Returns a timestamp for creation date and time of the transformer.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var ediType: B2biClientTypes.EdiType?
    /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Returns the InputConversion object, which contains the format options for the inbound transformation.
    public var inputConversion: B2biClientTypes.InputConversion?
    /// Returns the structure that contains the mapping template and its language (either XSLT or JSONATA).
    public var mapping: B2biClientTypes.Mapping?
    /// Returns the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var mappingTemplate: Swift.String?
    /// Returns a timestamp for last time the transformer was modified.
    public var modifiedAt: Foundation.Date?
    /// Returns the name of the transformer, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the OutputConversion object, which contains the format options for the outbound transformation.
    public var outputConversion: B2biClientTypes.OutputConversion?
    /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var sampleDocument: Swift.String?
    /// Returns a structure that contains the Amazon S3 bucket and an array of the corresponding keys used to identify the location for your sample documents.
    public var sampleDocuments: B2biClientTypes.SampleDocuments?
    /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
    /// This member is required.
    public var status: B2biClientTypes.TransformerStatus?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var transformerArn: Swift.String?
    /// Returns the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = .notUsed,
        inputConversion: B2biClientTypes.InputConversion? = nil,
        mapping: B2biClientTypes.Mapping? = nil,
        mappingTemplate: Swift.String? = "NOT_USED",
        modifiedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        outputConversion: B2biClientTypes.OutputConversion? = nil,
        sampleDocument: Swift.String? = nil,
        sampleDocuments: B2biClientTypes.SampleDocuments? = nil,
        status: B2biClientTypes.TransformerStatus? = nil,
        transformerArn: Swift.String? = nil,
        transformerId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.inputConversion = inputConversion
        self.mapping = mapping
        self.mappingTemplate = mappingTemplate
        self.modifiedAt = modifiedAt
        self.name = name
        self.outputConversion = outputConversion
        self.sampleDocument = sampleDocument
        self.sampleDocuments = sampleDocuments
        self.status = status
        self.transformerArn = transformerArn
        self.transformerId = transformerId
    }
}

public struct ListTransformersInput: Swift.Sendable {
    /// Specifies the number of items to return for the API response.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension B2biClientTypes {

    /// Contains the details for a transformer object. A transformer can take an EDI file as input and transform it into a JSON-or XML-formatted document. Alternatively, a transformer can take a JSON-or XML-formatted document as input and transform it into an EDI file.
    public struct TransformerSummary: Swift.Sendable {
        /// Returns a timestamp indicating when the transformer was created. For example, 2023-07-20T19:58:44.624Z.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
        public var ediType: B2biClientTypes.EdiType?
        /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
        @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
        public var fileFormat: B2biClientTypes.FileFormat?
        /// Returns a structure that contains the format options for the transformation.
        public var inputConversion: B2biClientTypes.InputConversion?
        /// Returns the structure that contains the mapping template and its language (either XSLT or JSONATA).
        public var mapping: B2biClientTypes.Mapping?
        /// Returns the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.
        @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
        public var mappingTemplate: Swift.String?
        /// Returns a timestamp representing the date and time for the most recent change for the transformer object.
        public var modifiedAt: Foundation.Date?
        /// Returns the descriptive name for the transformer.
        /// This member is required.
        public var name: Swift.String?
        /// Returns the OutputConversion object, which contains the format options for the outbound transformation.
        public var outputConversion: B2biClientTypes.OutputConversion?
        /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
        @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
        public var sampleDocument: Swift.String?
        /// Returns a structure that contains the Amazon S3 bucket and an array of the corresponding keys used to identify the location for your sample documents.
        public var sampleDocuments: B2biClientTypes.SampleDocuments?
        /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
        /// This member is required.
        public var status: B2biClientTypes.TransformerStatus?
        /// Returns the system-assigned unique identifier for the transformer.
        /// This member is required.
        public var transformerId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            ediType: B2biClientTypes.EdiType? = nil,
            fileFormat: B2biClientTypes.FileFormat? = .notUsed,
            inputConversion: B2biClientTypes.InputConversion? = nil,
            mapping: B2biClientTypes.Mapping? = nil,
            mappingTemplate: Swift.String? = "NOT_USED",
            modifiedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            outputConversion: B2biClientTypes.OutputConversion? = nil,
            sampleDocument: Swift.String? = nil,
            sampleDocuments: B2biClientTypes.SampleDocuments? = nil,
            status: B2biClientTypes.TransformerStatus? = nil,
            transformerId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.ediType = ediType
            self.fileFormat = fileFormat
            self.inputConversion = inputConversion
            self.mapping = mapping
            self.mappingTemplate = mappingTemplate
            self.modifiedAt = modifiedAt
            self.name = name
            self.outputConversion = outputConversion
            self.sampleDocument = sampleDocument
            self.sampleDocuments = sampleDocuments
            self.status = status
            self.transformerId = transformerId
        }
    }
}

public struct ListTransformersOutput: Swift.Sendable {
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?
    /// Returns an array of one or more transformer objects. For each transformer, a TransformerSummary object is returned. The TransformerSummary contains all the details for a specific transformer.
    /// This member is required.
    public var transformers: [B2biClientTypes.TransformerSummary]?

    public init(
        nextToken: Swift.String? = nil,
        transformers: [B2biClientTypes.TransformerSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.transformers = transformers
    }
}

public struct UpdateTransformerInput: Swift.Sendable {
    /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var ediType: B2biClientTypes.EdiType?
    /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var fileFormat: B2biClientTypes.FileFormat?
    /// To update, specify the InputConversion object, which contains the format options for the inbound transformation.
    public var inputConversion: B2biClientTypes.InputConversion?
    /// Specify the structure that contains the mapping template and its language (either XSLT or JSONATA).
    public var mapping: B2biClientTypes.Mapping?
    /// Specifies the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT. This parameter is available for backwards compatibility. Use the [Mapping](https://docs.aws.amazon.com/b2bi/latest/APIReference/API_Mapping.html) data type instead.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var mappingTemplate: Swift.String?
    /// Specify a new name for the transformer, if you want to update it.
    public var name: Swift.String?
    /// To update, specify the OutputConversion object, which contains the format options for the outbound transformation.
    public var outputConversion: B2biClientTypes.OutputConversion?
    /// Specifies a sample EDI document that is used by a transformer as a guide for processing the EDI data.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var sampleDocument: Swift.String?
    /// Specify a structure that contains the Amazon S3 bucket and an array of the corresponding keys used to identify the location for your sample documents.
    public var sampleDocuments: B2biClientTypes.SampleDocuments?
    /// Specifies the transformer's status. You can update the state of the transformer, from active to inactive, or inactive to active.
    public var status: B2biClientTypes.TransformerStatus?
    /// Specifies the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = nil,
        inputConversion: B2biClientTypes.InputConversion? = nil,
        mapping: B2biClientTypes.Mapping? = nil,
        mappingTemplate: Swift.String? = nil,
        name: Swift.String? = nil,
        outputConversion: B2biClientTypes.OutputConversion? = nil,
        sampleDocument: Swift.String? = nil,
        sampleDocuments: B2biClientTypes.SampleDocuments? = nil,
        status: B2biClientTypes.TransformerStatus? = nil,
        transformerId: Swift.String? = nil
    )
    {
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.inputConversion = inputConversion
        self.mapping = mapping
        self.mappingTemplate = mappingTemplate
        self.name = name
        self.outputConversion = outputConversion
        self.sampleDocument = sampleDocument
        self.sampleDocuments = sampleDocuments
        self.status = status
        self.transformerId = transformerId
    }
}

public struct UpdateTransformerOutput: Swift.Sendable {
    /// Returns a timestamp for creation date and time of the transformer.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var ediType: B2biClientTypes.EdiType?
    /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Returns the InputConversion object, which contains the format options for the inbound transformation.
    public var inputConversion: B2biClientTypes.InputConversion?
    /// Returns the structure that contains the mapping template and its language (either XSLT or JSONATA).
    public var mapping: B2biClientTypes.Mapping?
    /// Returns the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var mappingTemplate: Swift.String?
    /// Returns a timestamp for last time the transformer was modified.
    /// This member is required.
    public var modifiedAt: Foundation.Date?
    /// Returns the name of the transformer.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the OutputConversion object, which contains the format options for the outbound transformation.
    public var outputConversion: B2biClientTypes.OutputConversion?
    /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
    @available(*, deprecated, message: "This is a legacy trait. Please use input-conversion or output-conversion.")
    public var sampleDocument: Swift.String?
    /// Returns a structure that contains the Amazon S3 bucket and an array of the corresponding keys used to identify the location for your sample documents.
    public var sampleDocuments: B2biClientTypes.SampleDocuments?
    /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
    /// This member is required.
    public var status: B2biClientTypes.TransformerStatus?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var transformerArn: Swift.String?
    /// Returns the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = .notUsed,
        inputConversion: B2biClientTypes.InputConversion? = nil,
        mapping: B2biClientTypes.Mapping? = nil,
        mappingTemplate: Swift.String? = "NOT_USED",
        modifiedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        outputConversion: B2biClientTypes.OutputConversion? = nil,
        sampleDocument: Swift.String? = nil,
        sampleDocuments: B2biClientTypes.SampleDocuments? = nil,
        status: B2biClientTypes.TransformerStatus? = nil,
        transformerArn: Swift.String? = nil,
        transformerId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.inputConversion = inputConversion
        self.mapping = mapping
        self.mappingTemplate = mappingTemplate
        self.modifiedAt = modifiedAt
        self.name = name
        self.outputConversion = outputConversion
        self.sampleDocument = sampleDocument
        self.sampleDocuments = sampleDocuments
        self.status = status
        self.transformerArn = transformerArn
        self.transformerId = transformerId
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// Specifies an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

extension CreateCapabilityInput {

    static func urlPathProvider(_ value: CreateCapabilityInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePartnershipInput {

    static func urlPathProvider(_ value: CreatePartnershipInput) -> Swift.String? {
        return "/"
    }
}

extension CreateProfileInput {

    static func urlPathProvider(_ value: CreateProfileInput) -> Swift.String? {
        return "/"
    }
}

extension CreateStarterMappingTemplateInput {

    static func urlPathProvider(_ value: CreateStarterMappingTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTransformerInput {

    static func urlPathProvider(_ value: CreateTransformerInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCapabilityInput {

    static func urlPathProvider(_ value: DeleteCapabilityInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePartnershipInput {

    static func urlPathProvider(_ value: DeletePartnershipInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteProfileInput {

    static func urlPathProvider(_ value: DeleteProfileInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTransformerInput {

    static func urlPathProvider(_ value: DeleteTransformerInput) -> Swift.String? {
        return "/"
    }
}

extension GetCapabilityInput {

    static func urlPathProvider(_ value: GetCapabilityInput) -> Swift.String? {
        return "/"
    }
}

extension GetPartnershipInput {

    static func urlPathProvider(_ value: GetPartnershipInput) -> Swift.String? {
        return "/"
    }
}

extension GetProfileInput {

    static func urlPathProvider(_ value: GetProfileInput) -> Swift.String? {
        return "/"
    }
}

extension GetTransformerInput {

    static func urlPathProvider(_ value: GetTransformerInput) -> Swift.String? {
        return "/"
    }
}

extension GetTransformerJobInput {

    static func urlPathProvider(_ value: GetTransformerJobInput) -> Swift.String? {
        return "/"
    }
}

extension GetTransformerJobInput {

    static func queryItemProvider(_ value: GetTransformerJobInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListCapabilitiesInput {

    static func urlPathProvider(_ value: ListCapabilitiesInput) -> Swift.String? {
        return "/"
    }
}

extension ListCapabilitiesInput {

    static func queryItemProvider(_ value: ListCapabilitiesInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListPartnershipsInput {

    static func urlPathProvider(_ value: ListPartnershipsInput) -> Swift.String? {
        return "/"
    }
}

extension ListPartnershipsInput {

    static func queryItemProvider(_ value: ListPartnershipsInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListProfilesInput {

    static func urlPathProvider(_ value: ListProfilesInput) -> Swift.String? {
        return "/"
    }
}

extension ListProfilesInput {

    static func queryItemProvider(_ value: ListProfilesInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListTransformersInput {

    static func urlPathProvider(_ value: ListTransformersInput) -> Swift.String? {
        return "/"
    }
}

extension ListTransformersInput {

    static func queryItemProvider(_ value: ListTransformersInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension StartTransformerJobInput {

    static func urlPathProvider(_ value: StartTransformerJobInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TestConversionInput {

    static func urlPathProvider(_ value: TestConversionInput) -> Swift.String? {
        return "/"
    }
}

extension TestMappingInput {

    static func urlPathProvider(_ value: TestMappingInput) -> Swift.String? {
        return "/"
    }
}

extension TestParsingInput {

    static func urlPathProvider(_ value: TestParsingInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension UpdateCapabilityInput {

    static func urlPathProvider(_ value: UpdateCapabilityInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePartnershipInput {

    static func urlPathProvider(_ value: UpdatePartnershipInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateProfileInput {

    static func urlPathProvider(_ value: UpdateProfileInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateTransformerInput {

    static func urlPathProvider(_ value: UpdateTransformerInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCapabilityInput {

    static func write(value: CreateCapabilityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["configuration"].write(value.configuration, with: B2biClientTypes.CapabilityConfiguration.write(value:to:))
        try writer["instructionsDocuments"].writeList(value.instructionsDocuments, memberWritingClosure: B2biClientTypes.S3Location.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["tags"].writeList(value.tags, memberWritingClosure: B2biClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension CreatePartnershipInput {

    static func write(value: CreatePartnershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capabilities"].writeList(value.capabilities, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["capabilityOptions"].write(value.capabilityOptions, with: B2biClientTypes.CapabilityOptions.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["email"].write(value.email)
        try writer["name"].write(value.name)
        try writer["phone"].write(value.phone)
        try writer["profileId"].write(value.profileId)
        try writer["tags"].writeList(value.tags, memberWritingClosure: B2biClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateProfileInput {

    static func write(value: CreateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["businessName"].write(value.businessName)
        try writer["clientToken"].write(value.clientToken)
        try writer["email"].write(value.email)
        try writer["logging"].write(value.logging)
        try writer["name"].write(value.name)
        try writer["phone"].write(value.phone)
        try writer["tags"].writeList(value.tags, memberWritingClosure: B2biClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateStarterMappingTemplateInput {

    static func write(value: CreateStarterMappingTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["mappingType"].write(value.mappingType)
        try writer["outputSampleLocation"].write(value.outputSampleLocation, with: B2biClientTypes.S3Location.write(value:to:))
        try writer["templateDetails"].write(value.templateDetails, with: B2biClientTypes.TemplateDetails.write(value:to:))
    }
}

extension CreateTransformerInput {

    static func write(value: CreateTransformerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["ediType"].write(value.ediType, with: B2biClientTypes.EdiType.write(value:to:))
        try writer["fileFormat"].write(value.fileFormat)
        try writer["inputConversion"].write(value.inputConversion, with: B2biClientTypes.InputConversion.write(value:to:))
        try writer["mapping"].write(value.mapping, with: B2biClientTypes.Mapping.write(value:to:))
        try writer["mappingTemplate"].write(value.mappingTemplate)
        try writer["name"].write(value.name)
        try writer["outputConversion"].write(value.outputConversion, with: B2biClientTypes.OutputConversion.write(value:to:))
        try writer["sampleDocument"].write(value.sampleDocument)
        try writer["sampleDocuments"].write(value.sampleDocuments, with: B2biClientTypes.SampleDocuments.write(value:to:))
        try writer["tags"].writeList(value.tags, memberWritingClosure: B2biClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteCapabilityInput {

    static func write(value: DeleteCapabilityInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeletePartnershipInput {

    static func write(value: DeletePartnershipInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteProfileInput {

    static func write(value: DeleteProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteTransformerInput {

    static func write(value: DeleteTransformerInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetCapabilityInput {

    static func write(value: GetCapabilityInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetPartnershipInput {

    static func write(value: GetPartnershipInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetProfileInput {

    static func write(value: GetProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetTransformerInput {

    static func write(value: GetTransformerInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetTransformerJobInput {

    static func write(value: GetTransformerJobInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListCapabilitiesInput {

    static func write(value: ListCapabilitiesInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListPartnershipsInput {

    static func write(value: ListPartnershipsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListProfilesInput {

    static func write(value: ListProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListTransformersInput {

    static func write(value: ListTransformersInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension StartTransformerJobInput {

    static func write(value: StartTransformerJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["inputFile"].write(value.inputFile, with: B2biClientTypes.S3Location.write(value:to:))
        try writer["outputLocation"].write(value.outputLocation, with: B2biClientTypes.S3Location.write(value:to:))
        try writer["transformerId"].write(value.transformerId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: B2biClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TestConversionInput {

    static func write(value: TestConversionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["source"].write(value.source, with: B2biClientTypes.ConversionSource.write(value:to:))
        try writer["target"].write(value.target, with: B2biClientTypes.ConversionTarget.write(value:to:))
    }
}

extension TestMappingInput {

    static func write(value: TestMappingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileFormat"].write(value.fileFormat)
        try writer["inputFileContent"].write(value.inputFileContent)
        try writer["mappingTemplate"].write(value.mappingTemplate)
    }
}

extension TestParsingInput {

    static func write(value: TestParsingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ediType"].write(value.ediType, with: B2biClientTypes.EdiType.write(value:to:))
        try writer["fileFormat"].write(value.fileFormat)
        try writer["inputFile"].write(value.inputFile, with: B2biClientTypes.S3Location.write(value:to:))
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension UpdateCapabilityInput {

    static func write(value: UpdateCapabilityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration, with: B2biClientTypes.CapabilityConfiguration.write(value:to:))
        try writer["instructionsDocuments"].writeList(value.instructionsDocuments, memberWritingClosure: B2biClientTypes.S3Location.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
    }
}

extension UpdatePartnershipInput {

    static func write(value: UpdatePartnershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capabilities"].writeList(value.capabilities, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["capabilityOptions"].write(value.capabilityOptions, with: B2biClientTypes.CapabilityOptions.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension UpdateProfileInput {

    static func write(value: UpdateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["businessName"].write(value.businessName)
        try writer["email"].write(value.email)
        try writer["name"].write(value.name)
        try writer["phone"].write(value.phone)
    }
}

extension UpdateTransformerInput {

    static func write(value: UpdateTransformerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ediType"].write(value.ediType, with: B2biClientTypes.EdiType.write(value:to:))
        try writer["fileFormat"].write(value.fileFormat)
        try writer["inputConversion"].write(value.inputConversion, with: B2biClientTypes.InputConversion.write(value:to:))
        try writer["mapping"].write(value.mapping, with: B2biClientTypes.Mapping.write(value:to:))
        try writer["mappingTemplate"].write(value.mappingTemplate)
        try writer["name"].write(value.name)
        try writer["outputConversion"].write(value.outputConversion, with: B2biClientTypes.OutputConversion.write(value:to:))
        try writer["sampleDocument"].write(value.sampleDocument)
        try writer["sampleDocuments"].write(value.sampleDocuments, with: B2biClientTypes.SampleDocuments.write(value:to:))
        try writer["status"].write(value.status)
    }
}

extension CreateCapabilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCapabilityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCapabilityOutput()
        value.capabilityArn = try reader["capabilityArn"].readIfPresent() ?? ""
        value.capabilityId = try reader["capabilityId"].readIfPresent() ?? ""
        value.configuration = try reader["configuration"].readIfPresent(with: B2biClientTypes.CapabilityConfiguration.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.instructionsDocuments = try reader["instructionsDocuments"].readListIfPresent(memberReadingClosure: B2biClientTypes.S3Location.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreatePartnershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePartnershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePartnershipOutput()
        value.capabilities = try reader["capabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.capabilityOptions = try reader["capabilityOptions"].readIfPresent(with: B2biClientTypes.CapabilityOptions.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.email = try reader["email"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.partnershipArn = try reader["partnershipArn"].readIfPresent() ?? ""
        value.partnershipId = try reader["partnershipId"].readIfPresent() ?? ""
        value.phone = try reader["phone"].readIfPresent()
        value.profileId = try reader["profileId"].readIfPresent() ?? ""
        value.tradingPartnerId = try reader["tradingPartnerId"].readIfPresent()
        return value
    }
}

extension CreateProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProfileOutput()
        value.businessName = try reader["businessName"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.email = try reader["email"].readIfPresent()
        value.logGroupName = try reader["logGroupName"].readIfPresent()
        value.logging = try reader["logging"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.phone = try reader["phone"].readIfPresent() ?? ""
        value.profileArn = try reader["profileArn"].readIfPresent() ?? ""
        value.profileId = try reader["profileId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateStarterMappingTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStarterMappingTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStarterMappingTemplateOutput()
        value.mappingTemplate = try reader["mappingTemplate"].readIfPresent() ?? ""
        return value
    }
}

extension CreateTransformerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTransformerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTransformerOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.ediType = try reader["ediType"].readIfPresent(with: B2biClientTypes.EdiType.read(from:))
        value.fileFormat = try reader["fileFormat"].readIfPresent() ?? .notUsed
        value.inputConversion = try reader["inputConversion"].readIfPresent(with: B2biClientTypes.InputConversion.read(from:))
        value.mapping = try reader["mapping"].readIfPresent(with: B2biClientTypes.Mapping.read(from:))
        value.mappingTemplate = try reader["mappingTemplate"].readIfPresent() ?? "NOT_USED"
        value.name = try reader["name"].readIfPresent() ?? ""
        value.outputConversion = try reader["outputConversion"].readIfPresent(with: B2biClientTypes.OutputConversion.read(from:))
        value.sampleDocument = try reader["sampleDocument"].readIfPresent()
        value.sampleDocuments = try reader["sampleDocuments"].readIfPresent(with: B2biClientTypes.SampleDocuments.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.transformerArn = try reader["transformerArn"].readIfPresent() ?? ""
        value.transformerId = try reader["transformerId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteCapabilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCapabilityOutput {
        return DeleteCapabilityOutput()
    }
}

extension DeletePartnershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePartnershipOutput {
        return DeletePartnershipOutput()
    }
}

extension DeleteProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProfileOutput {
        return DeleteProfileOutput()
    }
}

extension DeleteTransformerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTransformerOutput {
        return DeleteTransformerOutput()
    }
}

extension GetCapabilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCapabilityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCapabilityOutput()
        value.capabilityArn = try reader["capabilityArn"].readIfPresent() ?? ""
        value.capabilityId = try reader["capabilityId"].readIfPresent() ?? ""
        value.configuration = try reader["configuration"].readIfPresent(with: B2biClientTypes.CapabilityConfiguration.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.instructionsDocuments = try reader["instructionsDocuments"].readListIfPresent(memberReadingClosure: B2biClientTypes.S3Location.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetPartnershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPartnershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPartnershipOutput()
        value.capabilities = try reader["capabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.capabilityOptions = try reader["capabilityOptions"].readIfPresent(with: B2biClientTypes.CapabilityOptions.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.email = try reader["email"].readIfPresent()
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.partnershipArn = try reader["partnershipArn"].readIfPresent() ?? ""
        value.partnershipId = try reader["partnershipId"].readIfPresent() ?? ""
        value.phone = try reader["phone"].readIfPresent()
        value.profileId = try reader["profileId"].readIfPresent() ?? ""
        value.tradingPartnerId = try reader["tradingPartnerId"].readIfPresent()
        return value
    }
}

extension GetProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProfileOutput()
        value.businessName = try reader["businessName"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.email = try reader["email"].readIfPresent()
        value.logGroupName = try reader["logGroupName"].readIfPresent()
        value.logging = try reader["logging"].readIfPresent()
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.phone = try reader["phone"].readIfPresent() ?? ""
        value.profileArn = try reader["profileArn"].readIfPresent() ?? ""
        value.profileId = try reader["profileId"].readIfPresent() ?? ""
        return value
    }
}

extension GetTransformerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTransformerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTransformerOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.ediType = try reader["ediType"].readIfPresent(with: B2biClientTypes.EdiType.read(from:))
        value.fileFormat = try reader["fileFormat"].readIfPresent() ?? .notUsed
        value.inputConversion = try reader["inputConversion"].readIfPresent(with: B2biClientTypes.InputConversion.read(from:))
        value.mapping = try reader["mapping"].readIfPresent(with: B2biClientTypes.Mapping.read(from:))
        value.mappingTemplate = try reader["mappingTemplate"].readIfPresent() ?? "NOT_USED"
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.outputConversion = try reader["outputConversion"].readIfPresent(with: B2biClientTypes.OutputConversion.read(from:))
        value.sampleDocument = try reader["sampleDocument"].readIfPresent()
        value.sampleDocuments = try reader["sampleDocuments"].readIfPresent(with: B2biClientTypes.SampleDocuments.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.transformerArn = try reader["transformerArn"].readIfPresent() ?? ""
        value.transformerId = try reader["transformerId"].readIfPresent() ?? ""
        return value
    }
}

extension GetTransformerJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTransformerJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTransformerJobOutput()
        value.message = try reader["message"].readIfPresent()
        value.outputFiles = try reader["outputFiles"].readListIfPresent(memberReadingClosure: B2biClientTypes.S3Location.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ListCapabilitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCapabilitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCapabilitiesOutput()
        value.capabilities = try reader["capabilities"].readListIfPresent(memberReadingClosure: B2biClientTypes.CapabilitySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListPartnershipsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPartnershipsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPartnershipsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.partnerships = try reader["partnerships"].readListIfPresent(memberReadingClosure: B2biClientTypes.PartnershipSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProfilesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.profiles = try reader["profiles"].readListIfPresent(memberReadingClosure: B2biClientTypes.ProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: B2biClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTransformersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTransformersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTransformersOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.transformers = try reader["transformers"].readListIfPresent(memberReadingClosure: B2biClientTypes.TransformerSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension StartTransformerJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartTransformerJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartTransformerJobOutput()
        value.transformerJobId = try reader["transformerJobId"].readIfPresent() ?? ""
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TestConversionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestConversionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TestConversionOutput()
        value.convertedFileContent = try reader["convertedFileContent"].readIfPresent() ?? ""
        value.validationMessages = try reader["validationMessages"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TestMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TestMappingOutput()
        value.mappedFileContent = try reader["mappedFileContent"].readIfPresent() ?? ""
        return value
    }
}

extension TestParsingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestParsingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TestParsingOutput()
        value.parsedFileContent = try reader["parsedFileContent"].readIfPresent() ?? ""
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateCapabilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCapabilityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCapabilityOutput()
        value.capabilityArn = try reader["capabilityArn"].readIfPresent() ?? ""
        value.capabilityId = try reader["capabilityId"].readIfPresent() ?? ""
        value.configuration = try reader["configuration"].readIfPresent(with: B2biClientTypes.CapabilityConfiguration.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.instructionsDocuments = try reader["instructionsDocuments"].readListIfPresent(memberReadingClosure: B2biClientTypes.S3Location.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension UpdatePartnershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePartnershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePartnershipOutput()
        value.capabilities = try reader["capabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.capabilityOptions = try reader["capabilityOptions"].readIfPresent(with: B2biClientTypes.CapabilityOptions.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.email = try reader["email"].readIfPresent()
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.partnershipArn = try reader["partnershipArn"].readIfPresent() ?? ""
        value.partnershipId = try reader["partnershipId"].readIfPresent() ?? ""
        value.phone = try reader["phone"].readIfPresent()
        value.profileId = try reader["profileId"].readIfPresent() ?? ""
        value.tradingPartnerId = try reader["tradingPartnerId"].readIfPresent()
        return value
    }
}

extension UpdateProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProfileOutput()
        value.businessName = try reader["businessName"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.email = try reader["email"].readIfPresent()
        value.logGroupName = try reader["logGroupName"].readIfPresent()
        value.logging = try reader["logging"].readIfPresent()
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.phone = try reader["phone"].readIfPresent() ?? ""
        value.profileArn = try reader["profileArn"].readIfPresent() ?? ""
        value.profileId = try reader["profileId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateTransformerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTransformerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTransformerOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.ediType = try reader["ediType"].readIfPresent(with: B2biClientTypes.EdiType.read(from:))
        value.fileFormat = try reader["fileFormat"].readIfPresent() ?? .notUsed
        value.inputConversion = try reader["inputConversion"].readIfPresent(with: B2biClientTypes.InputConversion.read(from:))
        value.mapping = try reader["mapping"].readIfPresent(with: B2biClientTypes.Mapping.read(from:))
        value.mappingTemplate = try reader["mappingTemplate"].readIfPresent() ?? "NOT_USED"
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.outputConversion = try reader["outputConversion"].readIfPresent(with: B2biClientTypes.OutputConversion.read(from:))
        value.sampleDocument = try reader["sampleDocument"].readIfPresent()
        value.sampleDocuments = try reader["sampleDocuments"].readIfPresent(with: B2biClientTypes.SampleDocuments.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.transformerArn = try reader["transformerArn"].readIfPresent() ?? ""
        value.transformerId = try reader["transformerId"].readIfPresent() ?? ""
        return value
    }
}

enum CreateCapabilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePartnershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStarterMappingTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTransformerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCapabilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePartnershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTransformerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCapabilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPartnershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTransformerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTransformerJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCapabilitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPartnershipsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTransformersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartTransformerJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestConversionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestParsingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCapabilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePartnershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTransformerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension B2biClientTypes.CapabilityConfiguration {

    static func write(value: B2biClientTypes.CapabilityConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .edi(edi):
                try writer["edi"].write(edi, with: B2biClientTypes.EdiConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.CapabilityConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "edi":
                return .edi(try reader["edi"].read(with: B2biClientTypes.EdiConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension B2biClientTypes.EdiConfiguration {

    static func write(value: B2biClientTypes.EdiConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capabilityDirection"].write(value.capabilityDirection)
        try writer["inputLocation"].write(value.inputLocation, with: B2biClientTypes.S3Location.write(value:to:))
        try writer["outputLocation"].write(value.outputLocation, with: B2biClientTypes.S3Location.write(value:to:))
        try writer["transformerId"].write(value.transformerId)
        try writer["type"].write(value.type, with: B2biClientTypes.EdiType.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.EdiConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.EdiConfiguration()
        value.capabilityDirection = try reader["capabilityDirection"].readIfPresent()
        value.type = try reader["type"].readIfPresent(with: B2biClientTypes.EdiType.read(from:))
        value.inputLocation = try reader["inputLocation"].readIfPresent(with: B2biClientTypes.S3Location.read(from:))
        value.outputLocation = try reader["outputLocation"].readIfPresent(with: B2biClientTypes.S3Location.read(from:))
        value.transformerId = try reader["transformerId"].readIfPresent() ?? ""
        return value
    }
}

extension B2biClientTypes.S3Location {

    static func write(value: B2biClientTypes.S3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["key"].write(value.key)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.S3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.S3Location()
        value.bucketName = try reader["bucketName"].readIfPresent()
        value.key = try reader["key"].readIfPresent()
        return value
    }
}

extension B2biClientTypes.EdiType {

    static func write(value: B2biClientTypes.EdiType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .x12details(x12details):
                try writer["x12Details"].write(x12details, with: B2biClientTypes.X12Details.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.EdiType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "x12Details":
                return .x12details(try reader["x12Details"].read(with: B2biClientTypes.X12Details.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension B2biClientTypes.X12Details {

    static func write(value: B2biClientTypes.X12Details?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["transactionSet"].write(value.transactionSet)
        try writer["version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.X12Details {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.X12Details()
        value.transactionSet = try reader["transactionSet"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension B2biClientTypes.CapabilityOptions {

    static func write(value: B2biClientTypes.CapabilityOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["outboundEdi"].write(value.outboundEdi, with: B2biClientTypes.OutboundEdiOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.CapabilityOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.CapabilityOptions()
        value.outboundEdi = try reader["outboundEdi"].readIfPresent(with: B2biClientTypes.OutboundEdiOptions.read(from:))
        return value
    }
}

extension B2biClientTypes.OutboundEdiOptions {

    static func write(value: B2biClientTypes.OutboundEdiOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .x12(x12):
                try writer["x12"].write(x12, with: B2biClientTypes.X12Envelope.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.OutboundEdiOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "x12":
                return .x12(try reader["x12"].read(with: B2biClientTypes.X12Envelope.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension B2biClientTypes.X12Envelope {

    static func write(value: B2biClientTypes.X12Envelope?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["common"].write(value.common, with: B2biClientTypes.X12OutboundEdiHeaders.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.X12Envelope {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.X12Envelope()
        value.common = try reader["common"].readIfPresent(with: B2biClientTypes.X12OutboundEdiHeaders.read(from:))
        return value
    }
}

extension B2biClientTypes.X12OutboundEdiHeaders {

    static func write(value: B2biClientTypes.X12OutboundEdiHeaders?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["delimiters"].write(value.delimiters, with: B2biClientTypes.X12Delimiters.write(value:to:))
        try writer["functionalGroupHeaders"].write(value.functionalGroupHeaders, with: B2biClientTypes.X12FunctionalGroupHeaders.write(value:to:))
        try writer["interchangeControlHeaders"].write(value.interchangeControlHeaders, with: B2biClientTypes.X12InterchangeControlHeaders.write(value:to:))
        try writer["validateEdi"].write(value.validateEdi)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.X12OutboundEdiHeaders {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.X12OutboundEdiHeaders()
        value.interchangeControlHeaders = try reader["interchangeControlHeaders"].readIfPresent(with: B2biClientTypes.X12InterchangeControlHeaders.read(from:))
        value.functionalGroupHeaders = try reader["functionalGroupHeaders"].readIfPresent(with: B2biClientTypes.X12FunctionalGroupHeaders.read(from:))
        value.delimiters = try reader["delimiters"].readIfPresent(with: B2biClientTypes.X12Delimiters.read(from:))
        value.validateEdi = try reader["validateEdi"].readIfPresent()
        return value
    }
}

extension B2biClientTypes.X12Delimiters {

    static func write(value: B2biClientTypes.X12Delimiters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["componentSeparator"].write(value.componentSeparator)
        try writer["dataElementSeparator"].write(value.dataElementSeparator)
        try writer["segmentTerminator"].write(value.segmentTerminator)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.X12Delimiters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.X12Delimiters()
        value.componentSeparator = try reader["componentSeparator"].readIfPresent()
        value.dataElementSeparator = try reader["dataElementSeparator"].readIfPresent()
        value.segmentTerminator = try reader["segmentTerminator"].readIfPresent()
        return value
    }
}

extension B2biClientTypes.X12FunctionalGroupHeaders {

    static func write(value: B2biClientTypes.X12FunctionalGroupHeaders?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationReceiverCode"].write(value.applicationReceiverCode)
        try writer["applicationSenderCode"].write(value.applicationSenderCode)
        try writer["responsibleAgencyCode"].write(value.responsibleAgencyCode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.X12FunctionalGroupHeaders {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.X12FunctionalGroupHeaders()
        value.applicationSenderCode = try reader["applicationSenderCode"].readIfPresent()
        value.applicationReceiverCode = try reader["applicationReceiverCode"].readIfPresent()
        value.responsibleAgencyCode = try reader["responsibleAgencyCode"].readIfPresent()
        return value
    }
}

extension B2biClientTypes.X12InterchangeControlHeaders {

    static func write(value: B2biClientTypes.X12InterchangeControlHeaders?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["acknowledgmentRequestedCode"].write(value.acknowledgmentRequestedCode)
        try writer["receiverId"].write(value.receiverId)
        try writer["receiverIdQualifier"].write(value.receiverIdQualifier)
        try writer["repetitionSeparator"].write(value.repetitionSeparator)
        try writer["senderId"].write(value.senderId)
        try writer["senderIdQualifier"].write(value.senderIdQualifier)
        try writer["usageIndicatorCode"].write(value.usageIndicatorCode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.X12InterchangeControlHeaders {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.X12InterchangeControlHeaders()
        value.senderIdQualifier = try reader["senderIdQualifier"].readIfPresent()
        value.senderId = try reader["senderId"].readIfPresent()
        value.receiverIdQualifier = try reader["receiverIdQualifier"].readIfPresent()
        value.receiverId = try reader["receiverId"].readIfPresent()
        value.repetitionSeparator = try reader["repetitionSeparator"].readIfPresent()
        value.acknowledgmentRequestedCode = try reader["acknowledgmentRequestedCode"].readIfPresent()
        value.usageIndicatorCode = try reader["usageIndicatorCode"].readIfPresent()
        return value
    }
}

extension B2biClientTypes.InputConversion {

    static func write(value: B2biClientTypes.InputConversion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["formatOptions"].write(value.formatOptions, with: B2biClientTypes.FormatOptions.write(value:to:))
        try writer["fromFormat"].write(value.fromFormat)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.InputConversion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.InputConversion()
        value.fromFormat = try reader["fromFormat"].readIfPresent() ?? .sdkUnknown("")
        value.formatOptions = try reader["formatOptions"].readIfPresent(with: B2biClientTypes.FormatOptions.read(from:))
        return value
    }
}

extension B2biClientTypes.FormatOptions {

    static func write(value: B2biClientTypes.FormatOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .x12(x12):
                try writer["x12"].write(x12, with: B2biClientTypes.X12Details.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.FormatOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "x12":
                return .x12(try reader["x12"].read(with: B2biClientTypes.X12Details.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension B2biClientTypes.Mapping {

    static func write(value: B2biClientTypes.Mapping?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["template"].write(value.template)
        try writer["templateLanguage"].write(value.templateLanguage)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.Mapping {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.Mapping()
        value.templateLanguage = try reader["templateLanguage"].readIfPresent() ?? .sdkUnknown("")
        value.template = try reader["template"].readIfPresent()
        return value
    }
}

extension B2biClientTypes.OutputConversion {

    static func write(value: B2biClientTypes.OutputConversion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["formatOptions"].write(value.formatOptions, with: B2biClientTypes.FormatOptions.write(value:to:))
        try writer["toFormat"].write(value.toFormat)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.OutputConversion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.OutputConversion()
        value.toFormat = try reader["toFormat"].readIfPresent() ?? .sdkUnknown("")
        value.formatOptions = try reader["formatOptions"].readIfPresent(with: B2biClientTypes.FormatOptions.read(from:))
        return value
    }
}

extension B2biClientTypes.SampleDocuments {

    static func write(value: B2biClientTypes.SampleDocuments?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["keys"].writeList(value.keys, memberWritingClosure: B2biClientTypes.SampleDocumentKeys.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.SampleDocuments {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.SampleDocuments()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        value.keys = try reader["keys"].readListIfPresent(memberReadingClosure: B2biClientTypes.SampleDocumentKeys.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension B2biClientTypes.SampleDocumentKeys {

    static func write(value: B2biClientTypes.SampleDocumentKeys?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["input"].write(value.input)
        try writer["output"].write(value.output)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.SampleDocumentKeys {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.SampleDocumentKeys()
        value.input = try reader["input"].readIfPresent()
        value.output = try reader["output"].readIfPresent()
        return value
    }
}

extension B2biClientTypes.CapabilitySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.CapabilitySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.CapabilitySummary()
        value.capabilityId = try reader["capabilityId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension B2biClientTypes.PartnershipSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.PartnershipSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.PartnershipSummary()
        value.profileId = try reader["profileId"].readIfPresent() ?? ""
        value.partnershipId = try reader["partnershipId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.capabilities = try reader["capabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.capabilityOptions = try reader["capabilityOptions"].readIfPresent(with: B2biClientTypes.CapabilityOptions.read(from:))
        value.tradingPartnerId = try reader["tradingPartnerId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension B2biClientTypes.ProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.ProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.ProfileSummary()
        value.profileId = try reader["profileId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.businessName = try reader["businessName"].readIfPresent() ?? ""
        value.logging = try reader["logging"].readIfPresent()
        value.logGroupName = try reader["logGroupName"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension B2biClientTypes.Tag {

    static func write(value: B2biClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension B2biClientTypes.TransformerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.TransformerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.TransformerSummary()
        value.transformerId = try reader["transformerId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.fileFormat = try reader["fileFormat"].readIfPresent() ?? .notUsed
        value.mappingTemplate = try reader["mappingTemplate"].readIfPresent() ?? "NOT_USED"
        value.ediType = try reader["ediType"].readIfPresent(with: B2biClientTypes.EdiType.read(from:))
        value.sampleDocument = try reader["sampleDocument"].readIfPresent()
        value.inputConversion = try reader["inputConversion"].readIfPresent(with: B2biClientTypes.InputConversion.read(from:))
        value.mapping = try reader["mapping"].readIfPresent(with: B2biClientTypes.Mapping.read(from:))
        value.outputConversion = try reader["outputConversion"].readIfPresent(with: B2biClientTypes.OutputConversion.read(from:))
        value.sampleDocuments = try reader["sampleDocuments"].readIfPresent(with: B2biClientTypes.SampleDocuments.read(from:))
        return value
    }
}

extension B2biClientTypes.TemplateDetails {

    static func write(value: B2biClientTypes.TemplateDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .x12(x12):
                try writer["x12"].write(x12, with: B2biClientTypes.X12Details.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension B2biClientTypes.ConversionSource {

    static func write(value: B2biClientTypes.ConversionSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileFormat"].write(value.fileFormat)
        try writer["inputFile"].write(value.inputFile, with: B2biClientTypes.InputFileSource.write(value:to:))
    }
}

extension B2biClientTypes.InputFileSource {

    static func write(value: B2biClientTypes.InputFileSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .filecontent(filecontent):
                try writer["fileContent"].write(filecontent)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension B2biClientTypes.ConversionTarget {

    static func write(value: B2biClientTypes.ConversionTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileFormat"].write(value.fileFormat)
        try writer["formatDetails"].write(value.formatDetails, with: B2biClientTypes.ConversionTargetFormatDetails.write(value:to:))
        try writer["outputSampleFile"].write(value.outputSampleFile, with: B2biClientTypes.OutputSampleFileSource.write(value:to:))
    }
}

extension B2biClientTypes.OutputSampleFileSource {

    static func write(value: B2biClientTypes.OutputSampleFileSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .filelocation(filelocation):
                try writer["fileLocation"].write(filelocation, with: B2biClientTypes.S3Location.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension B2biClientTypes.ConversionTargetFormatDetails {

    static func write(value: B2biClientTypes.ConversionTargetFormatDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .x12(x12):
                try writer["x12"].write(x12, with: B2biClientTypes.X12Details.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

public enum B2biClientTypes {}
