//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

public struct DeleteCapabilityOutput {

    public init() { }
}

public struct DeletePartnershipOutput {

    public init() { }
}

public struct DeleteProfileOutput {

    public init() { }
}

public struct DeleteTransformerOutput {

    public init() { }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceOutput {

    public init() { }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A conflict exception is thrown when you attempt to delete a resource (such as a profile or a capability) that is being used by other resources.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is thrown when an error occurs in the Amazon Web Services B2B Data Interchange service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The server attempts to retry a failed command.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// Occurs when the requested resource does not exist, or cannot be found. In some cases, the resource exists in a region other than the region specified in the API call.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Occurs when the calling command attempts to exceed one of the service quotas, for example trying to create a capability when you already have the maximum number of capabilities allowed.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota that was exceeded, which caused the exception.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID for the resource that exceeded the quota, which caused the exception.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type (profile, partnership, transformer, or capability) that exceeded the quota, which caused the exception.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The code responsible for exceeding the quota, which caused the exception.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// The request was denied due to throttling: the data speed and rendering may be limited depending on various parameters and conditions.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The server attempts to retry a command that was throttled.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// Occurs when a B2BI object cannot be validated against a request from another object.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension B2biClientTypes {
    /// Specifies the details for the Amazon S3 file location that is being used with Amazon Web Services B2BI Data Interchange. File locations in Amazon S3 are identified using a combination of the bucket and key.
    public struct S3Location {
        /// Specifies the name of the Amazon S3 bucket.
        public var bucketName: Swift.String?
        /// Specifies the Amazon S3 key for the file location.
        public var key: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.key = key
        }
    }

}

extension B2biClientTypes {

    public enum X12TransactionSet: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case x12110
        case x12180
        case x12204
        case x12210
        case x12211
        case x12214
        case x12215
        case x12259
        case x12260
        case x12266
        case x12269
        case x12270
        case x12270X279
        case x12271
        case x12271X279
        case x12274
        case x12275
        case x12275X210
        case x12275X211
        case x12276
        case x12276X212
        case x12277
        case x12277X212
        case x12277X214
        case x12277X364
        case x12278
        case x12278X217
        case x12310
        case x12315
        case x12322
        case x12404
        case x12410
        case x12417
        case x12421
        case x12426
        case x12810
        case x12820
        case x12820X218
        case x12820X306
        case x12824
        case x12824X186
        case x12830
        case x12832
        case x12834
        case x12834X220
        case x12834X307
        case x12834X318
        case x12835
        case x12835X221
        case x12837
        case x12837X222
        case x12837X223
        case x12837X224
        case x12837X291
        case x12837X292
        case x12837X298
        case x12844
        case x12846
        case x12849
        case x12850
        case x12852
        case x12855
        case x12856
        case x12860
        case x12861
        case x12864
        case x12865
        case x12869
        case x12870
        case x12940
        case x12945
        case x12990
        case x12997
        case x12999
        case x12999X231
        case sdkUnknown(Swift.String)

        public static var allCases: [X12TransactionSet] {
            return [
                .x12110,
                .x12180,
                .x12204,
                .x12210,
                .x12211,
                .x12214,
                .x12215,
                .x12259,
                .x12260,
                .x12266,
                .x12269,
                .x12270,
                .x12270X279,
                .x12271,
                .x12271X279,
                .x12274,
                .x12275,
                .x12275X210,
                .x12275X211,
                .x12276,
                .x12276X212,
                .x12277,
                .x12277X212,
                .x12277X214,
                .x12277X364,
                .x12278,
                .x12278X217,
                .x12310,
                .x12315,
                .x12322,
                .x12404,
                .x12410,
                .x12417,
                .x12421,
                .x12426,
                .x12810,
                .x12820,
                .x12820X218,
                .x12820X306,
                .x12824,
                .x12824X186,
                .x12830,
                .x12832,
                .x12834,
                .x12834X220,
                .x12834X307,
                .x12834X318,
                .x12835,
                .x12835X221,
                .x12837,
                .x12837X222,
                .x12837X223,
                .x12837X224,
                .x12837X291,
                .x12837X292,
                .x12837X298,
                .x12844,
                .x12846,
                .x12849,
                .x12850,
                .x12852,
                .x12855,
                .x12856,
                .x12860,
                .x12861,
                .x12864,
                .x12865,
                .x12869,
                .x12870,
                .x12940,
                .x12945,
                .x12990,
                .x12997,
                .x12999,
                .x12999X231
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .x12110: return "X12_110"
            case .x12180: return "X12_180"
            case .x12204: return "X12_204"
            case .x12210: return "X12_210"
            case .x12211: return "X12_211"
            case .x12214: return "X12_214"
            case .x12215: return "X12_215"
            case .x12259: return "X12_259"
            case .x12260: return "X12_260"
            case .x12266: return "X12_266"
            case .x12269: return "X12_269"
            case .x12270: return "X12_270"
            case .x12270X279: return "X12_270_X279"
            case .x12271: return "X12_271"
            case .x12271X279: return "X12_271_X279"
            case .x12274: return "X12_274"
            case .x12275: return "X12_275"
            case .x12275X210: return "X12_275_X210"
            case .x12275X211: return "X12_275_X211"
            case .x12276: return "X12_276"
            case .x12276X212: return "X12_276_X212"
            case .x12277: return "X12_277"
            case .x12277X212: return "X12_277_X212"
            case .x12277X214: return "X12_277_X214"
            case .x12277X364: return "X12_277_X364"
            case .x12278: return "X12_278"
            case .x12278X217: return "X12_278_X217"
            case .x12310: return "X12_310"
            case .x12315: return "X12_315"
            case .x12322: return "X12_322"
            case .x12404: return "X12_404"
            case .x12410: return "X12_410"
            case .x12417: return "X12_417"
            case .x12421: return "X12_421"
            case .x12426: return "X12_426"
            case .x12810: return "X12_810"
            case .x12820: return "X12_820"
            case .x12820X218: return "X12_820_X218"
            case .x12820X306: return "X12_820_X306"
            case .x12824: return "X12_824"
            case .x12824X186: return "X12_824_X186"
            case .x12830: return "X12_830"
            case .x12832: return "X12_832"
            case .x12834: return "X12_834"
            case .x12834X220: return "X12_834_X220"
            case .x12834X307: return "X12_834_X307"
            case .x12834X318: return "X12_834_X318"
            case .x12835: return "X12_835"
            case .x12835X221: return "X12_835_X221"
            case .x12837: return "X12_837"
            case .x12837X222: return "X12_837_X222"
            case .x12837X223: return "X12_837_X223"
            case .x12837X224: return "X12_837_X224"
            case .x12837X291: return "X12_837_X291"
            case .x12837X292: return "X12_837_X292"
            case .x12837X298: return "X12_837_X298"
            case .x12844: return "X12_844"
            case .x12846: return "X12_846"
            case .x12849: return "X12_849"
            case .x12850: return "X12_850"
            case .x12852: return "X12_852"
            case .x12855: return "X12_855"
            case .x12856: return "X12_856"
            case .x12860: return "X12_860"
            case .x12861: return "X12_861"
            case .x12864: return "X12_864"
            case .x12865: return "X12_865"
            case .x12869: return "X12_869"
            case .x12870: return "X12_870"
            case .x12940: return "X12_940"
            case .x12945: return "X12_945"
            case .x12990: return "X12_990"
            case .x12997: return "X12_997"
            case .x12999: return "X12_999"
            case .x12999X231: return "X12_999_X231"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension B2biClientTypes {

    public enum X12Version: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case version4010
        case version4030
        case version5010
        case version5010Hipaa
        case sdkUnknown(Swift.String)

        public static var allCases: [X12Version] {
            return [
                .version4010,
                .version4030,
                .version5010,
                .version5010Hipaa
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .version4010: return "VERSION_4010"
            case .version4030: return "VERSION_4030"
            case .version5010: return "VERSION_5010"
            case .version5010Hipaa: return "VERSION_5010_HIPAA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension B2biClientTypes {
    /// A structure that contains the X12 transaction set and version. The X12 structure is used when the system transforms an EDI (electronic data interchange) file. If an EDI input file contains more than one transaction, each transaction must have the same transaction set and version, for example 214/4010. If not, the transformer cannot parse the file.
    public struct X12Details {
        /// Returns an enumerated type where each value identifies an X12 transaction set. Transaction sets are maintained by the X12 Accredited Standards Committee.
        public var transactionSet: B2biClientTypes.X12TransactionSet?
        /// Returns the version to use for the specified X12 transaction set.
        public var version: B2biClientTypes.X12Version?

        public init(
            transactionSet: B2biClientTypes.X12TransactionSet? = nil,
            version: B2biClientTypes.X12Version? = nil
        )
        {
            self.transactionSet = transactionSet
            self.version = version
        }
    }

}

extension B2biClientTypes {
    /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    public enum EdiType {
        /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        case x12details(B2biClientTypes.X12Details)
        case sdkUnknown(Swift.String)
    }

}

extension B2biClientTypes {
    /// Specifies the details for the EDI (electronic data interchange) transformation.
    public struct EdiConfiguration {
        /// Contains the Amazon S3 bucket and prefix for the location of the input file, which is contained in an S3Location object.
        /// This member is required.
        public var inputLocation: B2biClientTypes.S3Location?
        /// Contains the Amazon S3 bucket and prefix for the location of the output file, which is contained in an S3Location object.
        /// This member is required.
        public var outputLocation: B2biClientTypes.S3Location?
        /// Returns the system-assigned unique identifier for the transformer.
        /// This member is required.
        public var transformerId: Swift.String?
        /// Returns the type of the capability. Currently, only edi is supported.
        /// This member is required.
        public var type: B2biClientTypes.EdiType?

        public init(
            inputLocation: B2biClientTypes.S3Location? = nil,
            outputLocation: B2biClientTypes.S3Location? = nil,
            transformerId: Swift.String? = nil,
            type: B2biClientTypes.EdiType? = nil
        )
        {
            self.inputLocation = inputLocation
            self.outputLocation = outputLocation
            self.transformerId = transformerId
            self.type = type
        }
    }

}

extension B2biClientTypes {
    /// A capability object. Currently, only EDI (electronic data interchange) capabilities are supported. A trading capability contains the information required to transform incoming EDI documents into JSON or XML outputs.
    public enum CapabilityConfiguration {
        /// An EDI (electronic data interchange) configuration object.
        case edi(B2biClientTypes.EdiConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension B2biClientTypes {
    /// Creates a key-value pair for a specific resource. Tags are metadata that you can use to search for and group a resource for various purposes. You can apply tags to capabilities, partnerships, profiles and transformers. A tag key can take more than one value. For example, to group capabilities for accounting purposes, you might create a tag called Group and assign the values Research and Accounting to that group.
    public struct Tag {
        /// Specifies the name assigned to the tag that you create.
        /// This member is required.
        public var key: Swift.String?
        /// Contains one or more values that you assigned to the key name that you create.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension B2biClientTypes {

    public enum CapabilityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case edi
        case sdkUnknown(Swift.String)

        public static var allCases: [CapabilityType] {
            return [
                .edi
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .edi: return "edi"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateCapabilityInput {
    /// Reserved for future use.
    public var clientToken: Swift.String?
    /// Specifies a structure that contains the details for a capability.
    /// This member is required.
    public var configuration: B2biClientTypes.CapabilityConfiguration?
    /// Specifies one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
    public var instructionsDocuments: [B2biClientTypes.S3Location]?
    /// Specifies the name of the capability, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    public var tags: [B2biClientTypes.Tag]?
    /// Specifies the type of the capability. Currently, only edi is supported.
    /// This member is required.
    public var type: B2biClientTypes.CapabilityType?

    public init(
        clientToken: Swift.String? = nil,
        configuration: B2biClientTypes.CapabilityConfiguration? = nil,
        instructionsDocuments: [B2biClientTypes.S3Location]? = nil,
        name: Swift.String? = nil,
        tags: [B2biClientTypes.Tag]? = nil,
        type: B2biClientTypes.CapabilityType? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.instructionsDocuments = instructionsDocuments
        self.name = name
        self.tags = tags
        self.type = type
    }
}

public struct CreateCapabilityOutput {
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var capabilityArn: Swift.String?
    /// Returns a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?
    /// Returns a structure that contains the details for a capability.
    /// This member is required.
    public var configuration: B2biClientTypes.CapabilityConfiguration?
    /// Returns a timestamp for creation date and time of the capability.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
    public var instructionsDocuments: [B2biClientTypes.S3Location]?
    /// Returns the name of the capability used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the type of the capability. Currently, only edi is supported.
    /// This member is required.
    public var type: B2biClientTypes.CapabilityType?

    public init(
        capabilityArn: Swift.String? = nil,
        capabilityId: Swift.String? = nil,
        configuration: B2biClientTypes.CapabilityConfiguration? = nil,
        createdAt: Foundation.Date? = nil,
        instructionsDocuments: [B2biClientTypes.S3Location]? = nil,
        name: Swift.String? = nil,
        type: B2biClientTypes.CapabilityType? = nil
    )
    {
        self.capabilityArn = capabilityArn
        self.capabilityId = capabilityId
        self.configuration = configuration
        self.createdAt = createdAt
        self.instructionsDocuments = instructionsDocuments
        self.name = name
        self.type = type
    }
}

public struct DeleteCapabilityInput {
    /// Specifies a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?

    public init(
        capabilityId: Swift.String? = nil
    )
    {
        self.capabilityId = capabilityId
    }
}

public struct GetCapabilityInput {
    /// Specifies a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?

    public init(
        capabilityId: Swift.String? = nil
    )
    {
        self.capabilityId = capabilityId
    }
}

public struct GetCapabilityOutput {
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var capabilityArn: Swift.String?
    /// Returns a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?
    /// Returns a structure that contains the details for a capability.
    /// This member is required.
    public var configuration: B2biClientTypes.CapabilityConfiguration?
    /// Returns a timestamp for creation date and time of the capability.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
    public var instructionsDocuments: [B2biClientTypes.S3Location]?
    /// Returns a timestamp for last time the capability was modified.
    public var modifiedAt: Foundation.Date?
    /// Returns the name of the capability, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the type of the capability. Currently, only edi is supported.
    /// This member is required.
    public var type: B2biClientTypes.CapabilityType?

    public init(
        capabilityArn: Swift.String? = nil,
        capabilityId: Swift.String? = nil,
        configuration: B2biClientTypes.CapabilityConfiguration? = nil,
        createdAt: Foundation.Date? = nil,
        instructionsDocuments: [B2biClientTypes.S3Location]? = nil,
        modifiedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        type: B2biClientTypes.CapabilityType? = nil
    )
    {
        self.capabilityArn = capabilityArn
        self.capabilityId = capabilityId
        self.configuration = configuration
        self.createdAt = createdAt
        self.instructionsDocuments = instructionsDocuments
        self.modifiedAt = modifiedAt
        self.name = name
        self.type = type
    }
}

public struct ListCapabilitiesInput {
    /// Specifies the maximum number of capabilities to return.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension B2biClientTypes {
    /// Returns the capability summary details. A trading capability contains the information required to transform incoming EDI documents into JSON or XML outputs.
    public struct CapabilitySummary {
        /// Returns a system-assigned unique identifier for the capability.
        /// This member is required.
        public var capabilityId: Swift.String?
        /// Returns a timestamp for creation date and time of the capability.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// Returns a timestamp that identifies the most recent date and time that the capability was modified.
        public var modifiedAt: Foundation.Date?
        /// The display name of the capability.
        /// This member is required.
        public var name: Swift.String?
        /// Returns the type of the capability. Currently, only edi is supported.
        /// This member is required.
        public var type: B2biClientTypes.CapabilityType?

        public init(
            capabilityId: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            modifiedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            type: B2biClientTypes.CapabilityType? = nil
        )
        {
            self.capabilityId = capabilityId
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.type = type
        }
    }

}

public struct ListCapabilitiesOutput {
    /// Returns one or more capabilities associated with this partnership.
    /// This member is required.
    public var capabilities: [B2biClientTypes.CapabilitySummary]?
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?

    public init(
        capabilities: [B2biClientTypes.CapabilitySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.nextToken = nextToken
    }
}

public struct UpdateCapabilityInput {
    /// Specifies a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?
    /// Specifies a structure that contains the details for a capability.
    public var configuration: B2biClientTypes.CapabilityConfiguration?
    /// Specifies one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
    public var instructionsDocuments: [B2biClientTypes.S3Location]?
    /// Specifies a new name for the capability, to replace the existing name.
    public var name: Swift.String?

    public init(
        capabilityId: Swift.String? = nil,
        configuration: B2biClientTypes.CapabilityConfiguration? = nil,
        instructionsDocuments: [B2biClientTypes.S3Location]? = nil,
        name: Swift.String? = nil
    )
    {
        self.capabilityId = capabilityId
        self.configuration = configuration
        self.instructionsDocuments = instructionsDocuments
        self.name = name
    }
}

public struct UpdateCapabilityOutput {
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var capabilityArn: Swift.String?
    /// Returns a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?
    /// Returns a structure that contains the details for a capability.
    /// This member is required.
    public var configuration: B2biClientTypes.CapabilityConfiguration?
    /// Returns a timestamp for creation date and time of the capability.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
    public var instructionsDocuments: [B2biClientTypes.S3Location]?
    /// Returns a timestamp for last time the capability was modified.
    public var modifiedAt: Foundation.Date?
    /// Returns the name of the capability, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the type of the capability. Currently, only edi is supported.
    /// This member is required.
    public var type: B2biClientTypes.CapabilityType?

    public init(
        capabilityArn: Swift.String? = nil,
        capabilityId: Swift.String? = nil,
        configuration: B2biClientTypes.CapabilityConfiguration? = nil,
        createdAt: Foundation.Date? = nil,
        instructionsDocuments: [B2biClientTypes.S3Location]? = nil,
        modifiedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        type: B2biClientTypes.CapabilityType? = nil
    )
    {
        self.capabilityArn = capabilityArn
        self.capabilityId = capabilityId
        self.configuration = configuration
        self.createdAt = createdAt
        self.instructionsDocuments = instructionsDocuments
        self.modifiedAt = modifiedAt
        self.name = name
        self.type = type
    }
}

public struct GetTransformerJobInput {
    /// Specifies the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?
    /// Specifies the unique, system-generated identifier for a transformer run.
    /// This member is required.
    public var transformerJobId: Swift.String?

    public init(
        transformerId: Swift.String? = nil,
        transformerJobId: Swift.String? = nil
    )
    {
        self.transformerId = transformerId
        self.transformerJobId = transformerJobId
    }
}

extension B2biClientTypes {

    public enum TransformerJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [TransformerJobStatus] {
            return [
                .failed,
                .running,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "failed"
            case .running: return "running"
            case .succeeded: return "succeeded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetTransformerJobOutput {
    /// Returns an optional error message, which gets populated when the job is not run successfully.
    public var message: Swift.String?
    /// Returns the location for the output files. If the caller specified a directory for the output, then this contains the full path to the output file, including the file name generated by the service.
    public var outputFiles: [B2biClientTypes.S3Location]?
    /// Returns the current state of the transformer job, either running, succeeded, or failed.
    /// This member is required.
    public var status: B2biClientTypes.TransformerJobStatus?

    public init(
        message: Swift.String? = nil,
        outputFiles: [B2biClientTypes.S3Location]? = nil,
        status: B2biClientTypes.TransformerJobStatus? = nil
    )
    {
        self.message = message
        self.outputFiles = outputFiles
        self.status = status
    }
}

public struct ListTagsForResourceInput {
    /// Requests the tags associated with a particular Amazon Resource Name (ARN). An ARN is an identifier for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput {
    /// Returns the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    public var tags: [B2biClientTypes.Tag]?

    public init(
        tags: [B2biClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct CreatePartnershipInput {
    /// Specifies a list of the capabilities associated with this partnership.
    /// This member is required.
    public var capabilities: [Swift.String]?
    /// Reserved for future use.
    public var clientToken: Swift.String?
    /// Specifies the email address associated with this trading partner.
    /// This member is required.
    public var email: Swift.String?
    /// Specifies a descriptive name for the partnership.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the phone number associated with the partnership.
    public var phone: Swift.String?
    /// Specifies the unique, system-generated identifier for the profile connected to this partnership.
    /// This member is required.
    public var profileId: Swift.String?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    public var tags: [B2biClientTypes.Tag]?

    public init(
        capabilities: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        email: Swift.String? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileId: Swift.String? = nil,
        tags: [B2biClientTypes.Tag]? = nil
    )
    {
        self.capabilities = capabilities
        self.clientToken = clientToken
        self.email = email
        self.name = name
        self.phone = phone
        self.profileId = profileId
        self.tags = tags
    }
}

extension CreatePartnershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePartnershipInput(capabilities: \(Swift.String(describing: capabilities)), clientToken: \(Swift.String(describing: clientToken)), name: \(Swift.String(describing: name)), profileId: \(Swift.String(describing: profileId)), tags: \(Swift.String(describing: tags)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

public struct CreatePartnershipOutput {
    /// Returns one or more capabilities associated with this partnership.
    public var capabilities: [Swift.String]?
    /// Returns a timestamp for creation date and time of the partnership.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the email address associated with this trading partner.
    public var email: Swift.String?
    /// Returns a descriptive name for the partnership.
    public var name: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var partnershipArn: Swift.String?
    /// Returns the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?
    /// Returns the phone number associated with the partnership.
    public var phone: Swift.String?
    /// Returns the unique, system-generated identifier for the profile connected to this partnership.
    /// This member is required.
    public var profileId: Swift.String?
    /// Returns the unique, system-generated identifier for a trading partner.
    public var tradingPartnerId: Swift.String?

    public init(
        capabilities: [Swift.String]? = nil,
        createdAt: Foundation.Date? = nil,
        email: Swift.String? = nil,
        name: Swift.String? = nil,
        partnershipArn: Swift.String? = nil,
        partnershipId: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileId: Swift.String? = nil,
        tradingPartnerId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.createdAt = createdAt
        self.email = email
        self.name = name
        self.partnershipArn = partnershipArn
        self.partnershipId = partnershipId
        self.phone = phone
        self.profileId = profileId
        self.tradingPartnerId = tradingPartnerId
    }
}

extension CreatePartnershipOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePartnershipOutput(capabilities: \(Swift.String(describing: capabilities)), createdAt: \(Swift.String(describing: createdAt)), name: \(Swift.String(describing: name)), partnershipArn: \(Swift.String(describing: partnershipArn)), partnershipId: \(Swift.String(describing: partnershipId)), profileId: \(Swift.String(describing: profileId)), tradingPartnerId: \(Swift.String(describing: tradingPartnerId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

public struct DeletePartnershipInput {
    /// Specifies the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?

    public init(
        partnershipId: Swift.String? = nil
    )
    {
        self.partnershipId = partnershipId
    }
}

public struct GetPartnershipInput {
    /// Specifies the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?

    public init(
        partnershipId: Swift.String? = nil
    )
    {
        self.partnershipId = partnershipId
    }
}

public struct GetPartnershipOutput {
    /// Returns one or more capabilities associated with this partnership.
    public var capabilities: [Swift.String]?
    /// Returns a timestamp for creation date and time of the partnership.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the email address associated with this trading partner.
    public var email: Swift.String?
    /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
    public var modifiedAt: Foundation.Date?
    /// Returns the display name of the partnership
    public var name: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var partnershipArn: Swift.String?
    /// Returns the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?
    /// Returns the phone number associated with the partnership.
    public var phone: Swift.String?
    /// Returns the unique, system-generated identifier for the profile connected to this partnership.
    /// This member is required.
    public var profileId: Swift.String?
    /// Returns the unique identifier for the partner for this partnership.
    public var tradingPartnerId: Swift.String?

    public init(
        capabilities: [Swift.String]? = nil,
        createdAt: Foundation.Date? = nil,
        email: Swift.String? = nil,
        modifiedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        partnershipArn: Swift.String? = nil,
        partnershipId: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileId: Swift.String? = nil,
        tradingPartnerId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.createdAt = createdAt
        self.email = email
        self.modifiedAt = modifiedAt
        self.name = name
        self.partnershipArn = partnershipArn
        self.partnershipId = partnershipId
        self.phone = phone
        self.profileId = profileId
        self.tradingPartnerId = tradingPartnerId
    }
}

extension GetPartnershipOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPartnershipOutput(capabilities: \(Swift.String(describing: capabilities)), createdAt: \(Swift.String(describing: createdAt)), modifiedAt: \(Swift.String(describing: modifiedAt)), name: \(Swift.String(describing: name)), partnershipArn: \(Swift.String(describing: partnershipArn)), partnershipId: \(Swift.String(describing: partnershipId)), profileId: \(Swift.String(describing: profileId)), tradingPartnerId: \(Swift.String(describing: tradingPartnerId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

public struct ListPartnershipsInput {
    /// Specifies the maximum number of capabilities to return.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?
    /// Specifies the unique, system-generated identifier for the profile connected to this partnership.
    public var profileId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profileId = profileId
    }
}

extension B2biClientTypes {
    /// A structure that contains the details for a partnership. A partnership represents the connection between you and your trading partner. It ties together a profile and one or more trading capabilities.
    public struct PartnershipSummary {
        /// Returns one or more capabilities associated with this partnership.
        public var capabilities: [Swift.String]?
        /// Returns a timestamp for creation date and time of the partnership.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
        public var modifiedAt: Foundation.Date?
        /// Returns the name of the partnership.
        public var name: Swift.String?
        /// Returns the unique, system-generated identifier for a partnership.
        /// This member is required.
        public var partnershipId: Swift.String?
        /// Returns the unique, system-generated identifier for the profile connected to this partnership.
        /// This member is required.
        public var profileId: Swift.String?
        /// Returns the unique, system-generated identifier for a trading partner.
        public var tradingPartnerId: Swift.String?

        public init(
            capabilities: [Swift.String]? = nil,
            createdAt: Foundation.Date? = nil,
            modifiedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            partnershipId: Swift.String? = nil,
            profileId: Swift.String? = nil,
            tradingPartnerId: Swift.String? = nil
        )
        {
            self.capabilities = capabilities
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.partnershipId = partnershipId
            self.profileId = profileId
            self.tradingPartnerId = tradingPartnerId
        }
    }

}

public struct ListPartnershipsOutput {
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?
    /// Specifies a list of your partnerships.
    /// This member is required.
    public var partnerships: [B2biClientTypes.PartnershipSummary]?

    public init(
        nextToken: Swift.String? = nil,
        partnerships: [B2biClientTypes.PartnershipSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.partnerships = partnerships
    }
}

public struct UpdatePartnershipInput {
    /// List of the capabilities associated with this partnership.
    public var capabilities: [Swift.String]?
    /// The name of the partnership, used to identify it.
    public var name: Swift.String?
    /// Specifies the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?

    public init(
        capabilities: [Swift.String]? = nil,
        name: Swift.String? = nil,
        partnershipId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.name = name
        self.partnershipId = partnershipId
    }
}

public struct UpdatePartnershipOutput {
    /// Returns one or more capabilities associated with this partnership.
    public var capabilities: [Swift.String]?
    /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the email address associated with this trading partner.
    public var email: Swift.String?
    /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
    public var modifiedAt: Foundation.Date?
    /// The name of the partnership, used to identify it.
    public var name: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var partnershipArn: Swift.String?
    /// Returns the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?
    /// Returns the phone number associated with the partnership.
    public var phone: Swift.String?
    /// Returns the unique, system-generated identifier for the profile connected to this partnership.
    /// This member is required.
    public var profileId: Swift.String?
    /// Returns the unique, system-generated identifier for a trading partner.
    public var tradingPartnerId: Swift.String?

    public init(
        capabilities: [Swift.String]? = nil,
        createdAt: Foundation.Date? = nil,
        email: Swift.String? = nil,
        modifiedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        partnershipArn: Swift.String? = nil,
        partnershipId: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileId: Swift.String? = nil,
        tradingPartnerId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.createdAt = createdAt
        self.email = email
        self.modifiedAt = modifiedAt
        self.name = name
        self.partnershipArn = partnershipArn
        self.partnershipId = partnershipId
        self.phone = phone
        self.profileId = profileId
        self.tradingPartnerId = tradingPartnerId
    }
}

extension UpdatePartnershipOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePartnershipOutput(capabilities: \(Swift.String(describing: capabilities)), createdAt: \(Swift.String(describing: createdAt)), modifiedAt: \(Swift.String(describing: modifiedAt)), name: \(Swift.String(describing: name)), partnershipArn: \(Swift.String(describing: partnershipArn)), partnershipId: \(Swift.String(describing: partnershipId)), profileId: \(Swift.String(describing: profileId)), tradingPartnerId: \(Swift.String(describing: tradingPartnerId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

extension B2biClientTypes {

    public enum Logging: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [Logging] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateProfileInput {
    /// Specifies the name for the business associated with this profile.
    /// This member is required.
    public var businessName: Swift.String?
    /// Reserved for future use.
    public var clientToken: Swift.String?
    /// Specifies the email address associated with this customer profile.
    public var email: Swift.String?
    /// Specifies whether or not logging is enabled for this profile.
    /// This member is required.
    public var logging: B2biClientTypes.Logging?
    /// Specifies the name of the profile.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the phone number associated with the profile.
    /// This member is required.
    public var phone: Swift.String?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    public var tags: [B2biClientTypes.Tag]?

    public init(
        businessName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        email: Swift.String? = nil,
        logging: B2biClientTypes.Logging? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        tags: [B2biClientTypes.Tag]? = nil
    )
    {
        self.businessName = businessName
        self.clientToken = clientToken
        self.email = email
        self.logging = logging
        self.name = name
        self.phone = phone
        self.tags = tags
    }
}

extension CreateProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProfileInput(businessName: \(Swift.String(describing: businessName)), clientToken: \(Swift.String(describing: clientToken)), logging: \(Swift.String(describing: logging)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

public struct CreateProfileOutput {
    /// Returns the name for the business associated with this profile.
    /// This member is required.
    public var businessName: Swift.String?
    /// Returns a timestamp representing the time the profile was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the email address associated with this customer profile.
    public var email: Swift.String?
    /// Returns the name of the logging group.
    public var logGroupName: Swift.String?
    /// Returns whether or not logging is turned on for this profile.
    public var logging: B2biClientTypes.Logging?
    /// Returns the name of the profile, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the phone number associated with the profile.
    /// This member is required.
    public var phone: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for the profile.
    /// This member is required.
    public var profileArn: Swift.String?
    /// Returns the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        businessName: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        email: Swift.String? = nil,
        logGroupName: Swift.String? = nil,
        logging: B2biClientTypes.Logging? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.businessName = businessName
        self.createdAt = createdAt
        self.email = email
        self.logGroupName = logGroupName
        self.logging = logging
        self.name = name
        self.phone = phone
        self.profileArn = profileArn
        self.profileId = profileId
    }
}

extension CreateProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProfileOutput(businessName: \(Swift.String(describing: businessName)), createdAt: \(Swift.String(describing: createdAt)), logGroupName: \(Swift.String(describing: logGroupName)), logging: \(Swift.String(describing: logging)), name: \(Swift.String(describing: name)), profileArn: \(Swift.String(describing: profileArn)), profileId: \(Swift.String(describing: profileId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

public struct DeleteProfileInput {
    /// Specifies the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

public struct GetProfileInput {
    /// Specifies the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

public struct GetProfileOutput {
    /// Returns the name for the business associated with this profile.
    /// This member is required.
    public var businessName: Swift.String?
    /// Returns a timestamp for creation date and time of the transformer.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the email address associated with this customer profile.
    public var email: Swift.String?
    /// Returns the name of the logging group.
    public var logGroupName: Swift.String?
    /// Returns whether or not logging is enabled for this profile.
    public var logging: B2biClientTypes.Logging?
    /// Returns a timestamp for last time the profile was modified.
    public var modifiedAt: Foundation.Date?
    /// Returns the name of the profile, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the phone number associated with the profile.
    /// This member is required.
    public var phone: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var profileArn: Swift.String?
    /// Returns the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        businessName: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        email: Swift.String? = nil,
        logGroupName: Swift.String? = nil,
        logging: B2biClientTypes.Logging? = nil,
        modifiedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.businessName = businessName
        self.createdAt = createdAt
        self.email = email
        self.logGroupName = logGroupName
        self.logging = logging
        self.modifiedAt = modifiedAt
        self.name = name
        self.phone = phone
        self.profileArn = profileArn
        self.profileId = profileId
    }
}

extension GetProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProfileOutput(businessName: \(Swift.String(describing: businessName)), createdAt: \(Swift.String(describing: createdAt)), logGroupName: \(Swift.String(describing: logGroupName)), logging: \(Swift.String(describing: logging)), modifiedAt: \(Swift.String(describing: modifiedAt)), name: \(Swift.String(describing: name)), profileArn: \(Swift.String(describing: profileArn)), profileId: \(Swift.String(describing: profileId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

public struct ListProfilesInput {
    /// Specifies the maximum number of profiles to return.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension B2biClientTypes {
    /// Contains the details for a profile. A profile is the mechanism used to create the concept of a private network.
    public struct ProfileSummary {
        /// Returns the name for the business associated with this profile.
        /// This member is required.
        public var businessName: Swift.String?
        /// Returns the timestamp for creation date and time of the profile.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// Returns the name of the logging group.
        public var logGroupName: Swift.String?
        /// Specifies whether or not logging is enabled for this profile.
        public var logging: B2biClientTypes.Logging?
        /// Returns the timestamp that identifies the most recent date and time that the profile was modified.
        public var modifiedAt: Foundation.Date?
        /// Returns the display name for profile.
        /// This member is required.
        public var name: Swift.String?
        /// Returns the unique, system-generated identifier for the profile.
        /// This member is required.
        public var profileId: Swift.String?

        public init(
            businessName: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            logGroupName: Swift.String? = nil,
            logging: B2biClientTypes.Logging? = nil,
            modifiedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            profileId: Swift.String? = nil
        )
        {
            self.businessName = businessName
            self.createdAt = createdAt
            self.logGroupName = logGroupName
            self.logging = logging
            self.modifiedAt = modifiedAt
            self.name = name
            self.profileId = profileId
        }
    }

}

public struct ListProfilesOutput {
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?
    /// Returns an array of ProfileSummary objects.
    /// This member is required.
    public var profiles: [B2biClientTypes.ProfileSummary]?

    public init(
        nextToken: Swift.String? = nil,
        profiles: [B2biClientTypes.ProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
    }
}

public struct UpdateProfileInput {
    /// Specifies the name for the business associated with this profile.
    public var businessName: Swift.String?
    /// Specifies the email address associated with this customer profile.
    public var email: Swift.String?
    /// The name of the profile, used to identify it.
    public var name: Swift.String?
    /// Specifies the phone number associated with the profile.
    public var phone: Swift.String?
    /// Specifies the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        businessName: Swift.String? = nil,
        email: Swift.String? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.businessName = businessName
        self.email = email
        self.name = name
        self.phone = phone
        self.profileId = profileId
    }
}

extension UpdateProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProfileInput(businessName: \(Swift.String(describing: businessName)), name: \(Swift.String(describing: name)), profileId: \(Swift.String(describing: profileId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

public struct UpdateProfileOutput {
    /// Returns the name for the business associated with this profile.
    /// This member is required.
    public var businessName: Swift.String?
    /// Returns a timestamp for creation date and time of the profile.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the email address associated with this customer profile.
    public var email: Swift.String?
    /// Returns the name of the logging group.
    public var logGroupName: Swift.String?
    /// Specifies whether or not logging is enabled for this profile.
    public var logging: B2biClientTypes.Logging?
    /// Returns a timestamp for last time the profile was modified.
    public var modifiedAt: Foundation.Date?
    /// Returns the name of the profile.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the phone number associated with the profile.
    /// This member is required.
    public var phone: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for the profile.
    /// This member is required.
    public var profileArn: Swift.String?
    /// Returns the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        businessName: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        email: Swift.String? = nil,
        logGroupName: Swift.String? = nil,
        logging: B2biClientTypes.Logging? = nil,
        modifiedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.businessName = businessName
        self.createdAt = createdAt
        self.email = email
        self.logGroupName = logGroupName
        self.logging = logging
        self.modifiedAt = modifiedAt
        self.name = name
        self.phone = phone
        self.profileArn = profileArn
        self.profileId = profileId
    }
}

extension UpdateProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProfileOutput(businessName: \(Swift.String(describing: businessName)), createdAt: \(Swift.String(describing: createdAt)), logGroupName: \(Swift.String(describing: logGroupName)), logging: \(Swift.String(describing: logging)), modifiedAt: \(Swift.String(describing: modifiedAt)), name: \(Swift.String(describing: name)), profileArn: \(Swift.String(describing: profileArn)), profileId: \(Swift.String(describing: profileId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

public struct StartTransformerJobInput {
    /// Reserved for future use.
    public var clientToken: Swift.String?
    /// Specifies the location of the input file for the transformation. The location consists of an Amazon S3 bucket and prefix.
    /// This member is required.
    public var inputFile: B2biClientTypes.S3Location?
    /// Specifies the location of the output file for the transformation. The location consists of an Amazon S3 bucket and prefix.
    /// This member is required.
    public var outputLocation: B2biClientTypes.S3Location?
    /// Specifies the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        inputFile: B2biClientTypes.S3Location? = nil,
        outputLocation: B2biClientTypes.S3Location? = nil,
        transformerId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.inputFile = inputFile
        self.outputLocation = outputLocation
        self.transformerId = transformerId
    }
}

public struct StartTransformerJobOutput {
    /// Returns the unique, system-generated identifier for a transformer run.
    /// This member is required.
    public var transformerJobId: Swift.String?

    public init(
        transformerJobId: Swift.String? = nil
    )
    {
        self.transformerJobId = transformerJobId
    }
}

public struct TagResourceInput {
    /// Specifies an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    /// This member is required.
    public var tags: [B2biClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [B2biClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

extension B2biClientTypes {

    public enum FileFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case xml
        case sdkUnknown(Swift.String)

        public static var allCases: [FileFormat] {
            return [
                .json,
                .xml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .xml: return "XML"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct TestMappingInput {
    /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
    /// This member is required.
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Specify the contents of the EDI (electronic data interchange) XML or JSON file that is used as input for the transform.
    /// This member is required.
    public var inputFileContent: Swift.String?
    /// Specifies the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.
    /// This member is required.
    public var mappingTemplate: Swift.String?

    public init(
        fileFormat: B2biClientTypes.FileFormat? = nil,
        inputFileContent: Swift.String? = nil,
        mappingTemplate: Swift.String? = nil
    )
    {
        self.fileFormat = fileFormat
        self.inputFileContent = inputFileContent
        self.mappingTemplate = mappingTemplate
    }
}

public struct TestMappingOutput {
    /// Returns a string for the mapping that can be used to identify the mapping. Similar to a fingerprint
    /// This member is required.
    public var mappedFileContent: Swift.String?

    public init(
        mappedFileContent: Swift.String? = nil
    )
    {
        self.mappedFileContent = mappedFileContent
    }
}

public struct TestParsingInput {
    /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    /// This member is required.
    public var ediType: B2biClientTypes.EdiType?
    /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
    /// This member is required.
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Specifies an S3Location object, which contains the Amazon S3 bucket and prefix for the location of the input file.
    /// This member is required.
    public var inputFile: B2biClientTypes.S3Location?

    public init(
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = nil,
        inputFile: B2biClientTypes.S3Location? = nil
    )
    {
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.inputFile = inputFile
    }
}

public struct TestParsingOutput {
    /// Returns the contents of the input file being tested, parsed according to the specified EDI (electronic data interchange) type.
    /// This member is required.
    public var parsedFileContent: Swift.String?

    public init(
        parsedFileContent: Swift.String? = nil
    )
    {
        self.parsedFileContent = parsedFileContent
    }
}

public struct CreateTransformerInput {
    /// Reserved for future use.
    public var clientToken: Swift.String?
    /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    /// This member is required.
    public var ediType: B2biClientTypes.EdiType?
    /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
    /// This member is required.
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Specifies the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.
    /// This member is required.
    public var mappingTemplate: Swift.String?
    /// Specifies the name of the transformer, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies a sample EDI document that is used by a transformer as a guide for processing the EDI data.
    public var sampleDocument: Swift.String?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    public var tags: [B2biClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = nil,
        mappingTemplate: Swift.String? = nil,
        name: Swift.String? = nil,
        sampleDocument: Swift.String? = nil,
        tags: [B2biClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.mappingTemplate = mappingTemplate
        self.name = name
        self.sampleDocument = sampleDocument
        self.tags = tags
    }
}

extension B2biClientTypes {

    public enum TransformerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [TransformerStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "active"
            case .inactive: return "inactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateTransformerOutput {
    /// Returns a timestamp for creation date and time of the transformer.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    /// This member is required.
    public var ediType: B2biClientTypes.EdiType?
    /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
    /// This member is required.
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Returns the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.
    /// This member is required.
    public var mappingTemplate: Swift.String?
    /// Returns the name of the transformer, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
    public var sampleDocument: Swift.String?
    /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
    /// This member is required.
    public var status: B2biClientTypes.TransformerStatus?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var transformerArn: Swift.String?
    /// Returns the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = nil,
        mappingTemplate: Swift.String? = nil,
        name: Swift.String? = nil,
        sampleDocument: Swift.String? = nil,
        status: B2biClientTypes.TransformerStatus? = nil,
        transformerArn: Swift.String? = nil,
        transformerId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.mappingTemplate = mappingTemplate
        self.name = name
        self.sampleDocument = sampleDocument
        self.status = status
        self.transformerArn = transformerArn
        self.transformerId = transformerId
    }
}

public struct DeleteTransformerInput {
    /// Specifies the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        transformerId: Swift.String? = nil
    )
    {
        self.transformerId = transformerId
    }
}

public struct GetTransformerInput {
    /// Specifies the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        transformerId: Swift.String? = nil
    )
    {
        self.transformerId = transformerId
    }
}

public struct GetTransformerOutput {
    /// Returns a timestamp for creation date and time of the transformer.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    /// This member is required.
    public var ediType: B2biClientTypes.EdiType?
    /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
    /// This member is required.
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Returns the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.
    /// This member is required.
    public var mappingTemplate: Swift.String?
    /// Returns a timestamp for last time the transformer was modified.
    public var modifiedAt: Foundation.Date?
    /// Returns the name of the transformer, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
    public var sampleDocument: Swift.String?
    /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
    /// This member is required.
    public var status: B2biClientTypes.TransformerStatus?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var transformerArn: Swift.String?
    /// Returns the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = nil,
        mappingTemplate: Swift.String? = nil,
        modifiedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        sampleDocument: Swift.String? = nil,
        status: B2biClientTypes.TransformerStatus? = nil,
        transformerArn: Swift.String? = nil,
        transformerId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.mappingTemplate = mappingTemplate
        self.modifiedAt = modifiedAt
        self.name = name
        self.sampleDocument = sampleDocument
        self.status = status
        self.transformerArn = transformerArn
        self.transformerId = transformerId
    }
}

public struct ListTransformersInput {
    /// Specifies the number of items to return for the API response.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension B2biClientTypes {
    /// Contains the details for a transformer object. A transformer describes how to process the incoming EDI documents and extract the necessary information to the output file.
    public struct TransformerSummary {
        /// Returns a timestamp indicating when the transformer was created. For example, 2023-07-20T19:58:44.624Z.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        /// This member is required.
        public var ediType: B2biClientTypes.EdiType?
        /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
        /// This member is required.
        public var fileFormat: B2biClientTypes.FileFormat?
        /// Returns the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.
        /// This member is required.
        public var mappingTemplate: Swift.String?
        /// Returns a timestamp representing the date and time for the most recent change for the transformer object.
        public var modifiedAt: Foundation.Date?
        /// Returns the descriptive name for the transformer.
        /// This member is required.
        public var name: Swift.String?
        /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
        public var sampleDocument: Swift.String?
        /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
        /// This member is required.
        public var status: B2biClientTypes.TransformerStatus?
        /// Returns the system-assigned unique identifier for the transformer.
        /// This member is required.
        public var transformerId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            ediType: B2biClientTypes.EdiType? = nil,
            fileFormat: B2biClientTypes.FileFormat? = nil,
            mappingTemplate: Swift.String? = nil,
            modifiedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            sampleDocument: Swift.String? = nil,
            status: B2biClientTypes.TransformerStatus? = nil,
            transformerId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.ediType = ediType
            self.fileFormat = fileFormat
            self.mappingTemplate = mappingTemplate
            self.modifiedAt = modifiedAt
            self.name = name
            self.sampleDocument = sampleDocument
            self.status = status
            self.transformerId = transformerId
        }
    }

}

public struct ListTransformersOutput {
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?
    /// Returns an array of one or more transformer objects. For each transformer, a TransformerSummary object is returned. The TransformerSummary contains all the details for a specific transformer.
    /// This member is required.
    public var transformers: [B2biClientTypes.TransformerSummary]?

    public init(
        nextToken: Swift.String? = nil,
        transformers: [B2biClientTypes.TransformerSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.transformers = transformers
    }
}

public struct UpdateTransformerInput {
    /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    public var ediType: B2biClientTypes.EdiType?
    /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Specifies the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.
    public var mappingTemplate: Swift.String?
    /// Specify a new name for the transformer, if you want to update it.
    public var name: Swift.String?
    /// Specifies a sample EDI document that is used by a transformer as a guide for processing the EDI data.
    public var sampleDocument: Swift.String?
    /// Specifies the transformer's status. You can update the state of the transformer, from active to inactive, or inactive to active.
    public var status: B2biClientTypes.TransformerStatus?
    /// Specifies the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = nil,
        mappingTemplate: Swift.String? = nil,
        name: Swift.String? = nil,
        sampleDocument: Swift.String? = nil,
        status: B2biClientTypes.TransformerStatus? = nil,
        transformerId: Swift.String? = nil
    )
    {
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.mappingTemplate = mappingTemplate
        self.name = name
        self.sampleDocument = sampleDocument
        self.status = status
        self.transformerId = transformerId
    }
}

public struct UpdateTransformerOutput {
    /// Returns a timestamp for creation date and time of the transformer.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    /// This member is required.
    public var ediType: B2biClientTypes.EdiType?
    /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
    /// This member is required.
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Returns the mapping template for the transformer. This template is used to map the parsed EDI file using JSONata or XSLT.
    /// This member is required.
    public var mappingTemplate: Swift.String?
    /// Returns a timestamp for last time the transformer was modified.
    /// This member is required.
    public var modifiedAt: Foundation.Date?
    /// Returns the name of the transformer.
    /// This member is required.
    public var name: Swift.String?
    /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
    public var sampleDocument: Swift.String?
    /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
    /// This member is required.
    public var status: B2biClientTypes.TransformerStatus?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var transformerArn: Swift.String?
    /// Returns the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = nil,
        mappingTemplate: Swift.String? = nil,
        modifiedAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        sampleDocument: Swift.String? = nil,
        status: B2biClientTypes.TransformerStatus? = nil,
        transformerArn: Swift.String? = nil,
        transformerId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.mappingTemplate = mappingTemplate
        self.modifiedAt = modifiedAt
        self.name = name
        self.sampleDocument = sampleDocument
        self.status = status
        self.transformerArn = transformerArn
        self.transformerId = transformerId
    }
}

public struct UntagResourceInput {
    /// Specifies an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

extension CreateCapabilityInput {

    static func urlPathProvider(_ value: CreateCapabilityInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePartnershipInput {

    static func urlPathProvider(_ value: CreatePartnershipInput) -> Swift.String? {
        return "/"
    }
}

extension CreateProfileInput {

    static func urlPathProvider(_ value: CreateProfileInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTransformerInput {

    static func urlPathProvider(_ value: CreateTransformerInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteCapabilityInput {

    static func urlPathProvider(_ value: DeleteCapabilityInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePartnershipInput {

    static func urlPathProvider(_ value: DeletePartnershipInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteProfileInput {

    static func urlPathProvider(_ value: DeleteProfileInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTransformerInput {

    static func urlPathProvider(_ value: DeleteTransformerInput) -> Swift.String? {
        return "/"
    }
}

extension GetCapabilityInput {

    static func urlPathProvider(_ value: GetCapabilityInput) -> Swift.String? {
        return "/"
    }
}

extension GetPartnershipInput {

    static func urlPathProvider(_ value: GetPartnershipInput) -> Swift.String? {
        return "/"
    }
}

extension GetProfileInput {

    static func urlPathProvider(_ value: GetProfileInput) -> Swift.String? {
        return "/"
    }
}

extension GetTransformerInput {

    static func urlPathProvider(_ value: GetTransformerInput) -> Swift.String? {
        return "/"
    }
}

extension GetTransformerJobInput {

    static func urlPathProvider(_ value: GetTransformerJobInput) -> Swift.String? {
        return "/"
    }
}

extension GetTransformerJobInput {

    static func queryItemProvider(_ value: GetTransformerJobInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListCapabilitiesInput {

    static func urlPathProvider(_ value: ListCapabilitiesInput) -> Swift.String? {
        return "/"
    }
}

extension ListCapabilitiesInput {

    static func queryItemProvider(_ value: ListCapabilitiesInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListPartnershipsInput {

    static func urlPathProvider(_ value: ListPartnershipsInput) -> Swift.String? {
        return "/"
    }
}

extension ListPartnershipsInput {

    static func queryItemProvider(_ value: ListPartnershipsInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListProfilesInput {

    static func urlPathProvider(_ value: ListProfilesInput) -> Swift.String? {
        return "/"
    }
}

extension ListProfilesInput {

    static func queryItemProvider(_ value: ListProfilesInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListTransformersInput {

    static func urlPathProvider(_ value: ListTransformersInput) -> Swift.String? {
        return "/"
    }
}

extension ListTransformersInput {

    static func queryItemProvider(_ value: ListTransformersInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension StartTransformerJobInput {

    static func urlPathProvider(_ value: StartTransformerJobInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TestMappingInput {

    static func urlPathProvider(_ value: TestMappingInput) -> Swift.String? {
        return "/"
    }
}

extension TestParsingInput {

    static func urlPathProvider(_ value: TestParsingInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        return []
    }
}

extension UpdateCapabilityInput {

    static func urlPathProvider(_ value: UpdateCapabilityInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePartnershipInput {

    static func urlPathProvider(_ value: UpdatePartnershipInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateProfileInput {

    static func urlPathProvider(_ value: UpdateProfileInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateTransformerInput {

    static func urlPathProvider(_ value: UpdateTransformerInput) -> Swift.String? {
        return "/"
    }
}

extension CreateCapabilityInput {

    static func write(value: CreateCapabilityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["configuration"].write(value.configuration, with: B2biClientTypes.CapabilityConfiguration.write(value:to:))
        try writer["instructionsDocuments"].writeList(value.instructionsDocuments, memberWritingClosure: B2biClientTypes.S3Location.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["tags"].writeList(value.tags, memberWritingClosure: B2biClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension CreatePartnershipInput {

    static func write(value: CreatePartnershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capabilities"].writeList(value.capabilities, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
        try writer["email"].write(value.email)
        try writer["name"].write(value.name)
        try writer["phone"].write(value.phone)
        try writer["profileId"].write(value.profileId)
        try writer["tags"].writeList(value.tags, memberWritingClosure: B2biClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateProfileInput {

    static func write(value: CreateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["businessName"].write(value.businessName)
        try writer["clientToken"].write(value.clientToken)
        try writer["email"].write(value.email)
        try writer["logging"].write(value.logging)
        try writer["name"].write(value.name)
        try writer["phone"].write(value.phone)
        try writer["tags"].writeList(value.tags, memberWritingClosure: B2biClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateTransformerInput {

    static func write(value: CreateTransformerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["ediType"].write(value.ediType, with: B2biClientTypes.EdiType.write(value:to:))
        try writer["fileFormat"].write(value.fileFormat)
        try writer["mappingTemplate"].write(value.mappingTemplate)
        try writer["name"].write(value.name)
        try writer["sampleDocument"].write(value.sampleDocument)
        try writer["tags"].writeList(value.tags, memberWritingClosure: B2biClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteCapabilityInput {

    static func write(value: DeleteCapabilityInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeletePartnershipInput {

    static func write(value: DeletePartnershipInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteProfileInput {

    static func write(value: DeleteProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DeleteTransformerInput {

    static func write(value: DeleteTransformerInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetCapabilityInput {

    static func write(value: GetCapabilityInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetPartnershipInput {

    static func write(value: GetPartnershipInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetProfileInput {

    static func write(value: GetProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetTransformerInput {

    static func write(value: GetTransformerInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetTransformerJobInput {

    static func write(value: GetTransformerJobInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListCapabilitiesInput {

    static func write(value: ListCapabilitiesInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListPartnershipsInput {

    static func write(value: ListPartnershipsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListProfilesInput {

    static func write(value: ListProfilesInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListTransformersInput {

    static func write(value: ListTransformersInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension StartTransformerJobInput {

    static func write(value: StartTransformerJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["inputFile"].write(value.inputFile, with: B2biClientTypes.S3Location.write(value:to:))
        try writer["outputLocation"].write(value.outputLocation, with: B2biClientTypes.S3Location.write(value:to:))
        try writer["transformerId"].write(value.transformerId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: B2biClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TestMappingInput {

    static func write(value: TestMappingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileFormat"].write(value.fileFormat)
        try writer["inputFileContent"].write(value.inputFileContent)
        try writer["mappingTemplate"].write(value.mappingTemplate)
    }
}

extension TestParsingInput {

    static func write(value: TestParsingInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ediType"].write(value.ediType, with: B2biClientTypes.EdiType.write(value:to:))
        try writer["fileFormat"].write(value.fileFormat)
        try writer["inputFile"].write(value.inputFile, with: B2biClientTypes.S3Location.write(value:to:))
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension UpdateCapabilityInput {

    static func write(value: UpdateCapabilityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuration"].write(value.configuration, with: B2biClientTypes.CapabilityConfiguration.write(value:to:))
        try writer["instructionsDocuments"].writeList(value.instructionsDocuments, memberWritingClosure: B2biClientTypes.S3Location.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
    }
}

extension UpdatePartnershipInput {

    static func write(value: UpdatePartnershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capabilities"].writeList(value.capabilities, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
    }
}

extension UpdateProfileInput {

    static func write(value: UpdateProfileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["businessName"].write(value.businessName)
        try writer["email"].write(value.email)
        try writer["name"].write(value.name)
        try writer["phone"].write(value.phone)
    }
}

extension UpdateTransformerInput {

    static func write(value: UpdateTransformerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ediType"].write(value.ediType, with: B2biClientTypes.EdiType.write(value:to:))
        try writer["fileFormat"].write(value.fileFormat)
        try writer["mappingTemplate"].write(value.mappingTemplate)
        try writer["name"].write(value.name)
        try writer["sampleDocument"].write(value.sampleDocument)
        try writer["status"].write(value.status)
    }
}

extension CreateCapabilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCapabilityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCapabilityOutput()
        value.capabilityArn = try reader["capabilityArn"].readIfPresent() ?? ""
        value.capabilityId = try reader["capabilityId"].readIfPresent() ?? ""
        value.configuration = try reader["configuration"].readIfPresent(with: B2biClientTypes.CapabilityConfiguration.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.instructionsDocuments = try reader["instructionsDocuments"].readListIfPresent(memberReadingClosure: B2biClientTypes.S3Location.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreatePartnershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePartnershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePartnershipOutput()
        value.capabilities = try reader["capabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.email = try reader["email"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.partnershipArn = try reader["partnershipArn"].readIfPresent() ?? ""
        value.partnershipId = try reader["partnershipId"].readIfPresent() ?? ""
        value.phone = try reader["phone"].readIfPresent()
        value.profileId = try reader["profileId"].readIfPresent() ?? ""
        value.tradingPartnerId = try reader["tradingPartnerId"].readIfPresent()
        return value
    }
}

extension CreateProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProfileOutput()
        value.businessName = try reader["businessName"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.email = try reader["email"].readIfPresent()
        value.logGroupName = try reader["logGroupName"].readIfPresent()
        value.logging = try reader["logging"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.phone = try reader["phone"].readIfPresent() ?? ""
        value.profileArn = try reader["profileArn"].readIfPresent() ?? ""
        value.profileId = try reader["profileId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateTransformerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTransformerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTransformerOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.ediType = try reader["ediType"].readIfPresent(with: B2biClientTypes.EdiType.read(from:))
        value.fileFormat = try reader["fileFormat"].readIfPresent() ?? .sdkUnknown("")
        value.mappingTemplate = try reader["mappingTemplate"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.sampleDocument = try reader["sampleDocument"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.transformerArn = try reader["transformerArn"].readIfPresent() ?? ""
        value.transformerId = try reader["transformerId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteCapabilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCapabilityOutput {
        return DeleteCapabilityOutput()
    }
}

extension DeletePartnershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePartnershipOutput {
        return DeletePartnershipOutput()
    }
}

extension DeleteProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProfileOutput {
        return DeleteProfileOutput()
    }
}

extension DeleteTransformerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTransformerOutput {
        return DeleteTransformerOutput()
    }
}

extension GetCapabilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCapabilityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCapabilityOutput()
        value.capabilityArn = try reader["capabilityArn"].readIfPresent() ?? ""
        value.capabilityId = try reader["capabilityId"].readIfPresent() ?? ""
        value.configuration = try reader["configuration"].readIfPresent(with: B2biClientTypes.CapabilityConfiguration.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.instructionsDocuments = try reader["instructionsDocuments"].readListIfPresent(memberReadingClosure: B2biClientTypes.S3Location.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetPartnershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPartnershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPartnershipOutput()
        value.capabilities = try reader["capabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.email = try reader["email"].readIfPresent()
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.partnershipArn = try reader["partnershipArn"].readIfPresent() ?? ""
        value.partnershipId = try reader["partnershipId"].readIfPresent() ?? ""
        value.phone = try reader["phone"].readIfPresent()
        value.profileId = try reader["profileId"].readIfPresent() ?? ""
        value.tradingPartnerId = try reader["tradingPartnerId"].readIfPresent()
        return value
    }
}

extension GetProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProfileOutput()
        value.businessName = try reader["businessName"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.email = try reader["email"].readIfPresent()
        value.logGroupName = try reader["logGroupName"].readIfPresent()
        value.logging = try reader["logging"].readIfPresent()
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.phone = try reader["phone"].readIfPresent() ?? ""
        value.profileArn = try reader["profileArn"].readIfPresent() ?? ""
        value.profileId = try reader["profileId"].readIfPresent() ?? ""
        return value
    }
}

extension GetTransformerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTransformerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTransformerOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.ediType = try reader["ediType"].readIfPresent(with: B2biClientTypes.EdiType.read(from:))
        value.fileFormat = try reader["fileFormat"].readIfPresent() ?? .sdkUnknown("")
        value.mappingTemplate = try reader["mappingTemplate"].readIfPresent() ?? ""
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.sampleDocument = try reader["sampleDocument"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.transformerArn = try reader["transformerArn"].readIfPresent() ?? ""
        value.transformerId = try reader["transformerId"].readIfPresent() ?? ""
        return value
    }
}

extension GetTransformerJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTransformerJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTransformerJobOutput()
        value.message = try reader["message"].readIfPresent()
        value.outputFiles = try reader["outputFiles"].readListIfPresent(memberReadingClosure: B2biClientTypes.S3Location.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ListCapabilitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCapabilitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCapabilitiesOutput()
        value.capabilities = try reader["capabilities"].readListIfPresent(memberReadingClosure: B2biClientTypes.CapabilitySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListPartnershipsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPartnershipsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPartnershipsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.partnerships = try reader["partnerships"].readListIfPresent(memberReadingClosure: B2biClientTypes.PartnershipSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListProfilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProfilesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProfilesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.profiles = try reader["profiles"].readListIfPresent(memberReadingClosure: B2biClientTypes.ProfileSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: B2biClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTransformersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTransformersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTransformersOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.transformers = try reader["transformers"].readListIfPresent(memberReadingClosure: B2biClientTypes.TransformerSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension StartTransformerJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartTransformerJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartTransformerJobOutput()
        value.transformerJobId = try reader["transformerJobId"].readIfPresent() ?? ""
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TestMappingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestMappingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TestMappingOutput()
        value.mappedFileContent = try reader["mappedFileContent"].readIfPresent() ?? ""
        return value
    }
}

extension TestParsingOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TestParsingOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = TestParsingOutput()
        value.parsedFileContent = try reader["parsedFileContent"].readIfPresent() ?? ""
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateCapabilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCapabilityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCapabilityOutput()
        value.capabilityArn = try reader["capabilityArn"].readIfPresent() ?? ""
        value.capabilityId = try reader["capabilityId"].readIfPresent() ?? ""
        value.configuration = try reader["configuration"].readIfPresent(with: B2biClientTypes.CapabilityConfiguration.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.instructionsDocuments = try reader["instructionsDocuments"].readListIfPresent(memberReadingClosure: B2biClientTypes.S3Location.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension UpdatePartnershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePartnershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePartnershipOutput()
        value.capabilities = try reader["capabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.email = try reader["email"].readIfPresent()
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent()
        value.partnershipArn = try reader["partnershipArn"].readIfPresent() ?? ""
        value.partnershipId = try reader["partnershipId"].readIfPresent() ?? ""
        value.phone = try reader["phone"].readIfPresent()
        value.profileId = try reader["profileId"].readIfPresent() ?? ""
        value.tradingPartnerId = try reader["tradingPartnerId"].readIfPresent()
        return value
    }
}

extension UpdateProfileOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProfileOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProfileOutput()
        value.businessName = try reader["businessName"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.email = try reader["email"].readIfPresent()
        value.logGroupName = try reader["logGroupName"].readIfPresent()
        value.logging = try reader["logging"].readIfPresent()
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.phone = try reader["phone"].readIfPresent() ?? ""
        value.profileArn = try reader["profileArn"].readIfPresent() ?? ""
        value.profileId = try reader["profileId"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateTransformerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTransformerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTransformerOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.ediType = try reader["ediType"].readIfPresent(with: B2biClientTypes.EdiType.read(from:))
        value.fileFormat = try reader["fileFormat"].readIfPresent() ?? .sdkUnknown("")
        value.mappingTemplate = try reader["mappingTemplate"].readIfPresent() ?? ""
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.sampleDocument = try reader["sampleDocument"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.transformerArn = try reader["transformerArn"].readIfPresent() ?? ""
        value.transformerId = try reader["transformerId"].readIfPresent() ?? ""
        return value
    }
}

enum CreateCapabilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePartnershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTransformerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCapabilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePartnershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTransformerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCapabilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPartnershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTransformerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTransformerJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCapabilitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPartnershipsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProfilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTransformersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartTransformerJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestMappingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TestParsingOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCapabilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePartnershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProfileOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTransformerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension B2biClientTypes.CapabilityConfiguration {

    static func write(value: B2biClientTypes.CapabilityConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .edi(edi):
                try writer["edi"].write(edi, with: B2biClientTypes.EdiConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.CapabilityConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "edi":
                return .edi(try reader["edi"].read(with: B2biClientTypes.EdiConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension B2biClientTypes.EdiConfiguration {

    static func write(value: B2biClientTypes.EdiConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputLocation"].write(value.inputLocation, with: B2biClientTypes.S3Location.write(value:to:))
        try writer["outputLocation"].write(value.outputLocation, with: B2biClientTypes.S3Location.write(value:to:))
        try writer["transformerId"].write(value.transformerId)
        try writer["type"].write(value.type, with: B2biClientTypes.EdiType.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.EdiConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.EdiConfiguration()
        value.type = try reader["type"].readIfPresent(with: B2biClientTypes.EdiType.read(from:))
        value.inputLocation = try reader["inputLocation"].readIfPresent(with: B2biClientTypes.S3Location.read(from:))
        value.outputLocation = try reader["outputLocation"].readIfPresent(with: B2biClientTypes.S3Location.read(from:))
        value.transformerId = try reader["transformerId"].readIfPresent() ?? ""
        return value
    }
}

extension B2biClientTypes.S3Location {

    static func write(value: B2biClientTypes.S3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["key"].write(value.key)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.S3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.S3Location()
        value.bucketName = try reader["bucketName"].readIfPresent()
        value.key = try reader["key"].readIfPresent()
        return value
    }
}

extension B2biClientTypes.EdiType {

    static func write(value: B2biClientTypes.EdiType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .x12details(x12details):
                try writer["x12Details"].write(x12details, with: B2biClientTypes.X12Details.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.EdiType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "x12Details":
                return .x12details(try reader["x12Details"].read(with: B2biClientTypes.X12Details.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension B2biClientTypes.X12Details {

    static func write(value: B2biClientTypes.X12Details?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["transactionSet"].write(value.transactionSet)
        try writer["version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.X12Details {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.X12Details()
        value.transactionSet = try reader["transactionSet"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension B2biClientTypes.CapabilitySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.CapabilitySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.CapabilitySummary()
        value.capabilityId = try reader["capabilityId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension B2biClientTypes.PartnershipSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.PartnershipSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.PartnershipSummary()
        value.profileId = try reader["profileId"].readIfPresent() ?? ""
        value.partnershipId = try reader["partnershipId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.capabilities = try reader["capabilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.tradingPartnerId = try reader["tradingPartnerId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension B2biClientTypes.ProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.ProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.ProfileSummary()
        value.profileId = try reader["profileId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.businessName = try reader["businessName"].readIfPresent() ?? ""
        value.logging = try reader["logging"].readIfPresent()
        value.logGroupName = try reader["logGroupName"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension B2biClientTypes.Tag {

    static func write(value: B2biClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension B2biClientTypes.TransformerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> B2biClientTypes.TransformerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = B2biClientTypes.TransformerSummary()
        value.transformerId = try reader["transformerId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.fileFormat = try reader["fileFormat"].readIfPresent() ?? .sdkUnknown("")
        value.mappingTemplate = try reader["mappingTemplate"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.ediType = try reader["ediType"].readIfPresent(with: B2biClientTypes.EdiType.read(from:))
        value.sampleDocument = try reader["sampleDocument"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

public enum B2biClientTypes {}
