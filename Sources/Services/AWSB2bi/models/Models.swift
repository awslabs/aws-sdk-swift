// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension B2biClientTypes.CapabilityConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case edi
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .edi(edi):
                try container.encode(edi, forKey: .edi)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let ediDecoded = try values.decodeIfPresent(B2biClientTypes.EdiConfiguration.self, forKey: .edi)
        if let edi = ediDecoded {
            self = .edi(edi)
            return
        }
        self = .sdkUnknown("")
    }
}

extension B2biClientTypes {
    /// A capability object. Currently, only EDI (electronic data interchange) capabilities are supported. A trading capability contains the information required to transform incoming EDI documents into JSON or XML outputs.
    public enum CapabilityConfiguration: Swift.Equatable {
        /// An EDI (electronic data interchange) configuration object.
        case edi(B2biClientTypes.EdiConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension B2biClientTypes.CapabilitySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityId
        case createdAt
        case modifiedAt
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilityId = self.capabilityId {
            try encodeContainer.encode(capabilityId, forKey: .capabilityId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .dateTime, forKey: .modifiedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityId)
        capabilityId = capabilityIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(B2biClientTypes.CapabilityType.self, forKey: .type)
        type = typeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

extension B2biClientTypes {
    /// Returns the capability summary details. A trading capability contains the information required to transform incoming EDI documents into JSON or XML outputs.
    public struct CapabilitySummary: Swift.Equatable {
        /// Returns a system-assigned unique identifier for the capability.
        /// This member is required.
        public var capabilityId: Swift.String?
        /// Returns a timestamp for creation date and time of the capability.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Returns a timestamp that identifies the most recent date and time that the capability was modified.
        public var modifiedAt: ClientRuntime.Date?
        /// The display name of the capability.
        /// This member is required.
        public var name: Swift.String?
        /// Returns the type of the capability. Currently, only edi is supported.
        /// This member is required.
        public var type: B2biClientTypes.CapabilityType?

        public init(
            capabilityId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            type: B2biClientTypes.CapabilityType? = nil
        )
        {
            self.capabilityId = capabilityId
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.type = type
        }
    }

}

extension B2biClientTypes {
    public enum CapabilityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case edi
        case sdkUnknown(Swift.String)

        public static var allCases: [CapabilityType] {
            return [
                .edi,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .edi: return "edi"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CapabilityType(rawValue: rawValue) ?? CapabilityType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A conflict exception is thrown when you attempt to delete a resource (such as a profile or a capability) that is being used by other resources.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateCapabilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configuration
        case instructionsDocuments
        case name
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let instructionsDocuments = instructionsDocuments {
            var instructionsDocumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instructionsDocuments)
            for s3location0 in instructionsDocuments {
                try instructionsDocumentsContainer.encode(s3location0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateCapabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateCapabilityInput: Swift.Equatable {
    /// Reserved for future use.
    public var clientToken: Swift.String?
    /// Specifies a structure that contains the details for a capability.
    /// This member is required.
    public var configuration: B2biClientTypes.CapabilityConfiguration?
    /// Specifies one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
    public var instructionsDocuments: [B2biClientTypes.S3Location]?
    /// Specifies the name of the capability, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    public var tags: [B2biClientTypes.Tag]?
    /// Specifies the type of the capability. Currently, only edi is supported.
    /// This member is required.
    public var type: B2biClientTypes.CapabilityType?

    public init(
        clientToken: Swift.String? = nil,
        configuration: B2biClientTypes.CapabilityConfiguration? = nil,
        instructionsDocuments: [B2biClientTypes.S3Location]? = nil,
        name: Swift.String? = nil,
        tags: [B2biClientTypes.Tag]? = nil,
        type: B2biClientTypes.CapabilityType? = nil
    )
    {
        self.clientToken = clientToken
        self.configuration = configuration
        self.instructionsDocuments = instructionsDocuments
        self.name = name
        self.tags = tags
        self.type = type
    }
}

struct CreateCapabilityInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: B2biClientTypes.CapabilityType?
    let configuration: B2biClientTypes.CapabilityConfiguration?
    let instructionsDocuments: [B2biClientTypes.S3Location]?
    let clientToken: Swift.String?
    let tags: [B2biClientTypes.Tag]?
}

extension CreateCapabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case configuration
        case instructionsDocuments
        case name
        case tags
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(B2biClientTypes.CapabilityType.self, forKey: .type)
        type = typeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(B2biClientTypes.CapabilityConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let instructionsDocumentsContainer = try containerValues.decodeIfPresent([B2biClientTypes.S3Location?].self, forKey: .instructionsDocuments)
        var instructionsDocumentsDecoded0:[B2biClientTypes.S3Location]? = nil
        if let instructionsDocumentsContainer = instructionsDocumentsContainer {
            instructionsDocumentsDecoded0 = [B2biClientTypes.S3Location]()
            for structure0 in instructionsDocumentsContainer {
                if let structure0 = structure0 {
                    instructionsDocumentsDecoded0?.append(structure0)
                }
            }
        }
        instructionsDocuments = instructionsDocumentsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([B2biClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[B2biClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [B2biClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCapabilityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCapabilityOutputBody = try responseDecoder.decode(responseBody: data)
            self.capabilityArn = output.capabilityArn
            self.capabilityId = output.capabilityId
            self.configuration = output.configuration
            self.createdAt = output.createdAt
            self.instructionsDocuments = output.instructionsDocuments
            self.name = output.name
            self.type = output.type
        } else {
            self.capabilityArn = nil
            self.capabilityId = nil
            self.configuration = nil
            self.createdAt = nil
            self.instructionsDocuments = nil
            self.name = nil
            self.type = nil
        }
    }
}

public struct CreateCapabilityOutput: Swift.Equatable {
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var capabilityArn: Swift.String?
    /// Returns a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?
    /// Returns a structure that contains the details for a capability.
    /// This member is required.
    public var configuration: B2biClientTypes.CapabilityConfiguration?
    /// Returns a timestamp for creation date and time of the capability.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Returns one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
    public var instructionsDocuments: [B2biClientTypes.S3Location]?
    /// Returns the name of the capability used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the type of the capability. Currently, only edi is supported.
    /// This member is required.
    public var type: B2biClientTypes.CapabilityType?

    public init(
        capabilityArn: Swift.String? = nil,
        capabilityId: Swift.String? = nil,
        configuration: B2biClientTypes.CapabilityConfiguration? = nil,
        createdAt: ClientRuntime.Date? = nil,
        instructionsDocuments: [B2biClientTypes.S3Location]? = nil,
        name: Swift.String? = nil,
        type: B2biClientTypes.CapabilityType? = nil
    )
    {
        self.capabilityArn = capabilityArn
        self.capabilityId = capabilityId
        self.configuration = configuration
        self.createdAt = createdAt
        self.instructionsDocuments = instructionsDocuments
        self.name = name
        self.type = type
    }
}

struct CreateCapabilityOutputBody: Swift.Equatable {
    let capabilityId: Swift.String?
    let capabilityArn: Swift.String?
    let name: Swift.String?
    let type: B2biClientTypes.CapabilityType?
    let configuration: B2biClientTypes.CapabilityConfiguration?
    let instructionsDocuments: [B2biClientTypes.S3Location]?
    let createdAt: ClientRuntime.Date?
}

extension CreateCapabilityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityArn
        case capabilityId
        case configuration
        case createdAt
        case instructionsDocuments
        case name
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityId)
        capabilityId = capabilityIdDecoded
        let capabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityArn)
        capabilityArn = capabilityArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(B2biClientTypes.CapabilityType.self, forKey: .type)
        type = typeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(B2biClientTypes.CapabilityConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let instructionsDocumentsContainer = try containerValues.decodeIfPresent([B2biClientTypes.S3Location?].self, forKey: .instructionsDocuments)
        var instructionsDocumentsDecoded0:[B2biClientTypes.S3Location]? = nil
        if let instructionsDocumentsContainer = instructionsDocumentsContainer {
            instructionsDocumentsDecoded0 = [B2biClientTypes.S3Location]()
            for structure0 in instructionsDocumentsContainer {
                if let structure0 = structure0 {
                    instructionsDocumentsDecoded0?.append(structure0)
                }
            }
        }
        instructionsDocuments = instructionsDocumentsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

enum CreateCapabilityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePartnershipInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePartnershipInput(capabilities: \(Swift.String(describing: capabilities)), clientToken: \(Swift.String(describing: clientToken)), name: \(Swift.String(describing: name)), profileId: \(Swift.String(describing: profileId)), tags: \(Swift.String(describing: tags)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

extension CreatePartnershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case clientToken
        case email
        case name
        case phone
        case profileId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capabilityid0 in capabilities {
                try capabilitiesContainer.encode(capabilityid0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phone = self.phone {
            try encodeContainer.encode(phone, forKey: .phone)
        }
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreatePartnershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePartnershipInput: Swift.Equatable {
    /// Specifies a list of the capabilities associated with this partnership.
    public var capabilities: [Swift.String]?
    /// Reserved for future use.
    public var clientToken: Swift.String?
    /// Specifies the email address associated with this trading partner.
    /// This member is required.
    public var email: Swift.String?
    /// Specifies a descriptive name for the partnership.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the phone number associated with the partnership.
    public var phone: Swift.String?
    /// Specifies the unique, system-generated identifier for the profile connected to this partnership.
    /// This member is required.
    public var profileId: Swift.String?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    public var tags: [B2biClientTypes.Tag]?

    public init(
        capabilities: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        email: Swift.String? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileId: Swift.String? = nil,
        tags: [B2biClientTypes.Tag]? = nil
    )
    {
        self.capabilities = capabilities
        self.clientToken = clientToken
        self.email = email
        self.name = name
        self.phone = phone
        self.profileId = profileId
        self.tags = tags
    }
}

struct CreatePartnershipInputBody: Swift.Equatable {
    let profileId: Swift.String?
    let name: Swift.String?
    let email: Swift.String?
    let phone: Swift.String?
    let capabilities: [Swift.String]?
    let clientToken: Swift.String?
    let tags: [B2biClientTypes.Tag]?
}

extension CreatePartnershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case clientToken
        case email
        case name
        case phone
        case profileId
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let phoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phone)
        phone = phoneDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([B2biClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[B2biClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [B2biClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePartnershipOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePartnershipOutput(capabilities: \(Swift.String(describing: capabilities)), createdAt: \(Swift.String(describing: createdAt)), name: \(Swift.String(describing: name)), partnershipArn: \(Swift.String(describing: partnershipArn)), partnershipId: \(Swift.String(describing: partnershipId)), profileId: \(Swift.String(describing: profileId)), tradingPartnerId: \(Swift.String(describing: tradingPartnerId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

extension CreatePartnershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePartnershipOutputBody = try responseDecoder.decode(responseBody: data)
            self.capabilities = output.capabilities
            self.createdAt = output.createdAt
            self.email = output.email
            self.name = output.name
            self.partnershipArn = output.partnershipArn
            self.partnershipId = output.partnershipId
            self.phone = output.phone
            self.profileId = output.profileId
            self.tradingPartnerId = output.tradingPartnerId
        } else {
            self.capabilities = nil
            self.createdAt = nil
            self.email = nil
            self.name = nil
            self.partnershipArn = nil
            self.partnershipId = nil
            self.phone = nil
            self.profileId = nil
            self.tradingPartnerId = nil
        }
    }
}

public struct CreatePartnershipOutput: Swift.Equatable {
    /// Returns one or more capabilities associated with this partnership.
    public var capabilities: [Swift.String]?
    /// Returns a timestamp for creation date and time of the partnership.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Returns the email address associated with this trading partner.
    public var email: Swift.String?
    /// Returns a descriptive name for the partnership.
    public var name: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var partnershipArn: Swift.String?
    /// Returns the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?
    /// Returns the phone number associated with the partnership.
    public var phone: Swift.String?
    /// Returns the unique, system-generated identifier for the profile connected to this partnership.
    /// This member is required.
    public var profileId: Swift.String?
    /// Returns the unique, system-generated identifier for a trading partner.
    public var tradingPartnerId: Swift.String?

    public init(
        capabilities: [Swift.String]? = nil,
        createdAt: ClientRuntime.Date? = nil,
        email: Swift.String? = nil,
        name: Swift.String? = nil,
        partnershipArn: Swift.String? = nil,
        partnershipId: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileId: Swift.String? = nil,
        tradingPartnerId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.createdAt = createdAt
        self.email = email
        self.name = name
        self.partnershipArn = partnershipArn
        self.partnershipId = partnershipId
        self.phone = phone
        self.profileId = profileId
        self.tradingPartnerId = tradingPartnerId
    }
}

struct CreatePartnershipOutputBody: Swift.Equatable {
    let profileId: Swift.String?
    let partnershipId: Swift.String?
    let partnershipArn: Swift.String?
    let name: Swift.String?
    let email: Swift.String?
    let phone: Swift.String?
    let capabilities: [Swift.String]?
    let tradingPartnerId: Swift.String?
    let createdAt: ClientRuntime.Date?
}

extension CreatePartnershipOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case createdAt
        case email
        case name
        case partnershipArn
        case partnershipId
        case phone
        case profileId
        case tradingPartnerId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let partnershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnershipId)
        partnershipId = partnershipIdDecoded
        let partnershipArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnershipArn)
        partnershipArn = partnershipArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let phoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phone)
        phone = phoneDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let tradingPartnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tradingPartnerId)
        tradingPartnerId = tradingPartnerIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

enum CreatePartnershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProfileInput(businessName: \(Swift.String(describing: businessName)), clientToken: \(Swift.String(describing: clientToken)), logging: \(Swift.String(describing: logging)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

extension CreateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessName
        case clientToken
        case email
        case logging
        case name
        case phone
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let businessName = self.businessName {
            try encodeContainer.encode(businessName, forKey: .businessName)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let logging = self.logging {
            try encodeContainer.encode(logging.rawValue, forKey: .logging)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phone = self.phone {
            try encodeContainer.encode(phone, forKey: .phone)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateProfileInput: Swift.Equatable {
    /// Specifies the name for the business associated with this profile.
    /// This member is required.
    public var businessName: Swift.String?
    /// Reserved for future use.
    public var clientToken: Swift.String?
    /// Specifies the email address associated with this customer profile.
    public var email: Swift.String?
    /// Specifies whether or not logging is enabled for this profile.
    /// This member is required.
    public var logging: B2biClientTypes.Logging?
    /// Specifies the name of the profile.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the phone number associated with the profile.
    /// This member is required.
    public var phone: Swift.String?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    public var tags: [B2biClientTypes.Tag]?

    public init(
        businessName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        email: Swift.String? = nil,
        logging: B2biClientTypes.Logging? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        tags: [B2biClientTypes.Tag]? = nil
    )
    {
        self.businessName = businessName
        self.clientToken = clientToken
        self.email = email
        self.logging = logging
        self.name = name
        self.phone = phone
        self.tags = tags
    }
}

struct CreateProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let email: Swift.String?
    let phone: Swift.String?
    let businessName: Swift.String?
    let logging: B2biClientTypes.Logging?
    let clientToken: Swift.String?
    let tags: [B2biClientTypes.Tag]?
}

extension CreateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessName
        case clientToken
        case email
        case logging
        case name
        case phone
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let phoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phone)
        phone = phoneDecoded
        let businessNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessName)
        businessName = businessNameDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(B2biClientTypes.Logging.self, forKey: .logging)
        logging = loggingDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([B2biClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[B2biClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [B2biClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProfileOutput(businessName: \(Swift.String(describing: businessName)), createdAt: \(Swift.String(describing: createdAt)), logGroupName: \(Swift.String(describing: logGroupName)), logging: \(Swift.String(describing: logging)), name: \(Swift.String(describing: name)), profileArn: \(Swift.String(describing: profileArn)), profileId: \(Swift.String(describing: profileId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

extension CreateProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.businessName = output.businessName
            self.createdAt = output.createdAt
            self.email = output.email
            self.logGroupName = output.logGroupName
            self.logging = output.logging
            self.name = output.name
            self.phone = output.phone
            self.profileArn = output.profileArn
            self.profileId = output.profileId
        } else {
            self.businessName = nil
            self.createdAt = nil
            self.email = nil
            self.logGroupName = nil
            self.logging = nil
            self.name = nil
            self.phone = nil
            self.profileArn = nil
            self.profileId = nil
        }
    }
}

public struct CreateProfileOutput: Swift.Equatable {
    /// Returns the name for the business associated with this profile.
    /// This member is required.
    public var businessName: Swift.String?
    /// Returns a timestamp representing the time the profile was created.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Returns the email address associated with this customer profile.
    public var email: Swift.String?
    /// Returns the name of the logging group.
    public var logGroupName: Swift.String?
    /// Returns whether or not logging is turned on for this profile.
    public var logging: B2biClientTypes.Logging?
    /// Returns the name of the profile, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the phone number associated with the profile.
    /// This member is required.
    public var phone: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for the profile.
    /// This member is required.
    public var profileArn: Swift.String?
    /// Returns the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        businessName: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        email: Swift.String? = nil,
        logGroupName: Swift.String? = nil,
        logging: B2biClientTypes.Logging? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.businessName = businessName
        self.createdAt = createdAt
        self.email = email
        self.logGroupName = logGroupName
        self.logging = logging
        self.name = name
        self.phone = phone
        self.profileArn = profileArn
        self.profileId = profileId
    }
}

struct CreateProfileOutputBody: Swift.Equatable {
    let profileId: Swift.String?
    let profileArn: Swift.String?
    let name: Swift.String?
    let businessName: Swift.String?
    let phone: Swift.String?
    let email: Swift.String?
    let logging: B2biClientTypes.Logging?
    let logGroupName: Swift.String?
    let createdAt: ClientRuntime.Date?
}

extension CreateProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessName
        case createdAt
        case email
        case logGroupName
        case logging
        case name
        case phone
        case profileArn
        case profileId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let businessNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessName)
        businessName = businessNameDecoded
        let phoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phone)
        phone = phoneDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(B2biClientTypes.Logging.self, forKey: .logging)
        logging = loggingDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

enum CreateProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTransformerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case ediType
        case fileFormat
        case mappingTemplate
        case name
        case sampleDocument
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let ediType = self.ediType {
            try encodeContainer.encode(ediType, forKey: .ediType)
        }
        if let fileFormat = self.fileFormat {
            try encodeContainer.encode(fileFormat.rawValue, forKey: .fileFormat)
        }
        if let mappingTemplate = self.mappingTemplate {
            try encodeContainer.encode(mappingTemplate, forKey: .mappingTemplate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sampleDocument = self.sampleDocument {
            try encodeContainer.encode(sampleDocument, forKey: .sampleDocument)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateTransformerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateTransformerInput: Swift.Equatable {
    /// Reserved for future use.
    public var clientToken: Swift.String?
    /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    /// This member is required.
    public var ediType: B2biClientTypes.EdiType?
    /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
    /// This member is required.
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Specifies the name of the mapping template for the transformer. This template is used to convert the input document into the correct set of objects.
    /// This member is required.
    public var mappingTemplate: Swift.String?
    /// Specifies the name of the transformer, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies a sample EDI document that is used by a transformer as a guide for processing the EDI data.
    public var sampleDocument: Swift.String?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    public var tags: [B2biClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = nil,
        mappingTemplate: Swift.String? = nil,
        name: Swift.String? = nil,
        sampleDocument: Swift.String? = nil,
        tags: [B2biClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.mappingTemplate = mappingTemplate
        self.name = name
        self.sampleDocument = sampleDocument
        self.tags = tags
    }
}

struct CreateTransformerInputBody: Swift.Equatable {
    let name: Swift.String?
    let fileFormat: B2biClientTypes.FileFormat?
    let mappingTemplate: Swift.String?
    let ediType: B2biClientTypes.EdiType?
    let sampleDocument: Swift.String?
    let clientToken: Swift.String?
    let tags: [B2biClientTypes.Tag]?
}

extension CreateTransformerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case ediType
        case fileFormat
        case mappingTemplate
        case name
        case sampleDocument
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(B2biClientTypes.FileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let mappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mappingTemplate)
        mappingTemplate = mappingTemplateDecoded
        let ediTypeDecoded = try containerValues.decodeIfPresent(B2biClientTypes.EdiType.self, forKey: .ediType)
        ediType = ediTypeDecoded
        let sampleDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleDocument)
        sampleDocument = sampleDocumentDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([B2biClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[B2biClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [B2biClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTransformerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTransformerOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.ediType = output.ediType
            self.fileFormat = output.fileFormat
            self.mappingTemplate = output.mappingTemplate
            self.name = output.name
            self.sampleDocument = output.sampleDocument
            self.status = output.status
            self.transformerArn = output.transformerArn
            self.transformerId = output.transformerId
        } else {
            self.createdAt = nil
            self.ediType = nil
            self.fileFormat = nil
            self.mappingTemplate = nil
            self.name = nil
            self.sampleDocument = nil
            self.status = nil
            self.transformerArn = nil
            self.transformerId = nil
        }
    }
}

public struct CreateTransformerOutput: Swift.Equatable {
    /// Returns a timestamp for creation date and time of the transformer.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    /// This member is required.
    public var ediType: B2biClientTypes.EdiType?
    /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
    /// This member is required.
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Returns the name of the mapping template for the transformer. This template is used to convert the input document into the correct set of objects.
    /// This member is required.
    public var mappingTemplate: Swift.String?
    /// Returns the name of the transformer, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
    public var sampleDocument: Swift.String?
    /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
    /// This member is required.
    public var status: B2biClientTypes.TransformerStatus?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var transformerArn: Swift.String?
    /// Returns the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = nil,
        mappingTemplate: Swift.String? = nil,
        name: Swift.String? = nil,
        sampleDocument: Swift.String? = nil,
        status: B2biClientTypes.TransformerStatus? = nil,
        transformerArn: Swift.String? = nil,
        transformerId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.mappingTemplate = mappingTemplate
        self.name = name
        self.sampleDocument = sampleDocument
        self.status = status
        self.transformerArn = transformerArn
        self.transformerId = transformerId
    }
}

struct CreateTransformerOutputBody: Swift.Equatable {
    let transformerId: Swift.String?
    let transformerArn: Swift.String?
    let name: Swift.String?
    let fileFormat: B2biClientTypes.FileFormat?
    let mappingTemplate: Swift.String?
    let status: B2biClientTypes.TransformerStatus?
    let ediType: B2biClientTypes.EdiType?
    let sampleDocument: Swift.String?
    let createdAt: ClientRuntime.Date?
}

extension CreateTransformerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case ediType
        case fileFormat
        case mappingTemplate
        case name
        case sampleDocument
        case status
        case transformerArn
        case transformerId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformerId)
        transformerId = transformerIdDecoded
        let transformerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformerArn)
        transformerArn = transformerArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(B2biClientTypes.FileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let mappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mappingTemplate)
        mappingTemplate = mappingTemplateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(B2biClientTypes.TransformerStatus.self, forKey: .status)
        status = statusDecoded
        let ediTypeDecoded = try containerValues.decodeIfPresent(B2biClientTypes.EdiType.self, forKey: .ediType)
        ediType = ediTypeDecoded
        let sampleDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleDocument)
        sampleDocument = sampleDocumentDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

enum CreateTransformerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCapabilityInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteCapabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteCapabilityInput: Swift.Equatable {
    /// Specifies a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?

    public init(
        capabilityId: Swift.String? = nil
    )
    {
        self.capabilityId = capabilityId
    }
}

struct DeleteCapabilityInputBody: Swift.Equatable {
}

extension DeleteCapabilityInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCapabilityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCapabilityOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCapabilityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePartnershipInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeletePartnershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePartnershipInput: Swift.Equatable {
    /// Specifies the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?

    public init(
        partnershipId: Swift.String? = nil
    )
    {
        self.partnershipId = partnershipId
    }
}

struct DeletePartnershipInputBody: Swift.Equatable {
}

extension DeletePartnershipInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePartnershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePartnershipOutput: Swift.Equatable {

    public init() { }
}

enum DeletePartnershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProfileInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProfileInput: Swift.Equatable {
    /// Specifies the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct DeleteProfileInputBody: Swift.Equatable {
}

extension DeleteProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProfileOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTransformerInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteTransformerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteTransformerInput: Swift.Equatable {
    /// Specifies the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        transformerId: Swift.String? = nil
    )
    {
        self.transformerId = transformerId
    }
}

struct DeleteTransformerInputBody: Swift.Equatable {
}

extension DeleteTransformerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTransformerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTransformerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTransformerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension B2biClientTypes.EdiConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputLocation
        case outputLocation
        case transformerId
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputLocation = self.inputLocation {
            try encodeContainer.encode(inputLocation, forKey: .inputLocation)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let transformerId = self.transformerId {
            try encodeContainer.encode(transformerId, forKey: .transformerId)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(B2biClientTypes.EdiType.self, forKey: .type)
        type = typeDecoded
        let inputLocationDecoded = try containerValues.decodeIfPresent(B2biClientTypes.S3Location.self, forKey: .inputLocation)
        inputLocation = inputLocationDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(B2biClientTypes.S3Location.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let transformerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformerId)
        transformerId = transformerIdDecoded
    }
}

extension B2biClientTypes {
    /// Specifies the details for the EDI (electronic data interchange) transformation.
    public struct EdiConfiguration: Swift.Equatable {
        /// Contains the Amazon S3 bucket and prefix for the location of the input file, which is contained in an S3Location object.
        /// This member is required.
        public var inputLocation: B2biClientTypes.S3Location?
        /// Contains the Amazon S3 bucket and prefix for the location of the output file, which is contained in an S3Location object.
        /// This member is required.
        public var outputLocation: B2biClientTypes.S3Location?
        /// Returns the system-assigned unique identifier for the transformer.
        /// This member is required.
        public var transformerId: Swift.String?
        /// Returns the type of the capability. Currently, only edi is supported.
        /// This member is required.
        public var type: B2biClientTypes.EdiType?

        public init(
            inputLocation: B2biClientTypes.S3Location? = nil,
            outputLocation: B2biClientTypes.S3Location? = nil,
            transformerId: Swift.String? = nil,
            type: B2biClientTypes.EdiType? = nil
        )
        {
            self.inputLocation = inputLocation
            self.outputLocation = outputLocation
            self.transformerId = transformerId
            self.type = type
        }
    }

}

extension B2biClientTypes.EdiType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case x12details = "x12Details"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .x12details(x12details):
                try container.encode(x12details, forKey: .x12details)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let x12detailsDecoded = try values.decodeIfPresent(B2biClientTypes.X12Details.self, forKey: .x12details)
        if let x12details = x12detailsDecoded {
            self = .x12details(x12details)
            return
        }
        self = .sdkUnknown("")
    }
}

extension B2biClientTypes {
    /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    public enum EdiType: Swift.Equatable {
        /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        case x12details(B2biClientTypes.X12Details)
        case sdkUnknown(Swift.String)
    }

}

extension B2biClientTypes {
    public enum FileFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case xml
        case sdkUnknown(Swift.String)

        public static var allCases: [FileFormat] {
            return [
                .json,
                .xml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .xml: return "XML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileFormat(rawValue: rawValue) ?? FileFormat.sdkUnknown(rawValue)
        }
    }
}

extension GetCapabilityInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetCapabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetCapabilityInput: Swift.Equatable {
    /// Specifies a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?

    public init(
        capabilityId: Swift.String? = nil
    )
    {
        self.capabilityId = capabilityId
    }
}

struct GetCapabilityInputBody: Swift.Equatable {
}

extension GetCapabilityInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCapabilityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCapabilityOutputBody = try responseDecoder.decode(responseBody: data)
            self.capabilityArn = output.capabilityArn
            self.capabilityId = output.capabilityId
            self.configuration = output.configuration
            self.createdAt = output.createdAt
            self.instructionsDocuments = output.instructionsDocuments
            self.modifiedAt = output.modifiedAt
            self.name = output.name
            self.type = output.type
        } else {
            self.capabilityArn = nil
            self.capabilityId = nil
            self.configuration = nil
            self.createdAt = nil
            self.instructionsDocuments = nil
            self.modifiedAt = nil
            self.name = nil
            self.type = nil
        }
    }
}

public struct GetCapabilityOutput: Swift.Equatable {
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var capabilityArn: Swift.String?
    /// Returns a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?
    /// Returns a structure that contains the details for a capability.
    /// This member is required.
    public var configuration: B2biClientTypes.CapabilityConfiguration?
    /// Returns a timestamp for creation date and time of the capability.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Returns one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
    public var instructionsDocuments: [B2biClientTypes.S3Location]?
    /// Returns a timestamp for last time the capability was modified.
    public var modifiedAt: ClientRuntime.Date?
    /// Returns the name of the capability, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the type of the capability. Currently, only edi is supported.
    /// This member is required.
    public var type: B2biClientTypes.CapabilityType?

    public init(
        capabilityArn: Swift.String? = nil,
        capabilityId: Swift.String? = nil,
        configuration: B2biClientTypes.CapabilityConfiguration? = nil,
        createdAt: ClientRuntime.Date? = nil,
        instructionsDocuments: [B2biClientTypes.S3Location]? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        type: B2biClientTypes.CapabilityType? = nil
    )
    {
        self.capabilityArn = capabilityArn
        self.capabilityId = capabilityId
        self.configuration = configuration
        self.createdAt = createdAt
        self.instructionsDocuments = instructionsDocuments
        self.modifiedAt = modifiedAt
        self.name = name
        self.type = type
    }
}

struct GetCapabilityOutputBody: Swift.Equatable {
    let capabilityId: Swift.String?
    let capabilityArn: Swift.String?
    let name: Swift.String?
    let type: B2biClientTypes.CapabilityType?
    let configuration: B2biClientTypes.CapabilityConfiguration?
    let instructionsDocuments: [B2biClientTypes.S3Location]?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
}

extension GetCapabilityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityArn
        case capabilityId
        case configuration
        case createdAt
        case instructionsDocuments
        case modifiedAt
        case name
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityId)
        capabilityId = capabilityIdDecoded
        let capabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityArn)
        capabilityArn = capabilityArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(B2biClientTypes.CapabilityType.self, forKey: .type)
        type = typeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(B2biClientTypes.CapabilityConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let instructionsDocumentsContainer = try containerValues.decodeIfPresent([B2biClientTypes.S3Location?].self, forKey: .instructionsDocuments)
        var instructionsDocumentsDecoded0:[B2biClientTypes.S3Location]? = nil
        if let instructionsDocumentsContainer = instructionsDocumentsContainer {
            instructionsDocumentsDecoded0 = [B2biClientTypes.S3Location]()
            for structure0 in instructionsDocumentsContainer {
                if let structure0 = structure0 {
                    instructionsDocumentsDecoded0?.append(structure0)
                }
            }
        }
        instructionsDocuments = instructionsDocumentsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

enum GetCapabilityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPartnershipInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetPartnershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPartnershipInput: Swift.Equatable {
    /// Specifies the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?

    public init(
        partnershipId: Swift.String? = nil
    )
    {
        self.partnershipId = partnershipId
    }
}

struct GetPartnershipInputBody: Swift.Equatable {
}

extension GetPartnershipInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPartnershipOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPartnershipOutput(capabilities: \(Swift.String(describing: capabilities)), createdAt: \(Swift.String(describing: createdAt)), modifiedAt: \(Swift.String(describing: modifiedAt)), name: \(Swift.String(describing: name)), partnershipArn: \(Swift.String(describing: partnershipArn)), partnershipId: \(Swift.String(describing: partnershipId)), profileId: \(Swift.String(describing: profileId)), tradingPartnerId: \(Swift.String(describing: tradingPartnerId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

extension GetPartnershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPartnershipOutputBody = try responseDecoder.decode(responseBody: data)
            self.capabilities = output.capabilities
            self.createdAt = output.createdAt
            self.email = output.email
            self.modifiedAt = output.modifiedAt
            self.name = output.name
            self.partnershipArn = output.partnershipArn
            self.partnershipId = output.partnershipId
            self.phone = output.phone
            self.profileId = output.profileId
            self.tradingPartnerId = output.tradingPartnerId
        } else {
            self.capabilities = nil
            self.createdAt = nil
            self.email = nil
            self.modifiedAt = nil
            self.name = nil
            self.partnershipArn = nil
            self.partnershipId = nil
            self.phone = nil
            self.profileId = nil
            self.tradingPartnerId = nil
        }
    }
}

public struct GetPartnershipOutput: Swift.Equatable {
    /// Returns one or more capabilities associated with this partnership.
    public var capabilities: [Swift.String]?
    /// Returns a timestamp for creation date and time of the partnership.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Returns the email address associated with this trading partner.
    public var email: Swift.String?
    /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
    public var modifiedAt: ClientRuntime.Date?
    /// Returns the display name of the partnership
    public var name: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var partnershipArn: Swift.String?
    /// Returns the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?
    /// Returns the phone number associated with the partnership.
    public var phone: Swift.String?
    /// Returns the unique, system-generated identifier for the profile connected to this partnership.
    /// This member is required.
    public var profileId: Swift.String?
    /// Returns the unique identifier for the partner for this partnership.
    public var tradingPartnerId: Swift.String?

    public init(
        capabilities: [Swift.String]? = nil,
        createdAt: ClientRuntime.Date? = nil,
        email: Swift.String? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        partnershipArn: Swift.String? = nil,
        partnershipId: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileId: Swift.String? = nil,
        tradingPartnerId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.createdAt = createdAt
        self.email = email
        self.modifiedAt = modifiedAt
        self.name = name
        self.partnershipArn = partnershipArn
        self.partnershipId = partnershipId
        self.phone = phone
        self.profileId = profileId
        self.tradingPartnerId = tradingPartnerId
    }
}

struct GetPartnershipOutputBody: Swift.Equatable {
    let profileId: Swift.String?
    let partnershipId: Swift.String?
    let partnershipArn: Swift.String?
    let name: Swift.String?
    let email: Swift.String?
    let phone: Swift.String?
    let capabilities: [Swift.String]?
    let tradingPartnerId: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
}

extension GetPartnershipOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case createdAt
        case email
        case modifiedAt
        case name
        case partnershipArn
        case partnershipId
        case phone
        case profileId
        case tradingPartnerId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let partnershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnershipId)
        partnershipId = partnershipIdDecoded
        let partnershipArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnershipArn)
        partnershipArn = partnershipArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let phoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phone)
        phone = phoneDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let tradingPartnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tradingPartnerId)
        tradingPartnerId = tradingPartnerIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

enum GetPartnershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProfileInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetProfileInput: Swift.Equatable {
    /// Specifies the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        profileId: Swift.String? = nil
    )
    {
        self.profileId = profileId
    }
}

struct GetProfileInputBody: Swift.Equatable {
}

extension GetProfileInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProfileOutput(businessName: \(Swift.String(describing: businessName)), createdAt: \(Swift.String(describing: createdAt)), logGroupName: \(Swift.String(describing: logGroupName)), logging: \(Swift.String(describing: logging)), modifiedAt: \(Swift.String(describing: modifiedAt)), name: \(Swift.String(describing: name)), profileArn: \(Swift.String(describing: profileArn)), profileId: \(Swift.String(describing: profileId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

extension GetProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.businessName = output.businessName
            self.createdAt = output.createdAt
            self.email = output.email
            self.logGroupName = output.logGroupName
            self.logging = output.logging
            self.modifiedAt = output.modifiedAt
            self.name = output.name
            self.phone = output.phone
            self.profileArn = output.profileArn
            self.profileId = output.profileId
        } else {
            self.businessName = nil
            self.createdAt = nil
            self.email = nil
            self.logGroupName = nil
            self.logging = nil
            self.modifiedAt = nil
            self.name = nil
            self.phone = nil
            self.profileArn = nil
            self.profileId = nil
        }
    }
}

public struct GetProfileOutput: Swift.Equatable {
    /// Returns the name for the business associated with this profile.
    /// This member is required.
    public var businessName: Swift.String?
    /// Returns a timestamp for creation date and time of the transformer.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Returns the email address associated with this customer profile.
    public var email: Swift.String?
    /// Returns the name of the logging group.
    public var logGroupName: Swift.String?
    /// Returns whether or not logging is enabled for this profile.
    public var logging: B2biClientTypes.Logging?
    /// Returns a timestamp for last time the profile was modified.
    public var modifiedAt: ClientRuntime.Date?
    /// Returns the name of the profile, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the phone number associated with the profile.
    /// This member is required.
    public var phone: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var profileArn: Swift.String?
    /// Returns the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        businessName: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        email: Swift.String? = nil,
        logGroupName: Swift.String? = nil,
        logging: B2biClientTypes.Logging? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.businessName = businessName
        self.createdAt = createdAt
        self.email = email
        self.logGroupName = logGroupName
        self.logging = logging
        self.modifiedAt = modifiedAt
        self.name = name
        self.phone = phone
        self.profileArn = profileArn
        self.profileId = profileId
    }
}

struct GetProfileOutputBody: Swift.Equatable {
    let profileId: Swift.String?
    let profileArn: Swift.String?
    let name: Swift.String?
    let email: Swift.String?
    let phone: Swift.String?
    let businessName: Swift.String?
    let logging: B2biClientTypes.Logging?
    let logGroupName: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
}

extension GetProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessName
        case createdAt
        case email
        case logGroupName
        case logging
        case modifiedAt
        case name
        case phone
        case profileArn
        case profileId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let phoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phone)
        phone = phoneDecoded
        let businessNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessName)
        businessName = businessNameDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(B2biClientTypes.Logging.self, forKey: .logging)
        logging = loggingDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

enum GetProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTransformerInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetTransformerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTransformerInput: Swift.Equatable {
    /// Specifies the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        transformerId: Swift.String? = nil
    )
    {
        self.transformerId = transformerId
    }
}

struct GetTransformerInputBody: Swift.Equatable {
}

extension GetTransformerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTransformerJobInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetTransformerJobInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension GetTransformerJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetTransformerJobInput: Swift.Equatable {
    /// Specifies the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?
    /// Specifies the unique, system-generated identifier for a transformer run.
    /// This member is required.
    public var transformerJobId: Swift.String?

    public init(
        transformerId: Swift.String? = nil,
        transformerJobId: Swift.String? = nil
    )
    {
        self.transformerId = transformerId
        self.transformerJobId = transformerJobId
    }
}

struct GetTransformerJobInputBody: Swift.Equatable {
}

extension GetTransformerJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetTransformerJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTransformerJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.outputFiles = output.outputFiles
            self.status = output.status
        } else {
            self.message = nil
            self.outputFiles = nil
            self.status = nil
        }
    }
}

public struct GetTransformerJobOutput: Swift.Equatable {
    /// Returns an optional error message, which gets populated when the job is not run successfully.
    public var message: Swift.String?
    /// Returns the location for the output files. If the caller specified a directory for the output, then this contains the full path to the output file, including the file name generated by the service.
    public var outputFiles: [B2biClientTypes.S3Location]?
    /// Returns the current state of the transformer job, either running, succeeded, or failed.
    /// This member is required.
    public var status: B2biClientTypes.TransformerJobStatus?

    public init(
        message: Swift.String? = nil,
        outputFiles: [B2biClientTypes.S3Location]? = nil,
        status: B2biClientTypes.TransformerJobStatus? = nil
    )
    {
        self.message = message
        self.outputFiles = outputFiles
        self.status = status
    }
}

struct GetTransformerJobOutputBody: Swift.Equatable {
    let status: B2biClientTypes.TransformerJobStatus?
    let outputFiles: [B2biClientTypes.S3Location]?
    let message: Swift.String?
}

extension GetTransformerJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case outputFiles
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(B2biClientTypes.TransformerJobStatus.self, forKey: .status)
        status = statusDecoded
        let outputFilesContainer = try containerValues.decodeIfPresent([B2biClientTypes.S3Location?].self, forKey: .outputFiles)
        var outputFilesDecoded0:[B2biClientTypes.S3Location]? = nil
        if let outputFilesContainer = outputFilesContainer {
            outputFilesDecoded0 = [B2biClientTypes.S3Location]()
            for structure0 in outputFilesContainer {
                if let structure0 = structure0 {
                    outputFilesDecoded0?.append(structure0)
                }
            }
        }
        outputFiles = outputFilesDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum GetTransformerJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTransformerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTransformerOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.ediType = output.ediType
            self.fileFormat = output.fileFormat
            self.mappingTemplate = output.mappingTemplate
            self.modifiedAt = output.modifiedAt
            self.name = output.name
            self.sampleDocument = output.sampleDocument
            self.status = output.status
            self.transformerArn = output.transformerArn
            self.transformerId = output.transformerId
        } else {
            self.createdAt = nil
            self.ediType = nil
            self.fileFormat = nil
            self.mappingTemplate = nil
            self.modifiedAt = nil
            self.name = nil
            self.sampleDocument = nil
            self.status = nil
            self.transformerArn = nil
            self.transformerId = nil
        }
    }
}

public struct GetTransformerOutput: Swift.Equatable {
    /// Returns a timestamp for creation date and time of the transformer.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    /// This member is required.
    public var ediType: B2biClientTypes.EdiType?
    /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
    /// This member is required.
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Returns the name of the mapping template for the transformer. This template is used to convert the input document into the correct set of objects.
    /// This member is required.
    public var mappingTemplate: Swift.String?
    /// Returns a timestamp for last time the transformer was modified.
    public var modifiedAt: ClientRuntime.Date?
    /// Returns the name of the transformer, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
    public var sampleDocument: Swift.String?
    /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
    /// This member is required.
    public var status: B2biClientTypes.TransformerStatus?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var transformerArn: Swift.String?
    /// Returns the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = nil,
        mappingTemplate: Swift.String? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        sampleDocument: Swift.String? = nil,
        status: B2biClientTypes.TransformerStatus? = nil,
        transformerArn: Swift.String? = nil,
        transformerId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.mappingTemplate = mappingTemplate
        self.modifiedAt = modifiedAt
        self.name = name
        self.sampleDocument = sampleDocument
        self.status = status
        self.transformerArn = transformerArn
        self.transformerId = transformerId
    }
}

struct GetTransformerOutputBody: Swift.Equatable {
    let transformerId: Swift.String?
    let transformerArn: Swift.String?
    let name: Swift.String?
    let fileFormat: B2biClientTypes.FileFormat?
    let mappingTemplate: Swift.String?
    let status: B2biClientTypes.TransformerStatus?
    let ediType: B2biClientTypes.EdiType?
    let sampleDocument: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
}

extension GetTransformerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case ediType
        case fileFormat
        case mappingTemplate
        case modifiedAt
        case name
        case sampleDocument
        case status
        case transformerArn
        case transformerId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformerId)
        transformerId = transformerIdDecoded
        let transformerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformerArn)
        transformerArn = transformerArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(B2biClientTypes.FileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let mappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mappingTemplate)
        mappingTemplate = mappingTemplateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(B2biClientTypes.TransformerStatus.self, forKey: .status)
        status = statusDecoded
        let ediTypeDecoded = try containerValues.decodeIfPresent(B2biClientTypes.EdiType.self, forKey: .ediType)
        ediType = ediTypeDecoded
        let sampleDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleDocument)
        sampleDocument = sampleDocumentDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

enum GetTransformerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception is thrown when an error occurs in the Amazon Web Services B2B Data Interchange service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The server attempts to retry a failed command.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListCapabilitiesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListCapabilitiesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListCapabilitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCapabilitiesInput: Swift.Equatable {
    /// Specifies the maximum number of capabilities to return.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCapabilitiesInputBody: Swift.Equatable {
}

extension ListCapabilitiesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCapabilitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCapabilitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.capabilities = output.capabilities
            self.nextToken = output.nextToken
        } else {
            self.capabilities = nil
            self.nextToken = nil
        }
    }
}

public struct ListCapabilitiesOutput: Swift.Equatable {
    /// Returns one or more capabilities associated with this partnership.
    /// This member is required.
    public var capabilities: [B2biClientTypes.CapabilitySummary]?
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?

    public init(
        capabilities: [B2biClientTypes.CapabilitySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.nextToken = nextToken
    }
}

struct ListCapabilitiesOutputBody: Swift.Equatable {
    let capabilities: [B2biClientTypes.CapabilitySummary]?
    let nextToken: Swift.String?
}

extension ListCapabilitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilitiesContainer = try containerValues.decodeIfPresent([B2biClientTypes.CapabilitySummary?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[B2biClientTypes.CapabilitySummary]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [B2biClientTypes.CapabilitySummary]()
            for structure0 in capabilitiesContainer {
                if let structure0 = structure0 {
                    capabilitiesDecoded0?.append(structure0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCapabilitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPartnershipsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListPartnershipsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListPartnershipsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPartnershipsInput: Swift.Equatable {
    /// Specifies the maximum number of capabilities to return.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?
    /// Specifies the unique, system-generated identifier for the profile connected to this partnership.
    public var profileId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profileId = profileId
    }
}

struct ListPartnershipsInputBody: Swift.Equatable {
}

extension ListPartnershipsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPartnershipsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPartnershipsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.partnerships = output.partnerships
        } else {
            self.nextToken = nil
            self.partnerships = nil
        }
    }
}

public struct ListPartnershipsOutput: Swift.Equatable {
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?
    /// Specifies a list of your partnerships.
    /// This member is required.
    public var partnerships: [B2biClientTypes.PartnershipSummary]?

    public init(
        nextToken: Swift.String? = nil,
        partnerships: [B2biClientTypes.PartnershipSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.partnerships = partnerships
    }
}

struct ListPartnershipsOutputBody: Swift.Equatable {
    let partnerships: [B2biClientTypes.PartnershipSummary]?
    let nextToken: Swift.String?
}

extension ListPartnershipsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case partnerships
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partnershipsContainer = try containerValues.decodeIfPresent([B2biClientTypes.PartnershipSummary?].self, forKey: .partnerships)
        var partnershipsDecoded0:[B2biClientTypes.PartnershipSummary]? = nil
        if let partnershipsContainer = partnershipsContainer {
            partnershipsDecoded0 = [B2biClientTypes.PartnershipSummary]()
            for structure0 in partnershipsContainer {
                if let structure0 = structure0 {
                    partnershipsDecoded0?.append(structure0)
                }
            }
        }
        partnerships = partnershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPartnershipsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProfilesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProfilesInput: Swift.Equatable {
    /// Specifies the maximum number of profiles to return.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProfilesInputBody: Swift.Equatable {
}

extension ListProfilesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProfilesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProfilesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.profiles = output.profiles
        } else {
            self.nextToken = nil
            self.profiles = nil
        }
    }
}

public struct ListProfilesOutput: Swift.Equatable {
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?
    /// Returns an array of ProfileSummary objects.
    /// This member is required.
    public var profiles: [B2biClientTypes.ProfileSummary]?

    public init(
        nextToken: Swift.String? = nil,
        profiles: [B2biClientTypes.ProfileSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
    }
}

struct ListProfilesOutputBody: Swift.Equatable {
    let profiles: [B2biClientTypes.ProfileSummary]?
    let nextToken: Swift.String?
}

extension ListProfilesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case profiles
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilesContainer = try containerValues.decodeIfPresent([B2biClientTypes.ProfileSummary?].self, forKey: .profiles)
        var profilesDecoded0:[B2biClientTypes.ProfileSummary]? = nil
        if let profilesContainer = profilesContainer {
            profilesDecoded0 = [B2biClientTypes.ProfileSummary]()
            for structure0 in profilesContainer {
                if let structure0 = structure0 {
                    profilesDecoded0?.append(structure0)
                }
            }
        }
        profiles = profilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProfilesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// Requests the tags associated with a particular Amazon Resource Name (ARN). An ARN is an identifier for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Returns the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    public var tags: [B2biClientTypes.Tag]?

    public init(
        tags: [B2biClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [B2biClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([B2biClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[B2biClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [B2biClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTransformersInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ListTransformersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension ListTransformersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTransformersInput: Swift.Equatable {
    /// Specifies the number of items to return for the API response.
    public var maxResults: Swift.Int?
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTransformersInputBody: Swift.Equatable {
}

extension ListTransformersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTransformersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTransformersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.transformers = output.transformers
        } else {
            self.nextToken = nil
            self.transformers = nil
        }
    }
}

public struct ListTransformersOutput: Swift.Equatable {
    /// When additional results are obtained from the command, a NextToken parameter is returned in the output. You can then pass the NextToken parameter in a subsequent command to continue listing additional resources.
    public var nextToken: Swift.String?
    /// Returns an array of one or more transformer objects. For each transformer, a TransformerSummary object is returned. The TransformerSummary contains all the details for a specific transformer.
    /// This member is required.
    public var transformers: [B2biClientTypes.TransformerSummary]?

    public init(
        nextToken: Swift.String? = nil,
        transformers: [B2biClientTypes.TransformerSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.transformers = transformers
    }
}

struct ListTransformersOutputBody: Swift.Equatable {
    let transformers: [B2biClientTypes.TransformerSummary]?
    let nextToken: Swift.String?
}

extension ListTransformersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case transformers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformersContainer = try containerValues.decodeIfPresent([B2biClientTypes.TransformerSummary?].self, forKey: .transformers)
        var transformersDecoded0:[B2biClientTypes.TransformerSummary]? = nil
        if let transformersContainer = transformersContainer {
            transformersDecoded0 = [B2biClientTypes.TransformerSummary]()
            for structure0 in transformersContainer {
                if let structure0 = structure0 {
                    transformersDecoded0?.append(structure0)
                }
            }
        }
        transformers = transformersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTransformersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension B2biClientTypes {
    public enum Logging: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [Logging] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Logging(rawValue: rawValue) ?? Logging.sdkUnknown(rawValue)
        }
    }
}

extension B2biClientTypes.PartnershipSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case createdAt
        case modifiedAt
        case name
        case partnershipId
        case profileId
        case tradingPartnerId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capabilityid0 in capabilities {
                try capabilitiesContainer.encode(capabilityid0)
            }
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .dateTime, forKey: .modifiedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let partnershipId = self.partnershipId {
            try encodeContainer.encode(partnershipId, forKey: .partnershipId)
        }
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
        if let tradingPartnerId = self.tradingPartnerId {
            try encodeContainer.encode(tradingPartnerId, forKey: .tradingPartnerId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let partnershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnershipId)
        partnershipId = partnershipIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let tradingPartnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tradingPartnerId)
        tradingPartnerId = tradingPartnerIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

extension B2biClientTypes {
    /// A structure that contains the details for a partnership. A partnership represents the connection between you and your trading partner. It ties together a profile and one or more trading capabilities.
    public struct PartnershipSummary: Swift.Equatable {
        /// Returns one or more capabilities associated with this partnership.
        public var capabilities: [Swift.String]?
        /// Returns a timestamp for creation date and time of the partnership.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
        public var modifiedAt: ClientRuntime.Date?
        /// Returns the name of the partnership.
        public var name: Swift.String?
        /// Returns the unique, system-generated identifier for a partnership.
        /// This member is required.
        public var partnershipId: Swift.String?
        /// Returns the unique, system-generated identifier for the profile connected to this partnership.
        /// This member is required.
        public var profileId: Swift.String?
        /// Returns the unique, system-generated identifier for a trading partner.
        public var tradingPartnerId: Swift.String?

        public init(
            capabilities: [Swift.String]? = nil,
            createdAt: ClientRuntime.Date? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            partnershipId: Swift.String? = nil,
            profileId: Swift.String? = nil,
            tradingPartnerId: Swift.String? = nil
        )
        {
            self.capabilities = capabilities
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.partnershipId = partnershipId
            self.profileId = profileId
            self.tradingPartnerId = tradingPartnerId
        }
    }

}

extension B2biClientTypes.ProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessName
        case createdAt
        case logGroupName
        case logging
        case modifiedAt
        case name
        case profileId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let businessName = self.businessName {
            try encodeContainer.encode(businessName, forKey: .businessName)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let logGroupName = self.logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
        if let logging = self.logging {
            try encodeContainer.encode(logging.rawValue, forKey: .logging)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .dateTime, forKey: .modifiedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let profileId = self.profileId {
            try encodeContainer.encode(profileId, forKey: .profileId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let businessNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessName)
        businessName = businessNameDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(B2biClientTypes.Logging.self, forKey: .logging)
        logging = loggingDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

extension B2biClientTypes {
    /// Contains the details for a profile. A profile is the mechanism used to create the concept of a private network.
    public struct ProfileSummary: Swift.Equatable {
        /// Returns the name for the business associated with this profile.
        /// This member is required.
        public var businessName: Swift.String?
        /// Returns the timestamp for creation date and time of the profile.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Returns the name of the logging group.
        public var logGroupName: Swift.String?
        /// Specifies whether or not logging is enabled for this profile.
        public var logging: B2biClientTypes.Logging?
        /// Returns the timestamp that identifies the most recent date and time that the profile was modified.
        public var modifiedAt: ClientRuntime.Date?
        /// Returns the display name for profile.
        /// This member is required.
        public var name: Swift.String?
        /// Returns the unique, system-generated identifier for the profile.
        /// This member is required.
        public var profileId: Swift.String?

        public init(
            businessName: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            logGroupName: Swift.String? = nil,
            logging: B2biClientTypes.Logging? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            profileId: Swift.String? = nil
        )
        {
            self.businessName = businessName
            self.createdAt = createdAt
            self.logGroupName = logGroupName
            self.logging = logging
            self.modifiedAt = modifiedAt
            self.name = name
            self.profileId = profileId
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Occurs when the requested resource does not exist, or cannot be found. In some cases, the resource exists in a region other than the region specified in the API call.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension B2biClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension B2biClientTypes {
    /// Specifies the details for the Amazon S3 file location that is being used with Amazon Web Services B2BI Data Interchange. File locations in Amazon S3 are identified using a combination of the bucket and key.
    public struct S3Location: Swift.Equatable {
        /// Specifies the name of the Amazon S3 bucket.
        public var bucketName: Swift.String?
        /// Specifies the Amazon S3 key for the file location.
        public var key: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.key = key
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Occurs when the calling command attempts to exceed one of the service quotas, for example trying to create a capability when you already have the maximum number of capabilities allowed.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota that was exceeded, which caused the exception.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID for the resource that exceeded the quota, which caused the exception.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type (profile, partnership, transformer, or capability) that exceeded the quota, which caused the exception.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The code responsible for exceeding the quota, which caused the exception.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension StartTransformerJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case inputFile
        case outputLocation
        case transformerId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let inputFile = self.inputFile {
            try encodeContainer.encode(inputFile, forKey: .inputFile)
        }
        if let outputLocation = self.outputLocation {
            try encodeContainer.encode(outputLocation, forKey: .outputLocation)
        }
        if let transformerId = self.transformerId {
            try encodeContainer.encode(transformerId, forKey: .transformerId)
        }
    }
}

extension StartTransformerJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartTransformerJobInput: Swift.Equatable {
    /// Reserved for future use.
    public var clientToken: Swift.String?
    /// Specifies the location of the input file for the transformation. The location consists of an Amazon S3 bucket and prefix.
    /// This member is required.
    public var inputFile: B2biClientTypes.S3Location?
    /// Specifies the location of the output file for the transformation. The location consists of an Amazon S3 bucket and prefix.
    /// This member is required.
    public var outputLocation: B2biClientTypes.S3Location?
    /// Specifies the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        inputFile: B2biClientTypes.S3Location? = nil,
        outputLocation: B2biClientTypes.S3Location? = nil,
        transformerId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.inputFile = inputFile
        self.outputLocation = outputLocation
        self.transformerId = transformerId
    }
}

struct StartTransformerJobInputBody: Swift.Equatable {
    let inputFile: B2biClientTypes.S3Location?
    let outputLocation: B2biClientTypes.S3Location?
    let transformerId: Swift.String?
    let clientToken: Swift.String?
}

extension StartTransformerJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case inputFile
        case outputLocation
        case transformerId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputFileDecoded = try containerValues.decodeIfPresent(B2biClientTypes.S3Location.self, forKey: .inputFile)
        inputFile = inputFileDecoded
        let outputLocationDecoded = try containerValues.decodeIfPresent(B2biClientTypes.S3Location.self, forKey: .outputLocation)
        outputLocation = outputLocationDecoded
        let transformerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformerId)
        transformerId = transformerIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartTransformerJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartTransformerJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.transformerJobId = output.transformerJobId
        } else {
            self.transformerJobId = nil
        }
    }
}

public struct StartTransformerJobOutput: Swift.Equatable {
    /// Returns the unique, system-generated identifier for a transformer run.
    /// This member is required.
    public var transformerJobId: Swift.String?

    public init(
        transformerJobId: Swift.String? = nil
    )
    {
        self.transformerJobId = transformerJobId
    }
}

struct StartTransformerJobOutputBody: Swift.Equatable {
    let transformerJobId: Swift.String?
}

extension StartTransformerJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transformerJobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformerJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformerJobId)
        transformerJobId = transformerJobIdDecoded
    }
}

enum StartTransformerJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension B2biClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension B2biClientTypes {
    /// Creates a key-value pair for a specific resource. Tags are metadata that you can use to search for and group a resource for various purposes. You can apply tags to capabilities, partnerships, profiles and transformers. A tag key can take more than one value. For example, to group capabilities for accounting purposes, you might create a tag called Group and assign the values Research and Accounting to that group.
    public struct Tag: Swift.Equatable {
        /// Specifies the name assigned to the tag that you create.
        /// This member is required.
        public var key: Swift.String?
        /// Contains one or more values that you assigned to the key name that you create.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// Specifies an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    /// This member is required.
    public var tags: [B2biClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [B2biClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [B2biClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([B2biClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[B2biClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [B2biClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TestMappingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileFormat
        case inputFileContent
        case mappingTemplate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileFormat = self.fileFormat {
            try encodeContainer.encode(fileFormat.rawValue, forKey: .fileFormat)
        }
        if let inputFileContent = self.inputFileContent {
            try encodeContainer.encode(inputFileContent, forKey: .inputFileContent)
        }
        if let mappingTemplate = self.mappingTemplate {
            try encodeContainer.encode(mappingTemplate, forKey: .mappingTemplate)
        }
    }
}

extension TestMappingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TestMappingInput: Swift.Equatable {
    /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
    /// This member is required.
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Specify the contents of the EDI (electronic data interchange) XML or JSON file that is used as input for the transform.
    /// This member is required.
    public var inputFileContent: Swift.String?
    /// Specifies the name of the mapping template for the transformer. This template is used to convert the input document into the correct set of objects.
    /// This member is required.
    public var mappingTemplate: Swift.String?

    public init(
        fileFormat: B2biClientTypes.FileFormat? = nil,
        inputFileContent: Swift.String? = nil,
        mappingTemplate: Swift.String? = nil
    )
    {
        self.fileFormat = fileFormat
        self.inputFileContent = inputFileContent
        self.mappingTemplate = mappingTemplate
    }
}

struct TestMappingInputBody: Swift.Equatable {
    let inputFileContent: Swift.String?
    let mappingTemplate: Swift.String?
    let fileFormat: B2biClientTypes.FileFormat?
}

extension TestMappingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileFormat
        case inputFileContent
        case mappingTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputFileContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputFileContent)
        inputFileContent = inputFileContentDecoded
        let mappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mappingTemplate)
        mappingTemplate = mappingTemplateDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(B2biClientTypes.FileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
    }
}

extension TestMappingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TestMappingOutputBody = try responseDecoder.decode(responseBody: data)
            self.mappedFileContent = output.mappedFileContent
        } else {
            self.mappedFileContent = nil
        }
    }
}

public struct TestMappingOutput: Swift.Equatable {
    /// Returns a string for the mapping that can be used to identify the mapping. Similar to a fingerprint
    /// This member is required.
    public var mappedFileContent: Swift.String?

    public init(
        mappedFileContent: Swift.String? = nil
    )
    {
        self.mappedFileContent = mappedFileContent
    }
}

struct TestMappingOutputBody: Swift.Equatable {
    let mappedFileContent: Swift.String?
}

extension TestMappingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mappedFileContent
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mappedFileContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mappedFileContent)
        mappedFileContent = mappedFileContentDecoded
    }
}

enum TestMappingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TestParsingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ediType
        case fileFormat
        case inputFile
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ediType = self.ediType {
            try encodeContainer.encode(ediType, forKey: .ediType)
        }
        if let fileFormat = self.fileFormat {
            try encodeContainer.encode(fileFormat.rawValue, forKey: .fileFormat)
        }
        if let inputFile = self.inputFile {
            try encodeContainer.encode(inputFile, forKey: .inputFile)
        }
    }
}

extension TestParsingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TestParsingInput: Swift.Equatable {
    /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    /// This member is required.
    public var ediType: B2biClientTypes.EdiType?
    /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
    /// This member is required.
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Specifies an S3Location object, which contains the Amazon S3 bucket and prefix for the location of the input file.
    /// This member is required.
    public var inputFile: B2biClientTypes.S3Location?

    public init(
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = nil,
        inputFile: B2biClientTypes.S3Location? = nil
    )
    {
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.inputFile = inputFile
    }
}

struct TestParsingInputBody: Swift.Equatable {
    let inputFile: B2biClientTypes.S3Location?
    let fileFormat: B2biClientTypes.FileFormat?
    let ediType: B2biClientTypes.EdiType?
}

extension TestParsingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ediType
        case fileFormat
        case inputFile
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputFileDecoded = try containerValues.decodeIfPresent(B2biClientTypes.S3Location.self, forKey: .inputFile)
        inputFile = inputFileDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(B2biClientTypes.FileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let ediTypeDecoded = try containerValues.decodeIfPresent(B2biClientTypes.EdiType.self, forKey: .ediType)
        ediType = ediTypeDecoded
    }
}

extension TestParsingOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TestParsingOutputBody = try responseDecoder.decode(responseBody: data)
            self.parsedFileContent = output.parsedFileContent
        } else {
            self.parsedFileContent = nil
        }
    }
}

public struct TestParsingOutput: Swift.Equatable {
    /// Returns the contents of the input file being tested, parsed according to the specified EDI (electronic data interchange) type.
    /// This member is required.
    public var parsedFileContent: Swift.String?

    public init(
        parsedFileContent: Swift.String? = nil
    )
    {
        self.parsedFileContent = parsedFileContent
    }
}

struct TestParsingOutputBody: Swift.Equatable {
    let parsedFileContent: Swift.String?
}

extension TestParsingOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parsedFileContent
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parsedFileContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parsedFileContent)
        parsedFileContent = parsedFileContentDecoded
    }
}

enum TestParsingOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to throttling: the data speed and rendering may be limited depending on various parameters and conditions.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The server attempts to retry a command that was throttled.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension B2biClientTypes {
    public enum TransformerJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [TransformerJobStatus] {
            return [
                .failed,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "failed"
            case .running: return "running"
            case .succeeded: return "succeeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransformerJobStatus(rawValue: rawValue) ?? TransformerJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension B2biClientTypes {
    public enum TransformerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [TransformerStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "active"
            case .inactive: return "inactive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransformerStatus(rawValue: rawValue) ?? TransformerStatus.sdkUnknown(rawValue)
        }
    }
}

extension B2biClientTypes.TransformerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case ediType
        case fileFormat
        case mappingTemplate
        case modifiedAt
        case name
        case sampleDocument
        case status
        case transformerId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let ediType = self.ediType {
            try encodeContainer.encode(ediType, forKey: .ediType)
        }
        if let fileFormat = self.fileFormat {
            try encodeContainer.encode(fileFormat.rawValue, forKey: .fileFormat)
        }
        if let mappingTemplate = self.mappingTemplate {
            try encodeContainer.encode(mappingTemplate, forKey: .mappingTemplate)
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .dateTime, forKey: .modifiedAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sampleDocument = self.sampleDocument {
            try encodeContainer.encode(sampleDocument, forKey: .sampleDocument)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let transformerId = self.transformerId {
            try encodeContainer.encode(transformerId, forKey: .transformerId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformerId)
        transformerId = transformerIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(B2biClientTypes.FileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let mappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mappingTemplate)
        mappingTemplate = mappingTemplateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(B2biClientTypes.TransformerStatus.self, forKey: .status)
        status = statusDecoded
        let ediTypeDecoded = try containerValues.decodeIfPresent(B2biClientTypes.EdiType.self, forKey: .ediType)
        ediType = ediTypeDecoded
        let sampleDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleDocument)
        sampleDocument = sampleDocumentDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

extension B2biClientTypes {
    /// Contains the details for a transformer object. A transformer describes how to process the incoming EDI documents and extract the necessary information to the output file.
    public struct TransformerSummary: Swift.Equatable {
        /// Returns a timestamp indicating when the transformer was created. For example, 2023-07-20T19:58:44.624Z.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
        /// This member is required.
        public var ediType: B2biClientTypes.EdiType?
        /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
        /// This member is required.
        public var fileFormat: B2biClientTypes.FileFormat?
        /// Returns the name of the mapping template for the transformer. This template is used to convert the input document into the correct set of objects.
        /// This member is required.
        public var mappingTemplate: Swift.String?
        /// Returns a timestamp representing the date and time for the most recent change for the transformer object.
        public var modifiedAt: ClientRuntime.Date?
        /// Returns the descriptive name for the transformer.
        /// This member is required.
        public var name: Swift.String?
        /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
        public var sampleDocument: Swift.String?
        /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
        /// This member is required.
        public var status: B2biClientTypes.TransformerStatus?
        /// Returns the system-assigned unique identifier for the transformer.
        /// This member is required.
        public var transformerId: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            ediType: B2biClientTypes.EdiType? = nil,
            fileFormat: B2biClientTypes.FileFormat? = nil,
            mappingTemplate: Swift.String? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            sampleDocument: Swift.String? = nil,
            status: B2biClientTypes.TransformerStatus? = nil,
            transformerId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.ediType = ediType
            self.fileFormat = fileFormat
            self.mappingTemplate = mappingTemplate
            self.modifiedAt = modifiedAt
            self.name = name
            self.sampleDocument = sampleDocument
            self.status = status
            self.transformerId = transformerId
        }
    }

}

extension UntagResourceInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Specifies an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// Specifies the key-value pairs assigned to ARNs that you can use to group and search for resources by type. You can attach this metadata to resources (capabilities, partnerships, and so on) for any purpose.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCapabilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case instructionsDocuments
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let instructionsDocuments = instructionsDocuments {
            var instructionsDocumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instructionsDocuments)
            for s3location0 in instructionsDocuments {
                try instructionsDocumentsContainer.encode(s3location0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateCapabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateCapabilityInput: Swift.Equatable {
    /// Specifies a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?
    /// Specifies a structure that contains the details for a capability.
    public var configuration: B2biClientTypes.CapabilityConfiguration?
    /// Specifies one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
    public var instructionsDocuments: [B2biClientTypes.S3Location]?
    /// Specifies a new name for the capability, to replace the existing name.
    public var name: Swift.String?

    public init(
        capabilityId: Swift.String? = nil,
        configuration: B2biClientTypes.CapabilityConfiguration? = nil,
        instructionsDocuments: [B2biClientTypes.S3Location]? = nil,
        name: Swift.String? = nil
    )
    {
        self.capabilityId = capabilityId
        self.configuration = configuration
        self.instructionsDocuments = instructionsDocuments
        self.name = name
    }
}

struct UpdateCapabilityInputBody: Swift.Equatable {
    let name: Swift.String?
    let configuration: B2biClientTypes.CapabilityConfiguration?
    let instructionsDocuments: [B2biClientTypes.S3Location]?
}

extension UpdateCapabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case instructionsDocuments
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(B2biClientTypes.CapabilityConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let instructionsDocumentsContainer = try containerValues.decodeIfPresent([B2biClientTypes.S3Location?].self, forKey: .instructionsDocuments)
        var instructionsDocumentsDecoded0:[B2biClientTypes.S3Location]? = nil
        if let instructionsDocumentsContainer = instructionsDocumentsContainer {
            instructionsDocumentsDecoded0 = [B2biClientTypes.S3Location]()
            for structure0 in instructionsDocumentsContainer {
                if let structure0 = structure0 {
                    instructionsDocumentsDecoded0?.append(structure0)
                }
            }
        }
        instructionsDocuments = instructionsDocumentsDecoded0
    }
}

extension UpdateCapabilityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCapabilityOutputBody = try responseDecoder.decode(responseBody: data)
            self.capabilityArn = output.capabilityArn
            self.capabilityId = output.capabilityId
            self.configuration = output.configuration
            self.createdAt = output.createdAt
            self.instructionsDocuments = output.instructionsDocuments
            self.modifiedAt = output.modifiedAt
            self.name = output.name
            self.type = output.type
        } else {
            self.capabilityArn = nil
            self.capabilityId = nil
            self.configuration = nil
            self.createdAt = nil
            self.instructionsDocuments = nil
            self.modifiedAt = nil
            self.name = nil
            self.type = nil
        }
    }
}

public struct UpdateCapabilityOutput: Swift.Equatable {
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var capabilityArn: Swift.String?
    /// Returns a system-assigned unique identifier for the capability.
    /// This member is required.
    public var capabilityId: Swift.String?
    /// Returns a structure that contains the details for a capability.
    /// This member is required.
    public var configuration: B2biClientTypes.CapabilityConfiguration?
    /// Returns a timestamp for creation date and time of the capability.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Returns one or more locations in Amazon S3, each specifying an EDI document that can be used with this capability. Each item contains the name of the bucket and the key, to identify the document's location.
    public var instructionsDocuments: [B2biClientTypes.S3Location]?
    /// Returns a timestamp for last time the capability was modified.
    public var modifiedAt: ClientRuntime.Date?
    /// Returns the name of the capability, used to identify it.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the type of the capability. Currently, only edi is supported.
    /// This member is required.
    public var type: B2biClientTypes.CapabilityType?

    public init(
        capabilityArn: Swift.String? = nil,
        capabilityId: Swift.String? = nil,
        configuration: B2biClientTypes.CapabilityConfiguration? = nil,
        createdAt: ClientRuntime.Date? = nil,
        instructionsDocuments: [B2biClientTypes.S3Location]? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        type: B2biClientTypes.CapabilityType? = nil
    )
    {
        self.capabilityArn = capabilityArn
        self.capabilityId = capabilityId
        self.configuration = configuration
        self.createdAt = createdAt
        self.instructionsDocuments = instructionsDocuments
        self.modifiedAt = modifiedAt
        self.name = name
        self.type = type
    }
}

struct UpdateCapabilityOutputBody: Swift.Equatable {
    let capabilityId: Swift.String?
    let capabilityArn: Swift.String?
    let name: Swift.String?
    let type: B2biClientTypes.CapabilityType?
    let configuration: B2biClientTypes.CapabilityConfiguration?
    let instructionsDocuments: [B2biClientTypes.S3Location]?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
}

extension UpdateCapabilityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityArn
        case capabilityId
        case configuration
        case createdAt
        case instructionsDocuments
        case modifiedAt
        case name
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityId)
        capabilityId = capabilityIdDecoded
        let capabilityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityArn)
        capabilityArn = capabilityArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(B2biClientTypes.CapabilityType.self, forKey: .type)
        type = typeDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(B2biClientTypes.CapabilityConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let instructionsDocumentsContainer = try containerValues.decodeIfPresent([B2biClientTypes.S3Location?].self, forKey: .instructionsDocuments)
        var instructionsDocumentsDecoded0:[B2biClientTypes.S3Location]? = nil
        if let instructionsDocumentsContainer = instructionsDocumentsContainer {
            instructionsDocumentsDecoded0 = [B2biClientTypes.S3Location]()
            for structure0 in instructionsDocumentsContainer {
                if let structure0 = structure0 {
                    instructionsDocumentsDecoded0?.append(structure0)
                }
            }
        }
        instructionsDocuments = instructionsDocumentsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

enum UpdateCapabilityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePartnershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilities = capabilities {
            var capabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilities)
            for capabilityid0 in capabilities {
                try capabilitiesContainer.encode(capabilityid0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdatePartnershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePartnershipInput: Swift.Equatable {
    /// List of the capabilities associated with this partnership.
    public var capabilities: [Swift.String]?
    /// The name of the partnership, used to identify it.
    public var name: Swift.String?
    /// Specifies the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?

    public init(
        capabilities: [Swift.String]? = nil,
        name: Swift.String? = nil,
        partnershipId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.name = name
        self.partnershipId = partnershipId
    }
}

struct UpdatePartnershipInputBody: Swift.Equatable {
    let name: Swift.String?
    let capabilities: [Swift.String]?
}

extension UpdatePartnershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
    }
}

extension UpdatePartnershipOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePartnershipOutput(capabilities: \(Swift.String(describing: capabilities)), createdAt: \(Swift.String(describing: createdAt)), modifiedAt: \(Swift.String(describing: modifiedAt)), name: \(Swift.String(describing: name)), partnershipArn: \(Swift.String(describing: partnershipArn)), partnershipId: \(Swift.String(describing: partnershipId)), profileId: \(Swift.String(describing: profileId)), tradingPartnerId: \(Swift.String(describing: tradingPartnerId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

extension UpdatePartnershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePartnershipOutputBody = try responseDecoder.decode(responseBody: data)
            self.capabilities = output.capabilities
            self.createdAt = output.createdAt
            self.email = output.email
            self.modifiedAt = output.modifiedAt
            self.name = output.name
            self.partnershipArn = output.partnershipArn
            self.partnershipId = output.partnershipId
            self.phone = output.phone
            self.profileId = output.profileId
            self.tradingPartnerId = output.tradingPartnerId
        } else {
            self.capabilities = nil
            self.createdAt = nil
            self.email = nil
            self.modifiedAt = nil
            self.name = nil
            self.partnershipArn = nil
            self.partnershipId = nil
            self.phone = nil
            self.profileId = nil
            self.tradingPartnerId = nil
        }
    }
}

public struct UpdatePartnershipOutput: Swift.Equatable {
    /// Returns one or more capabilities associated with this partnership.
    public var capabilities: [Swift.String]?
    /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Returns the email address associated with this trading partner.
    public var email: Swift.String?
    /// Returns a timestamp that identifies the most recent date and time that the partnership was modified.
    public var modifiedAt: ClientRuntime.Date?
    /// The name of the partnership, used to identify it.
    public var name: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var partnershipArn: Swift.String?
    /// Returns the unique, system-generated identifier for a partnership.
    /// This member is required.
    public var partnershipId: Swift.String?
    /// Returns the phone number associated with the partnership.
    public var phone: Swift.String?
    /// Returns the unique, system-generated identifier for the profile connected to this partnership.
    /// This member is required.
    public var profileId: Swift.String?
    /// Returns the unique, system-generated identifier for a trading partner.
    public var tradingPartnerId: Swift.String?

    public init(
        capabilities: [Swift.String]? = nil,
        createdAt: ClientRuntime.Date? = nil,
        email: Swift.String? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        partnershipArn: Swift.String? = nil,
        partnershipId: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileId: Swift.String? = nil,
        tradingPartnerId: Swift.String? = nil
    )
    {
        self.capabilities = capabilities
        self.createdAt = createdAt
        self.email = email
        self.modifiedAt = modifiedAt
        self.name = name
        self.partnershipArn = partnershipArn
        self.partnershipId = partnershipId
        self.phone = phone
        self.profileId = profileId
        self.tradingPartnerId = tradingPartnerId
    }
}

struct UpdatePartnershipOutputBody: Swift.Equatable {
    let profileId: Swift.String?
    let partnershipId: Swift.String?
    let partnershipArn: Swift.String?
    let name: Swift.String?
    let email: Swift.String?
    let phone: Swift.String?
    let capabilities: [Swift.String]?
    let tradingPartnerId: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
}

extension UpdatePartnershipOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilities
        case createdAt
        case email
        case modifiedAt
        case name
        case partnershipArn
        case partnershipId
        case phone
        case profileId
        case tradingPartnerId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let partnershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnershipId)
        partnershipId = partnershipIdDecoded
        let partnershipArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partnershipArn)
        partnershipArn = partnershipArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let phoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phone)
        phone = phoneDecoded
        let capabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .capabilities)
        var capabilitiesDecoded0:[Swift.String]? = nil
        if let capabilitiesContainer = capabilitiesContainer {
            capabilitiesDecoded0 = [Swift.String]()
            for string0 in capabilitiesContainer {
                if let string0 = string0 {
                    capabilitiesDecoded0?.append(string0)
                }
            }
        }
        capabilities = capabilitiesDecoded0
        let tradingPartnerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tradingPartnerId)
        tradingPartnerId = tradingPartnerIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

enum UpdatePartnershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProfileInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProfileInput(businessName: \(Swift.String(describing: businessName)), name: \(Swift.String(describing: name)), profileId: \(Swift.String(describing: profileId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

extension UpdateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessName
        case email
        case name
        case phone
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let businessName = self.businessName {
            try encodeContainer.encode(businessName, forKey: .businessName)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phone = self.phone {
            try encodeContainer.encode(phone, forKey: .phone)
        }
    }
}

extension UpdateProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateProfileInput: Swift.Equatable {
    /// Specifies the name for the business associated with this profile.
    public var businessName: Swift.String?
    /// Specifies the email address associated with this customer profile.
    public var email: Swift.String?
    /// The name of the profile, used to identify it.
    public var name: Swift.String?
    /// Specifies the phone number associated with the profile.
    public var phone: Swift.String?
    /// Specifies the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        businessName: Swift.String? = nil,
        email: Swift.String? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.businessName = businessName
        self.email = email
        self.name = name
        self.phone = phone
        self.profileId = profileId
    }
}

struct UpdateProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let email: Swift.String?
    let phone: Swift.String?
    let businessName: Swift.String?
}

extension UpdateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessName
        case email
        case name
        case phone
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let phoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phone)
        phone = phoneDecoded
        let businessNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessName)
        businessName = businessNameDecoded
    }
}

extension UpdateProfileOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProfileOutput(businessName: \(Swift.String(describing: businessName)), createdAt: \(Swift.String(describing: createdAt)), logGroupName: \(Swift.String(describing: logGroupName)), logging: \(Swift.String(describing: logging)), modifiedAt: \(Swift.String(describing: modifiedAt)), name: \(Swift.String(describing: name)), profileArn: \(Swift.String(describing: profileArn)), profileId: \(Swift.String(describing: profileId)), email: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

extension UpdateProfileOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProfileOutputBody = try responseDecoder.decode(responseBody: data)
            self.businessName = output.businessName
            self.createdAt = output.createdAt
            self.email = output.email
            self.logGroupName = output.logGroupName
            self.logging = output.logging
            self.modifiedAt = output.modifiedAt
            self.name = output.name
            self.phone = output.phone
            self.profileArn = output.profileArn
            self.profileId = output.profileId
        } else {
            self.businessName = nil
            self.createdAt = nil
            self.email = nil
            self.logGroupName = nil
            self.logging = nil
            self.modifiedAt = nil
            self.name = nil
            self.phone = nil
            self.profileArn = nil
            self.profileId = nil
        }
    }
}

public struct UpdateProfileOutput: Swift.Equatable {
    /// Returns the name for the business associated with this profile.
    /// This member is required.
    public var businessName: Swift.String?
    /// Returns a timestamp for creation date and time of the profile.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Returns the email address associated with this customer profile.
    public var email: Swift.String?
    /// Returns the name of the logging group.
    public var logGroupName: Swift.String?
    /// Specifies whether or not logging is enabled for this profile.
    public var logging: B2biClientTypes.Logging?
    /// Returns a timestamp for last time the profile was modified.
    public var modifiedAt: ClientRuntime.Date?
    /// Returns the name of the profile.
    /// This member is required.
    public var name: Swift.String?
    /// Returns the phone number associated with the profile.
    /// This member is required.
    public var phone: Swift.String?
    /// Returns an Amazon Resource Name (ARN) for the profile.
    /// This member is required.
    public var profileArn: Swift.String?
    /// Returns the unique, system-generated identifier for the profile.
    /// This member is required.
    public var profileId: Swift.String?

    public init(
        businessName: Swift.String? = nil,
        createdAt: ClientRuntime.Date? = nil,
        email: Swift.String? = nil,
        logGroupName: Swift.String? = nil,
        logging: B2biClientTypes.Logging? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        phone: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        profileId: Swift.String? = nil
    )
    {
        self.businessName = businessName
        self.createdAt = createdAt
        self.email = email
        self.logGroupName = logGroupName
        self.logging = logging
        self.modifiedAt = modifiedAt
        self.name = name
        self.phone = phone
        self.profileArn = profileArn
        self.profileId = profileId
    }
}

struct UpdateProfileOutputBody: Swift.Equatable {
    let profileId: Swift.String?
    let profileArn: Swift.String?
    let name: Swift.String?
    let email: Swift.String?
    let phone: Swift.String?
    let businessName: Swift.String?
    let logging: B2biClientTypes.Logging?
    let logGroupName: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
}

extension UpdateProfileOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessName
        case createdAt
        case email
        case logGroupName
        case logging
        case modifiedAt
        case name
        case phone
        case profileArn
        case profileId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileId)
        profileId = profileIdDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let phoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phone)
        phone = phoneDecoded
        let businessNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .businessName)
        businessName = businessNameDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(B2biClientTypes.Logging.self, forKey: .logging)
        logging = loggingDecoded
        let logGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

enum UpdateProfileOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTransformerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ediType
        case fileFormat
        case mappingTemplate
        case name
        case sampleDocument
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ediType = self.ediType {
            try encodeContainer.encode(ediType, forKey: .ediType)
        }
        if let fileFormat = self.fileFormat {
            try encodeContainer.encode(fileFormat.rawValue, forKey: .fileFormat)
        }
        if let mappingTemplate = self.mappingTemplate {
            try encodeContainer.encode(mappingTemplate, forKey: .mappingTemplate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sampleDocument = self.sampleDocument {
            try encodeContainer.encode(sampleDocument, forKey: .sampleDocument)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateTransformerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateTransformerInput: Swift.Equatable {
    /// Specifies the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    public var ediType: B2biClientTypes.EdiType?
    /// Specifies that the currently supported file formats for EDI transformations are JSON and XML.
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Specifies the name of the mapping template for the transformer. This template is used to convert the input document into the correct set of objects.
    public var mappingTemplate: Swift.String?
    /// Specify a new name for the transformer, if you want to update it.
    public var name: Swift.String?
    /// Specifies a sample EDI document that is used by a transformer as a guide for processing the EDI data.
    public var sampleDocument: Swift.String?
    /// Specifies the transformer's status. You can update the state of the transformer, from active to inactive, or inactive to active.
    public var status: B2biClientTypes.TransformerStatus?
    /// Specifies the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = nil,
        mappingTemplate: Swift.String? = nil,
        name: Swift.String? = nil,
        sampleDocument: Swift.String? = nil,
        status: B2biClientTypes.TransformerStatus? = nil,
        transformerId: Swift.String? = nil
    )
    {
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.mappingTemplate = mappingTemplate
        self.name = name
        self.sampleDocument = sampleDocument
        self.status = status
        self.transformerId = transformerId
    }
}

struct UpdateTransformerInputBody: Swift.Equatable {
    let name: Swift.String?
    let fileFormat: B2biClientTypes.FileFormat?
    let mappingTemplate: Swift.String?
    let status: B2biClientTypes.TransformerStatus?
    let ediType: B2biClientTypes.EdiType?
    let sampleDocument: Swift.String?
}

extension UpdateTransformerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ediType
        case fileFormat
        case mappingTemplate
        case name
        case sampleDocument
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(B2biClientTypes.FileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let mappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mappingTemplate)
        mappingTemplate = mappingTemplateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(B2biClientTypes.TransformerStatus.self, forKey: .status)
        status = statusDecoded
        let ediTypeDecoded = try containerValues.decodeIfPresent(B2biClientTypes.EdiType.self, forKey: .ediType)
        ediType = ediTypeDecoded
        let sampleDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleDocument)
        sampleDocument = sampleDocumentDecoded
    }
}

extension UpdateTransformerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateTransformerOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.ediType = output.ediType
            self.fileFormat = output.fileFormat
            self.mappingTemplate = output.mappingTemplate
            self.modifiedAt = output.modifiedAt
            self.name = output.name
            self.sampleDocument = output.sampleDocument
            self.status = output.status
            self.transformerArn = output.transformerArn
            self.transformerId = output.transformerId
        } else {
            self.createdAt = nil
            self.ediType = nil
            self.fileFormat = nil
            self.mappingTemplate = nil
            self.modifiedAt = nil
            self.name = nil
            self.sampleDocument = nil
            self.status = nil
            self.transformerArn = nil
            self.transformerId = nil
        }
    }
}

public struct UpdateTransformerOutput: Swift.Equatable {
    /// Returns a timestamp for creation date and time of the transformer.
    /// This member is required.
    public var createdAt: ClientRuntime.Date?
    /// Returns the details for the EDI standard that is being used for the transformer. Currently, only X12 is supported. X12 is a set of standards and corresponding messages that define specific business documents.
    /// This member is required.
    public var ediType: B2biClientTypes.EdiType?
    /// Returns that the currently supported file formats for EDI transformations are JSON and XML.
    /// This member is required.
    public var fileFormat: B2biClientTypes.FileFormat?
    /// Returns the name of the mapping template for the transformer. This template is used to convert the input document into the correct set of objects.
    /// This member is required.
    public var mappingTemplate: Swift.String?
    /// Returns a timestamp for last time the transformer was modified.
    /// This member is required.
    public var modifiedAt: ClientRuntime.Date?
    /// Returns the name of the transformer.
    /// This member is required.
    public var name: Swift.String?
    /// Returns a sample EDI document that is used by a transformer as a guide for processing the EDI data.
    public var sampleDocument: Swift.String?
    /// Returns the state of the newly created transformer. The transformer can be either active or inactive. For the transformer to be used in a capability, its status must active.
    /// This member is required.
    public var status: B2biClientTypes.TransformerStatus?
    /// Returns an Amazon Resource Name (ARN) for a specific Amazon Web Services resource, such as a capability, partnership, profile, or transformer.
    /// This member is required.
    public var transformerArn: Swift.String?
    /// Returns the system-assigned unique identifier for the transformer.
    /// This member is required.
    public var transformerId: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        ediType: B2biClientTypes.EdiType? = nil,
        fileFormat: B2biClientTypes.FileFormat? = nil,
        mappingTemplate: Swift.String? = nil,
        modifiedAt: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        sampleDocument: Swift.String? = nil,
        status: B2biClientTypes.TransformerStatus? = nil,
        transformerArn: Swift.String? = nil,
        transformerId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.ediType = ediType
        self.fileFormat = fileFormat
        self.mappingTemplate = mappingTemplate
        self.modifiedAt = modifiedAt
        self.name = name
        self.sampleDocument = sampleDocument
        self.status = status
        self.transformerArn = transformerArn
        self.transformerId = transformerId
    }
}

struct UpdateTransformerOutputBody: Swift.Equatable {
    let transformerId: Swift.String?
    let transformerArn: Swift.String?
    let name: Swift.String?
    let fileFormat: B2biClientTypes.FileFormat?
    let mappingTemplate: Swift.String?
    let status: B2biClientTypes.TransformerStatus?
    let ediType: B2biClientTypes.EdiType?
    let sampleDocument: Swift.String?
    let createdAt: ClientRuntime.Date?
    let modifiedAt: ClientRuntime.Date?
}

extension UpdateTransformerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case ediType
        case fileFormat
        case mappingTemplate
        case modifiedAt
        case name
        case sampleDocument
        case status
        case transformerArn
        case transformerId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformerId)
        transformerId = transformerIdDecoded
        let transformerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transformerArn)
        transformerArn = transformerArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fileFormatDecoded = try containerValues.decodeIfPresent(B2biClientTypes.FileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
        let mappingTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mappingTemplate)
        mappingTemplate = mappingTemplateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(B2biClientTypes.TransformerStatus.self, forKey: .status)
        status = statusDecoded
        let ediTypeDecoded = try containerValues.decodeIfPresent(B2biClientTypes.EdiType.self, forKey: .ediType)
        ediType = ediTypeDecoded
        let sampleDocumentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleDocument)
        sampleDocument = sampleDocumentDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
    }
}

enum UpdateTransformerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Occurs when a B2BI object cannot be validated against a request from another object.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension B2biClientTypes.X12Details: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionSet
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transactionSet = self.transactionSet {
            try encodeContainer.encode(transactionSet.rawValue, forKey: .transactionSet)
        }
        if let version = self.version {
            try encodeContainer.encode(version.rawValue, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionSetDecoded = try containerValues.decodeIfPresent(B2biClientTypes.X12TransactionSet.self, forKey: .transactionSet)
        transactionSet = transactionSetDecoded
        let versionDecoded = try containerValues.decodeIfPresent(B2biClientTypes.X12Version.self, forKey: .version)
        version = versionDecoded
    }
}

extension B2biClientTypes {
    /// A structure that contains the X12 transaction set and version. The X12 structure is used when the system transforms an EDI (electronic data interchange) file. If an EDI input file contains more than one transaction, each transaction must have the same transaction set and version, for example 214/4010. If not, the transformer cannot parse the file.
    public struct X12Details: Swift.Equatable {
        /// Returns an enumerated type where each value identifies an X12 transaction set. Transaction sets are maintained by the X12 Accredited Standards Committee.
        public var transactionSet: B2biClientTypes.X12TransactionSet?
        /// Returns the version to use for the specified X12 transaction set. Supported versions are 4010, 4030, and 5010.
        public var version: B2biClientTypes.X12Version?

        public init(
            transactionSet: B2biClientTypes.X12TransactionSet? = nil,
            version: B2biClientTypes.X12Version? = nil
        )
        {
            self.transactionSet = transactionSet
            self.version = version
        }
    }

}

extension B2biClientTypes {
    public enum X12TransactionSet: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case x12110
        case x12180
        case x12204
        case x12210
        case x12214
        case x12215
        case x12310
        case x12315
        case x12322
        case x12404
        case x12410
        case x12820
        case x12824
        case x12830
        case x12846
        case x12850
        case x12852
        case x12855
        case x12856
        case x12860
        case x12861
        case x12864
        case x12940
        case x12990
        case x12997
        case sdkUnknown(Swift.String)

        public static var allCases: [X12TransactionSet] {
            return [
                .x12110,
                .x12180,
                .x12204,
                .x12210,
                .x12214,
                .x12215,
                .x12310,
                .x12315,
                .x12322,
                .x12404,
                .x12410,
                .x12820,
                .x12824,
                .x12830,
                .x12846,
                .x12850,
                .x12852,
                .x12855,
                .x12856,
                .x12860,
                .x12861,
                .x12864,
                .x12940,
                .x12990,
                .x12997,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .x12110: return "X12_110"
            case .x12180: return "X12_180"
            case .x12204: return "X12_204"
            case .x12210: return "X12_210"
            case .x12214: return "X12_214"
            case .x12215: return "X12_215"
            case .x12310: return "X12_310"
            case .x12315: return "X12_315"
            case .x12322: return "X12_322"
            case .x12404: return "X12_404"
            case .x12410: return "X12_410"
            case .x12820: return "X12_820"
            case .x12824: return "X12_824"
            case .x12830: return "X12_830"
            case .x12846: return "X12_846"
            case .x12850: return "X12_850"
            case .x12852: return "X12_852"
            case .x12855: return "X12_855"
            case .x12856: return "X12_856"
            case .x12860: return "X12_860"
            case .x12861: return "X12_861"
            case .x12864: return "X12_864"
            case .x12940: return "X12_940"
            case .x12990: return "X12_990"
            case .x12997: return "X12_997"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = X12TransactionSet(rawValue: rawValue) ?? X12TransactionSet.sdkUnknown(rawValue)
        }
    }
}

extension B2biClientTypes {
    public enum X12Version: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case version4010
        case version4030
        case version5010
        case sdkUnknown(Swift.String)

        public static var allCases: [X12Version] {
            return [
                .version4010,
                .version4030,
                .version5010,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .version4010: return "VERSION_4010"
            case .version4030: return "VERSION_4030"
            case .version5010: return "VERSION_5010"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = X12Version(rawValue: rawValue) ?? X12Version.sdkUnknown(rawValue)
        }
    }
}
