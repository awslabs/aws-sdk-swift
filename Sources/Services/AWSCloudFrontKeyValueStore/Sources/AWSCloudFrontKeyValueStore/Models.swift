//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// Access denied.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Resource is not in expected state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Internal server error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Limit exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Validation failed.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteKeyInput: Swift.Sendable {
    /// The current version (ETag) of the Key Value Store that you are deleting keys from, which you can get using DescribeKeyValueStore.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The key to delete.
    /// This member is required.
    public var key: Swift.String?
    /// The Amazon Resource Name (ARN) of the Key Value Store.
    /// This member is required.
    public var kvsARN: Swift.String?

    public init(
        ifMatch: Swift.String? = nil,
        key: Swift.String? = nil,
        kvsARN: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.key = key
        self.kvsARN = kvsARN
    }
}

/// Metadata information about a Key Value Store.
public struct DeleteKeyOutput: Swift.Sendable {
    /// The current version identifier of the Key Value Store after the successful delete.
    /// This member is required.
    public var eTag: Swift.String?
    /// Number of key value pairs in the Key Value Store after the successful delete.
    /// This member is required.
    public var itemCount: Swift.Int?
    /// Total size of the Key Value Store after the successful delete, in bytes.
    /// This member is required.
    public var totalSizeInBytes: Swift.Int?

    public init(
        eTag: Swift.String? = nil,
        itemCount: Swift.Int? = nil,
        totalSizeInBytes: Swift.Int? = nil
    )
    {
        self.eTag = eTag
        self.itemCount = itemCount
        self.totalSizeInBytes = totalSizeInBytes
    }
}

public struct DescribeKeyValueStoreInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Key Value Store.
    /// This member is required.
    public var kvsARN: Swift.String?

    public init(
        kvsARN: Swift.String? = nil
    )
    {
        self.kvsARN = kvsARN
    }
}

/// Metadata information about a Key Value Store.
public struct DescribeKeyValueStoreOutput: Swift.Sendable {
    /// Date and time when the Key Value Store was created.
    /// This member is required.
    public var created: Foundation.Date?
    /// The version identifier for the current version of the Key Value Store.
    /// This member is required.
    public var eTag: Swift.String?
    /// The reason for Key Value Store creation failure.
    public var failureReason: Swift.String?
    /// Number of key value pairs in the Key Value Store.
    /// This member is required.
    public var itemCount: Swift.Int?
    /// The Amazon Resource Name (ARN) of the Key Value Store.
    /// This member is required.
    public var kvsARN: Swift.String?
    /// Date and time when the key value pairs in the Key Value Store was last modified.
    public var lastModified: Foundation.Date?
    /// The current status of the Key Value Store.
    public var status: Swift.String?
    /// Total size of the Key Value Store in bytes.
    /// This member is required.
    public var totalSizeInBytes: Swift.Int?

    public init(
        created: Foundation.Date? = nil,
        eTag: Swift.String? = nil,
        failureReason: Swift.String? = nil,
        itemCount: Swift.Int? = nil,
        kvsARN: Swift.String? = nil,
        lastModified: Foundation.Date? = nil,
        status: Swift.String? = nil,
        totalSizeInBytes: Swift.Int? = nil
    )
    {
        self.created = created
        self.eTag = eTag
        self.failureReason = failureReason
        self.itemCount = itemCount
        self.kvsARN = kvsARN
        self.lastModified = lastModified
        self.status = status
        self.totalSizeInBytes = totalSizeInBytes
    }
}

public struct GetKeyInput: Swift.Sendable {
    /// The key to get.
    /// This member is required.
    public var key: Swift.String?
    /// The Amazon Resource Name (ARN) of the Key Value Store.
    /// This member is required.
    public var kvsARN: Swift.String?

    public init(
        key: Swift.String? = nil,
        kvsARN: Swift.String? = nil
    )
    {
        self.key = key
        self.kvsARN = kvsARN
    }
}

/// A key value pair.
public struct GetKeyOutput: Swift.Sendable {
    /// Number of key value pairs in the Key Value Store.
    /// This member is required.
    public var itemCount: Swift.Int?
    /// The key of the key value pair.
    /// This member is required.
    public var key: Swift.String?
    /// Total size of the Key Value Store in bytes.
    /// This member is required.
    public var totalSizeInBytes: Swift.Int?
    /// The value of the key value pair.
    /// This member is required.
    public var value: Swift.String?

    public init(
        itemCount: Swift.Int? = nil,
        key: Swift.String? = nil,
        totalSizeInBytes: Swift.Int? = nil,
        value: Swift.String? = nil
    )
    {
        self.itemCount = itemCount
        self.key = key
        self.totalSizeInBytes = totalSizeInBytes
        self.value = value
    }
}

extension GetKeyOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetKeyOutput(itemCount: \(Swift.String(describing: itemCount)), key: \(Swift.String(describing: key)), totalSizeInBytes: \(Swift.String(describing: totalSizeInBytes)), value: \"CONTENT_REDACTED\")"}
}

public struct ListKeysInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Key Value Store.
    /// This member is required.
    public var kvsARN: Swift.String?
    /// Maximum number of results that are returned per call. The default is 10 and maximum allowed page is 50.
    public var maxResults: Swift.Int?
    /// If nextToken is returned in the response, there are more results available. Make the next call using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        kvsARN: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.kvsARN = kvsARN
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CloudFrontKeyValueStoreClientTypes {

    /// A key value pair.
    public struct ListKeysResponseListItem: Swift.Sendable {
        /// The key of the key value pair.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the key value pair.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension CloudFrontKeyValueStoreClientTypes.ListKeysResponseListItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListKeysResponseListItem(key: \(Swift.String(describing: key)), value: \"CONTENT_REDACTED\")"}
}

public struct ListKeysOutput: Swift.Sendable {
    /// Key value pairs
    public var items: [CloudFrontKeyValueStoreClientTypes.ListKeysResponseListItem]?
    /// If nextToken is returned in the response, there are more results available. Make the next call using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        items: [CloudFrontKeyValueStoreClientTypes.ListKeysResponseListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

/// A key value pair.
public struct PutKeyInput: Swift.Sendable {
    /// The current version (ETag) of the Key Value Store that you are putting keys into, which you can get using DescribeKeyValueStore.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The key to put.
    /// This member is required.
    public var key: Swift.String?
    /// The Amazon Resource Name (ARN) of the Key Value Store.
    /// This member is required.
    public var kvsARN: Swift.String?
    /// The value to put.
    /// This member is required.
    public var value: Swift.String?

    public init(
        ifMatch: Swift.String? = nil,
        key: Swift.String? = nil,
        kvsARN: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.key = key
        self.kvsARN = kvsARN
        self.value = value
    }
}

extension PutKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutKeyInput(ifMatch: \(Swift.String(describing: ifMatch)), key: \(Swift.String(describing: key)), kvsARN: \(Swift.String(describing: kvsARN)), value: \"CONTENT_REDACTED\")"}
}

/// Metadata information about a Key Value Store.
public struct PutKeyOutput: Swift.Sendable {
    /// The current version identifier of the Key Value Store after the successful put.
    /// This member is required.
    public var eTag: Swift.String?
    /// Number of key value pairs in the Key Value Store after the successful put.
    /// This member is required.
    public var itemCount: Swift.Int?
    /// Total size of the Key Value Store after the successful put, in bytes.
    /// This member is required.
    public var totalSizeInBytes: Swift.Int?

    public init(
        eTag: Swift.String? = nil,
        itemCount: Swift.Int? = nil,
        totalSizeInBytes: Swift.Int? = nil
    )
    {
        self.eTag = eTag
        self.itemCount = itemCount
        self.totalSizeInBytes = totalSizeInBytes
    }
}

extension CloudFrontKeyValueStoreClientTypes {

    /// List item for keys to delete.
    public struct DeleteKeyRequestListItem: Swift.Sendable {
        /// The key of the key value pair to be deleted.
        /// This member is required.
        public var key: Swift.String?

        public init(
            key: Swift.String? = nil
        )
        {
            self.key = key
        }
    }
}

extension CloudFrontKeyValueStoreClientTypes {

    /// List item for key value pair to put.
    public struct PutKeyRequestListItem: Swift.Sendable {
        /// The key of the key value pair list item to put.
        /// This member is required.
        public var key: Swift.String?
        /// The value for the key value pair to put.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

extension CloudFrontKeyValueStoreClientTypes.PutKeyRequestListItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutKeyRequestListItem(key: \(Swift.String(describing: key)), value: \"CONTENT_REDACTED\")"}
}

public struct UpdateKeysInput: Swift.Sendable {
    /// List of keys to delete.
    public var deletes: [CloudFrontKeyValueStoreClientTypes.DeleteKeyRequestListItem]?
    /// The current version (ETag) of the Key Value Store that you are updating keys of, which you can get using DescribeKeyValueStore.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The Amazon Resource Name (ARN) of the Key Value Store.
    /// This member is required.
    public var kvsARN: Swift.String?
    /// List of key value pairs to put.
    public var puts: [CloudFrontKeyValueStoreClientTypes.PutKeyRequestListItem]?

    public init(
        deletes: [CloudFrontKeyValueStoreClientTypes.DeleteKeyRequestListItem]? = nil,
        ifMatch: Swift.String? = nil,
        kvsARN: Swift.String? = nil,
        puts: [CloudFrontKeyValueStoreClientTypes.PutKeyRequestListItem]? = nil
    )
    {
        self.deletes = deletes
        self.ifMatch = ifMatch
        self.kvsARN = kvsARN
        self.puts = puts
    }
}

/// Metadata information about a Key Value Store.
public struct UpdateKeysOutput: Swift.Sendable {
    /// The current version identifier of the Key Value Store after the successful update.
    /// This member is required.
    public var eTag: Swift.String?
    /// Number of key value pairs in the Key Value Store after the successful update.
    /// This member is required.
    public var itemCount: Swift.Int?
    /// Total size of the Key Value Store after the successful update, in bytes.
    /// This member is required.
    public var totalSizeInBytes: Swift.Int?

    public init(
        eTag: Swift.String? = nil,
        itemCount: Swift.Int? = nil,
        totalSizeInBytes: Swift.Int? = nil
    )
    {
        self.eTag = eTag
        self.itemCount = itemCount
        self.totalSizeInBytes = totalSizeInBytes
    }
}

extension DeleteKeyInput {

    static func urlPathProvider(_ value: DeleteKeyInput) -> Swift.String? {
        guard let kvsARN = value.kvsARN else {
            return nil
        }
        guard let key = value.key else {
            return nil
        }
        return "/key-value-stores/\(kvsARN.urlPercentEncoding())/keys/\(key.urlPercentEncoding())"
    }
}

extension DeleteKeyInput {

    static func headerProvider(_ value: DeleteKeyInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DescribeKeyValueStoreInput {

    static func urlPathProvider(_ value: DescribeKeyValueStoreInput) -> Swift.String? {
        guard let kvsARN = value.kvsARN else {
            return nil
        }
        return "/key-value-stores/\(kvsARN.urlPercentEncoding())"
    }
}

extension GetKeyInput {

    static func urlPathProvider(_ value: GetKeyInput) -> Swift.String? {
        guard let kvsARN = value.kvsARN else {
            return nil
        }
        guard let key = value.key else {
            return nil
        }
        return "/key-value-stores/\(kvsARN.urlPercentEncoding())/keys/\(key.urlPercentEncoding())"
    }
}

extension ListKeysInput {

    static func urlPathProvider(_ value: ListKeysInput) -> Swift.String? {
        guard let kvsARN = value.kvsARN else {
            return nil
        }
        return "/key-value-stores/\(kvsARN.urlPercentEncoding())/keys"
    }
}

extension ListKeysInput {

    static func queryItemProvider(_ value: ListKeysInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension PutKeyInput {

    static func urlPathProvider(_ value: PutKeyInput) -> Swift.String? {
        guard let kvsARN = value.kvsARN else {
            return nil
        }
        guard let key = value.key else {
            return nil
        }
        return "/key-value-stores/\(kvsARN.urlPercentEncoding())/keys/\(key.urlPercentEncoding())"
    }
}

extension PutKeyInput {

    static func headerProvider(_ value: PutKeyInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateKeysInput {

    static func urlPathProvider(_ value: UpdateKeysInput) -> Swift.String? {
        guard let kvsARN = value.kvsARN else {
            return nil
        }
        return "/key-value-stores/\(kvsARN.urlPercentEncoding())/keys"
    }
}

extension UpdateKeysInput {

    static func headerProvider(_ value: UpdateKeysInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension PutKeyInput {

    static func write(value: PutKeyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Value"].write(value.value)
    }
}

extension UpdateKeysInput {

    static func write(value: UpdateKeysInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Deletes"].writeList(value.deletes, memberWritingClosure: CloudFrontKeyValueStoreClientTypes.DeleteKeyRequestListItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Puts"].writeList(value.puts, memberWritingClosure: CloudFrontKeyValueStoreClientTypes.PutKeyRequestListItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteKeyOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.itemCount = try reader["ItemCount"].readIfPresent() ?? 0
        value.totalSizeInBytes = try reader["TotalSizeInBytes"].readIfPresent() ?? 0
        return value
    }
}

extension DescribeKeyValueStoreOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeKeyValueStoreOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeKeyValueStoreOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.created = try reader["Created"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.itemCount = try reader["ItemCount"].readIfPresent() ?? 0
        value.kvsARN = try reader["KvsARN"].readIfPresent() ?? ""
        value.lastModified = try reader["LastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        value.totalSizeInBytes = try reader["TotalSizeInBytes"].readIfPresent() ?? 0
        return value
    }
}

extension GetKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetKeyOutput()
        value.itemCount = try reader["ItemCount"].readIfPresent() ?? 0
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.totalSizeInBytes = try reader["TotalSizeInBytes"].readIfPresent() ?? 0
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension ListKeysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListKeysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListKeysOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: CloudFrontKeyValueStoreClientTypes.ListKeysResponseListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension PutKeyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutKeyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutKeyOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.itemCount = try reader["ItemCount"].readIfPresent() ?? 0
        value.totalSizeInBytes = try reader["TotalSizeInBytes"].readIfPresent() ?? 0
        return value
    }
}

extension UpdateKeysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateKeysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateKeysOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.itemCount = try reader["ItemCount"].readIfPresent() ?? 0
        value.totalSizeInBytes = try reader["TotalSizeInBytes"].readIfPresent() ?? 0
        return value
    }
}

enum DeleteKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeKeyValueStoreOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListKeysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutKeyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateKeysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CloudFrontKeyValueStoreClientTypes.ListKeysResponseListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> CloudFrontKeyValueStoreClientTypes.ListKeysResponseListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CloudFrontKeyValueStoreClientTypes.ListKeysResponseListItem()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension CloudFrontKeyValueStoreClientTypes.PutKeyRequestListItem {

    static func write(value: CloudFrontKeyValueStoreClientTypes.PutKeyRequestListItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }
}

extension CloudFrontKeyValueStoreClientTypes.DeleteKeyRequestListItem {

    static func write(value: CloudFrontKeyValueStoreClientTypes.DeleteKeyRequestListItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
    }
}

public enum CloudFrontKeyValueStoreClientTypes {}
