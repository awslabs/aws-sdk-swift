// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Access denied.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Resource is not in expected state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DeleteKeyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension DeleteKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let kvsARN = kvsARN else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/key-value-stores/\(kvsARN.urlPercentEncoding())/keys/\(key.urlPercentEncoding())"
    }
}

public struct DeleteKeyInput: Swift.Equatable {
    /// The current version (ETag) of the Key Value Store that you are deleting keys from, which you can get using DescribeKeyValueStore.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The key to delete.
    /// This member is required.
    public var key: Swift.String?
    /// The Amazon Resource Name (ARN) of the Key Value Store.
    /// This member is required.
    public var kvsARN: Swift.String?

    public init(
        ifMatch: Swift.String? = nil,
        key: Swift.String? = nil,
        kvsARN: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.key = key
        self.kvsARN = kvsARN
    }
}

struct DeleteKeyInputBody: Swift.Equatable {
}

extension DeleteKeyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.itemCount = output.itemCount
            self.totalSizeInBytes = output.totalSizeInBytes
        } else {
            self.itemCount = nil
            self.totalSizeInBytes = nil
        }
    }
}

/// Metadata information about a Key Value Store.
public struct DeleteKeyOutput: Swift.Equatable {
    /// The current version identifier of the Key Value Store after the successful delete.
    /// This member is required.
    public var eTag: Swift.String?
    /// Number of key value pairs in the Key Value Store after the successful delete.
    /// This member is required.
    public var itemCount: Swift.Int?
    /// Total size of the Key Value Store after the successful delete, in bytes.
    /// This member is required.
    public var totalSizeInBytes: Swift.Int?

    public init(
        eTag: Swift.String? = nil,
        itemCount: Swift.Int? = nil,
        totalSizeInBytes: Swift.Int? = nil
    )
    {
        self.eTag = eTag
        self.itemCount = itemCount
        self.totalSizeInBytes = totalSizeInBytes
    }
}

struct DeleteKeyOutputBody: Swift.Equatable {
    let itemCount: Swift.Int?
    let totalSizeInBytes: Swift.Int?
}

extension DeleteKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemCount = "ItemCount"
        case totalSizeInBytes = "TotalSizeInBytes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
        let totalSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSizeInBytes)
        totalSizeInBytes = totalSizeInBytesDecoded
    }
}

enum DeleteKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudFrontKeyValueStoreClientTypes.DeleteKeyRequestListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension CloudFrontKeyValueStoreClientTypes {
    /// List item for keys to delete.
    public struct DeleteKeyRequestListItem: Swift.Equatable {
        /// The key of the key value pair to be deleted.
        /// This member is required.
        public var key: Swift.String?

        public init(
            key: Swift.String? = nil
        )
        {
            self.key = key
        }
    }

}

extension DescribeKeyValueStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let kvsARN = kvsARN else {
            return nil
        }
        return "/key-value-stores/\(kvsARN.urlPercentEncoding())"
    }
}

public struct DescribeKeyValueStoreInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Key Value Store.
    /// This member is required.
    public var kvsARN: Swift.String?

    public init(
        kvsARN: Swift.String? = nil
    )
    {
        self.kvsARN = kvsARN
    }
}

struct DescribeKeyValueStoreInputBody: Swift.Equatable {
}

extension DescribeKeyValueStoreInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeKeyValueStoreOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeKeyValueStoreOutputBody = try responseDecoder.decode(responseBody: data)
            self.created = output.created
            self.itemCount = output.itemCount
            self.kvsARN = output.kvsARN
            self.lastModified = output.lastModified
            self.totalSizeInBytes = output.totalSizeInBytes
        } else {
            self.created = nil
            self.itemCount = nil
            self.kvsARN = nil
            self.lastModified = nil
            self.totalSizeInBytes = nil
        }
    }
}

/// Metadata information about a Key Value Store.
public struct DescribeKeyValueStoreOutput: Swift.Equatable {
    /// Date and time when the Key Value Store was created.
    /// This member is required.
    public var created: ClientRuntime.Date?
    /// The version identifier for the current version of the Key Value Store.
    /// This member is required.
    public var eTag: Swift.String?
    /// Number of key value pairs in the Key Value Store.
    /// This member is required.
    public var itemCount: Swift.Int?
    /// The Amazon Resource Name (ARN) of the Key Value Store.
    /// This member is required.
    public var kvsARN: Swift.String?
    /// Date and time when the key value pairs in the Key Value Store was last modified.
    public var lastModified: ClientRuntime.Date?
    /// Total size of the Key Value Store in bytes.
    /// This member is required.
    public var totalSizeInBytes: Swift.Int?

    public init(
        created: ClientRuntime.Date? = nil,
        eTag: Swift.String? = nil,
        itemCount: Swift.Int? = nil,
        kvsARN: Swift.String? = nil,
        lastModified: ClientRuntime.Date? = nil,
        totalSizeInBytes: Swift.Int? = nil
    )
    {
        self.created = created
        self.eTag = eTag
        self.itemCount = itemCount
        self.kvsARN = kvsARN
        self.lastModified = lastModified
        self.totalSizeInBytes = totalSizeInBytes
    }
}

struct DescribeKeyValueStoreOutputBody: Swift.Equatable {
    let itemCount: Swift.Int?
    let totalSizeInBytes: Swift.Int?
    let kvsARN: Swift.String?
    let created: ClientRuntime.Date?
    let lastModified: ClientRuntime.Date?
}

extension DescribeKeyValueStoreOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created = "Created"
        case itemCount = "ItemCount"
        case kvsARN = "KvsARN"
        case lastModified = "LastModified"
        case totalSizeInBytes = "TotalSizeInBytes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
        let totalSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSizeInBytes)
        totalSizeInBytes = totalSizeInBytesDecoded
        let kvsARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kvsARN)
        kvsARN = kvsARNDecoded
        let createdDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .created)
        created = createdDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

enum DescribeKeyValueStoreOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let kvsARN = kvsARN else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/key-value-stores/\(kvsARN.urlPercentEncoding())/keys/\(key.urlPercentEncoding())"
    }
}

public struct GetKeyInput: Swift.Equatable {
    /// The key to get.
    /// This member is required.
    public var key: Swift.String?
    /// The Amazon Resource Name (ARN) of the Key Value Store.
    /// This member is required.
    public var kvsARN: Swift.String?

    public init(
        key: Swift.String? = nil,
        kvsARN: Swift.String? = nil
    )
    {
        self.key = key
        self.kvsARN = kvsARN
    }
}

struct GetKeyInputBody: Swift.Equatable {
}

extension GetKeyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetKeyOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetKeyOutput(itemCount: \(Swift.String(describing: itemCount)), key: \(Swift.String(describing: key)), totalSizeInBytes: \(Swift.String(describing: totalSizeInBytes)), value: \"CONTENT_REDACTED\")"}
}

extension GetKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.itemCount = output.itemCount
            self.key = output.key
            self.totalSizeInBytes = output.totalSizeInBytes
            self.value = output.value
        } else {
            self.itemCount = nil
            self.key = nil
            self.totalSizeInBytes = nil
            self.value = nil
        }
    }
}

/// A key value pair.
public struct GetKeyOutput: Swift.Equatable {
    /// Number of key value pairs in the Key Value Store.
    /// This member is required.
    public var itemCount: Swift.Int?
    /// The key of the key value pair.
    /// This member is required.
    public var key: Swift.String?
    /// Total size of the Key Value Store in bytes.
    /// This member is required.
    public var totalSizeInBytes: Swift.Int?
    /// The value of the key value pair.
    /// This member is required.
    public var value: Swift.String?

    public init(
        itemCount: Swift.Int? = nil,
        key: Swift.String? = nil,
        totalSizeInBytes: Swift.Int? = nil,
        value: Swift.String? = nil
    )
    {
        self.itemCount = itemCount
        self.key = key
        self.totalSizeInBytes = totalSizeInBytes
        self.value = value
    }
}

struct GetKeyOutputBody: Swift.Equatable {
    let key: Swift.String?
    let value: Swift.String?
    let itemCount: Swift.Int?
    let totalSizeInBytes: Swift.Int?
}

extension GetKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemCount = "ItemCount"
        case key = "Key"
        case totalSizeInBytes = "TotalSizeInBytes"
        case value = "Value"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
        let totalSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSizeInBytes)
        totalSizeInBytes = totalSizeInBytesDecoded
    }
}

enum GetKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Internal server error.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListKeysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let kvsARN = kvsARN else {
            return nil
        }
        return "/key-value-stores/\(kvsARN.urlPercentEncoding())/keys"
    }
}

public struct ListKeysInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Key Value Store.
    /// This member is required.
    public var kvsARN: Swift.String?
    /// Maximum number of results that are returned per call. The default is 10 and maximum allowed page is 50.
    public var maxResults: Swift.Int?
    /// If nextToken is returned in the response, there are more results available. Make the next call using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        kvsARN: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.kvsARN = kvsARN
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListKeysInputBody: Swift.Equatable {
}

extension ListKeysInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListKeysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListKeysOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListKeysOutput: Swift.Equatable {
    /// Key value pairs
    public var items: [CloudFrontKeyValueStoreClientTypes.ListKeysResponseListItem]?
    /// If nextToken is returned in the response, there are more results available. Make the next call using the returned token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        items: [CloudFrontKeyValueStoreClientTypes.ListKeysResponseListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListKeysOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let items: [CloudFrontKeyValueStoreClientTypes.ListKeysResponseListItem]?
}

extension ListKeysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let itemsContainer = try containerValues.decodeIfPresent([CloudFrontKeyValueStoreClientTypes.ListKeysResponseListItem?].self, forKey: .items)
        var itemsDecoded0:[CloudFrontKeyValueStoreClientTypes.ListKeysResponseListItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CloudFrontKeyValueStoreClientTypes.ListKeysResponseListItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum ListKeysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudFrontKeyValueStoreClientTypes.ListKeysResponseListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudFrontKeyValueStoreClientTypes.ListKeysResponseListItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListKeysResponseListItem(key: \(Swift.String(describing: key)), value: \"CONTENT_REDACTED\")"}
}

extension CloudFrontKeyValueStoreClientTypes {
    /// A key value pair.
    public struct ListKeysResponseListItem: Swift.Equatable {
        /// The key of the key value pair.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the key value pair.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension PutKeyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutKeyInput(ifMatch: \(Swift.String(describing: ifMatch)), key: \(Swift.String(describing: key)), kvsARN: \(Swift.String(describing: kvsARN)), value: \"CONTENT_REDACTED\")"}
}

extension PutKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }
}

extension PutKeyInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension PutKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let kvsARN = kvsARN else {
            return nil
        }
        guard let key = key else {
            return nil
        }
        return "/key-value-stores/\(kvsARN.urlPercentEncoding())/keys/\(key.urlPercentEncoding())"
    }
}

/// A key value pair.
public struct PutKeyInput: Swift.Equatable {
    /// The current version (ETag) of the Key Value Store that you are putting keys into, which you can get using DescribeKeyValueStore.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The key to put.
    /// This member is required.
    public var key: Swift.String?
    /// The Amazon Resource Name (ARN) of the Key Value Store.
    /// This member is required.
    public var kvsARN: Swift.String?
    /// The value to put.
    /// This member is required.
    public var value: Swift.String?

    public init(
        ifMatch: Swift.String? = nil,
        key: Swift.String? = nil,
        kvsARN: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.ifMatch = ifMatch
        self.key = key
        self.kvsARN = kvsARN
        self.value = value
    }
}

struct PutKeyInputBody: Swift.Equatable {
    let value: Swift.String?
}

extension PutKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case value = "Value"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension PutKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.itemCount = output.itemCount
            self.totalSizeInBytes = output.totalSizeInBytes
        } else {
            self.itemCount = nil
            self.totalSizeInBytes = nil
        }
    }
}

/// Metadata information about a Key Value Store.
public struct PutKeyOutput: Swift.Equatable {
    /// The current version identifier of the Key Value Store after the successful put.
    /// This member is required.
    public var eTag: Swift.String?
    /// Number of key value pairs in the Key Value Store after the successful put.
    /// This member is required.
    public var itemCount: Swift.Int?
    /// Total size of the Key Value Store after the successful put, in bytes.
    /// This member is required.
    public var totalSizeInBytes: Swift.Int?

    public init(
        eTag: Swift.String? = nil,
        itemCount: Swift.Int? = nil,
        totalSizeInBytes: Swift.Int? = nil
    )
    {
        self.eTag = eTag
        self.itemCount = itemCount
        self.totalSizeInBytes = totalSizeInBytes
    }
}

struct PutKeyOutputBody: Swift.Equatable {
    let itemCount: Swift.Int?
    let totalSizeInBytes: Swift.Int?
}

extension PutKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemCount = "ItemCount"
        case totalSizeInBytes = "TotalSizeInBytes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
        let totalSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSizeInBytes)
        totalSizeInBytes = totalSizeInBytesDecoded
    }
}

enum PutKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CloudFrontKeyValueStoreClientTypes.PutKeyRequestListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CloudFrontKeyValueStoreClientTypes.PutKeyRequestListItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutKeyRequestListItem(key: \(Swift.String(describing: key)), value: \"CONTENT_REDACTED\")"}
}

extension CloudFrontKeyValueStoreClientTypes {
    /// List item for key value pair to put.
    public struct PutKeyRequestListItem: Swift.Equatable {
        /// The key of the key value pair list item to put.
        /// This member is required.
        public var key: Swift.String?
        /// The value for the key value pair to put.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Limit exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateKeysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletes = "Deletes"
        case puts = "Puts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletes = deletes {
            var deletesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deletes)
            for deletekeyrequestlistitem0 in deletes {
                try deletesContainer.encode(deletekeyrequestlistitem0)
            }
        }
        if let puts = puts {
            var putsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .puts)
            for putkeyrequestlistitem0 in puts {
                try putsContainer.encode(putkeyrequestlistitem0)
            }
        }
    }
}

extension UpdateKeysInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let ifMatch = ifMatch {
            items.add(Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        return items
    }
}

extension UpdateKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let kvsARN = kvsARN else {
            return nil
        }
        return "/key-value-stores/\(kvsARN.urlPercentEncoding())/keys"
    }
}

public struct UpdateKeysInput: Swift.Equatable {
    /// List of keys to delete.
    public var deletes: [CloudFrontKeyValueStoreClientTypes.DeleteKeyRequestListItem]?
    /// The current version (ETag) of the Key Value Store that you are updating keys of, which you can get using DescribeKeyValueStore.
    /// This member is required.
    public var ifMatch: Swift.String?
    /// The Amazon Resource Name (ARN) of the Key Value Store.
    /// This member is required.
    public var kvsARN: Swift.String?
    /// List of key value pairs to put.
    public var puts: [CloudFrontKeyValueStoreClientTypes.PutKeyRequestListItem]?

    public init(
        deletes: [CloudFrontKeyValueStoreClientTypes.DeleteKeyRequestListItem]? = nil,
        ifMatch: Swift.String? = nil,
        kvsARN: Swift.String? = nil,
        puts: [CloudFrontKeyValueStoreClientTypes.PutKeyRequestListItem]? = nil
    )
    {
        self.deletes = deletes
        self.ifMatch = ifMatch
        self.kvsARN = kvsARN
        self.puts = puts
    }
}

struct UpdateKeysInputBody: Swift.Equatable {
    let puts: [CloudFrontKeyValueStoreClientTypes.PutKeyRequestListItem]?
    let deletes: [CloudFrontKeyValueStoreClientTypes.DeleteKeyRequestListItem]?
}

extension UpdateKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletes = "Deletes"
        case puts = "Puts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let putsContainer = try containerValues.decodeIfPresent([CloudFrontKeyValueStoreClientTypes.PutKeyRequestListItem?].self, forKey: .puts)
        var putsDecoded0:[CloudFrontKeyValueStoreClientTypes.PutKeyRequestListItem]? = nil
        if let putsContainer = putsContainer {
            putsDecoded0 = [CloudFrontKeyValueStoreClientTypes.PutKeyRequestListItem]()
            for structure0 in putsContainer {
                if let structure0 = structure0 {
                    putsDecoded0?.append(structure0)
                }
            }
        }
        puts = putsDecoded0
        let deletesContainer = try containerValues.decodeIfPresent([CloudFrontKeyValueStoreClientTypes.DeleteKeyRequestListItem?].self, forKey: .deletes)
        var deletesDecoded0:[CloudFrontKeyValueStoreClientTypes.DeleteKeyRequestListItem]? = nil
        if let deletesContainer = deletesContainer {
            deletesDecoded0 = [CloudFrontKeyValueStoreClientTypes.DeleteKeyRequestListItem]()
            for structure0 in deletesContainer {
                if let structure0 = structure0 {
                    deletesDecoded0?.append(structure0)
                }
            }
        }
        deletes = deletesDecoded0
    }
}

extension UpdateKeysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            self.eTag = eTagHeaderValue
        } else {
            self.eTag = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateKeysOutputBody = try responseDecoder.decode(responseBody: data)
            self.itemCount = output.itemCount
            self.totalSizeInBytes = output.totalSizeInBytes
        } else {
            self.itemCount = nil
            self.totalSizeInBytes = nil
        }
    }
}

/// Metadata information about a Key Value Store.
public struct UpdateKeysOutput: Swift.Equatable {
    /// The current version identifier of the Key Value Store after the successful update.
    /// This member is required.
    public var eTag: Swift.String?
    /// Number of key value pairs in the Key Value Store after the successful update.
    /// This member is required.
    public var itemCount: Swift.Int?
    /// Total size of the Key Value Store after the successful update, in bytes.
    /// This member is required.
    public var totalSizeInBytes: Swift.Int?

    public init(
        eTag: Swift.String? = nil,
        itemCount: Swift.Int? = nil,
        totalSizeInBytes: Swift.Int? = nil
    )
    {
        self.eTag = eTag
        self.itemCount = itemCount
        self.totalSizeInBytes = totalSizeInBytes
    }
}

struct UpdateKeysOutputBody: Swift.Equatable {
    let itemCount: Swift.Int?
    let totalSizeInBytes: Swift.Int?
}

extension UpdateKeysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemCount = "ItemCount"
        case totalSizeInBytes = "TotalSizeInBytes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
        let totalSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSizeInBytes)
        totalSizeInBytes = totalSizeInBytesDecoded
    }
}

enum UpdateKeysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Validation failed.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
