//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// Thrown when the caller does not have sufficient permissions to perform the requested operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A message describing the access denial.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension PartnerCentralBenefitsClientTypes {

    /// Contains information about access-based benefit fulfillment, such as service permissions or feature access.
    public struct AccessDetails: Swift.Sendable {
        /// A description of the access privileges or permissions granted by this benefit.
        public var description: Swift.String?

        public init(
            description: Swift.String? = nil
        ) {
            self.description = description
        }
    }
}

/// Thrown when the request conflicts with the current state of the resource, such as attempting to modify a resource that has been changed by another process.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A message describing the conflict.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Thrown when an unexpected error occurs on the server side during request processing.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A message describing the internal server error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Thrown when the requested resource cannot be found or does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A message describing the resource not found error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Thrown when the request rate exceeds the allowed limits and the request is being throttled.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A message describing the throttling error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension PartnerCentralBenefitsClientTypes {

    public enum ValidationExceptionErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionNotPermitted
        case duplicateKeyValue
        case invalidEnumValue
        case invalidResourceState
        case invalidStringFormat
        case invalidValue
        case notEnoughValues
        case requiredFieldMissing
        case tooManyValues
        case valueOutOfRange
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionErrorCode] {
            return [
                .actionNotPermitted,
                .duplicateKeyValue,
                .invalidEnumValue,
                .invalidResourceState,
                .invalidStringFormat,
                .invalidValue,
                .notEnoughValues,
                .requiredFieldMissing,
                .tooManyValues,
                .valueOutOfRange
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionNotPermitted: return "ACTION_NOT_PERMITTED"
            case .duplicateKeyValue: return "DUPLICATE_KEY_VALUE"
            case .invalidEnumValue: return "INVALID_ENUM_VALUE"
            case .invalidResourceState: return "INVALID_RESOURCE_STATE"
            case .invalidStringFormat: return "INVALID_STRING_FORMAT"
            case .invalidValue: return "INVALID_VALUE"
            case .notEnoughValues: return "NOT_ENOUGH_VALUES"
            case .requiredFieldMissing: return "REQUIRED_FIELD_MISSING"
            case .tooManyValues: return "TOO_MANY_VALUES"
            case .valueOutOfRange: return "VALUE_OUT_OF_RANGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    /// Represents a field-specific validation error with detailed information.
    public struct ValidationExceptionField: Swift.Sendable {
        /// An error code explaining why the field validation failed.
        public var code: PartnerCentralBenefitsClientTypes.ValidationExceptionErrorCode?
        /// A detailed message explaining why the field validation failed.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            code: PartnerCentralBenefitsClientTypes.ValidationExceptionErrorCode? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.code = code
            self.message = message
            self.name = name
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case businessValidationFailed
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .businessValidationFailed,
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .businessValidationFailed: return "BUSINESS_VALIDATION_FAILED"
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Thrown when the request contains invalid parameters or fails input validation requirements.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A list of fields that failed validation.
        public internal(set) var fieldList: [PartnerCentralBenefitsClientTypes.ValidationExceptionField]? = nil
        /// A message describing the validation error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the validation failure.
        /// This member is required.
        public internal(set) var reason: PartnerCentralBenefitsClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [PartnerCentralBenefitsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: PartnerCentralBenefitsClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension PartnerCentralBenefitsClientTypes {

    /// Represents a specific change to be made to a benefit application field.
    public struct Amendment: Swift.Sendable {
        /// The JSON path or field identifier specifying which field in the benefit application to modify.
        /// This member is required.
        public var fieldPath: Swift.String?
        /// The new value to set for the specified field in the benefit application.
        /// This member is required.
        public var newValue: Swift.String?

        public init(
            fieldPath: Swift.String? = nil,
            newValue: Swift.String? = nil
        ) {
            self.fieldPath = fieldPath
            self.newValue = newValue
        }
    }
}

public struct AmendBenefitApplicationInput: Swift.Sendable {
    /// A descriptive reason explaining why the benefit application is being amended.
    /// This member is required.
    public var amendmentReason: Swift.String?
    /// A list of specific field amendments to apply to the benefit application.
    /// This member is required.
    public var amendments: [PartnerCentralBenefitsClientTypes.Amendment]?
    /// The catalog identifier that specifies which benefit catalog the application belongs to.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotent processing of the amendment request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The unique identifier of the benefit application to be amended.
    /// This member is required.
    public var identifier: Swift.String?
    /// The current revision number of the benefit application to ensure optimistic concurrency control.
    /// This member is required.
    public var revision: Swift.String?

    public init(
        amendmentReason: Swift.String? = nil,
        amendments: [PartnerCentralBenefitsClientTypes.Amendment]? = nil,
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        revision: Swift.String? = nil
    ) {
        self.amendmentReason = amendmentReason
        self.amendments = amendments
        self.catalog = catalog
        self.clientToken = clientToken
        self.identifier = identifier
        self.revision = revision
    }
}

public struct AmendBenefitApplicationOutput: Swift.Sendable {

    public init() { }
}

public struct AssociateBenefitApplicationResourceInput: Swift.Sendable {
    /// The unique identifier of the benefit application to associate the resource with.
    /// This member is required.
    public var benefitApplicationIdentifier: Swift.String?
    /// The catalog identifier that specifies which benefit catalog the application belongs to.
    /// This member is required.
    public var catalog: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS resource to associate with the benefit application.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        benefitApplicationIdentifier: Swift.String? = nil,
        catalog: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    ) {
        self.benefitApplicationIdentifier = benefitApplicationIdentifier
        self.catalog = catalog
        self.resourceArn = resourceArn
    }
}

public struct AssociateBenefitApplicationResourceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the benefit application after the resource association.
    public var arn: Swift.String?
    /// The unique identifier of the benefit application after the resource association.
    public var id: Swift.String?
    /// The updated revision number of the benefit application after the resource association.
    public var revision: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        revision: Swift.String? = nil
    ) {
        self.arn = arn
        self.id = id
        self.revision = revision
    }
}

extension PartnerCentralBenefitsClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case benefitAllocation
        case opportunity
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .benefitAllocation,
                .opportunity
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .benefitAllocation: return "BENEFIT_ALLOCATION"
            case .opportunity: return "OPPORTUNITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    /// Represents an AWS resource that is associated with a benefit application for tracking and management.
    public struct AssociatedResource: Swift.Sendable {
        /// The Amazon Resource Name (ARN) that uniquely identifies the AWS resource.
        public var resourceArn: Swift.String?
        /// The unique identifier of the AWS resource within its service.
        @available(*, deprecated, message: "This field is no longer used API deprecated since Oct 08 2025")
        public var resourceIdentifier: Swift.String?
        /// The type of AWS resource (e.g., EC2 instance, S3 bucket, Lambda function).
        public var resourceType: PartnerCentralBenefitsClientTypes.ResourceType?

        public init(
            resourceArn: Swift.String? = nil,
            resourceIdentifier: Swift.String? = nil,
            resourceType: PartnerCentralBenefitsClientTypes.ResourceType? = nil
        ) {
            self.resourceArn = resourceArn
            self.resourceIdentifier = resourceIdentifier
            self.resourceType = resourceType
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    public enum BenefitAllocationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case fulfilled
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [BenefitAllocationStatus] {
            return [
                .active,
                .fulfilled,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .fulfilled: return "FULFILLED"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    public enum FulfillmentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case access
        case cash
        case credits
        case sdkUnknown(Swift.String)

        public static var allCases: [FulfillmentType] {
            return [
                .access,
                .cash,
                .credits
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .access: return "ACCESS"
            case .cash: return "CASH"
            case .credits: return "CREDITS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    /// A summary view of a benefit allocation containing key information for list operations.
    public struct BenefitAllocationSummary: Swift.Sendable {
        /// The identifiers of the benefits applicable for this allocation.
        public var applicableBenefitIds: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the benefit allocation.
        public var arn: Swift.String?
        /// The identifier of the benefit application that resulted in this allocation.
        public var benefitApplicationId: Swift.String?
        /// The identifier of the benefit that this allocation is based on.
        public var benefitId: Swift.String?
        /// The catalog identifier that the benefit allocation belongs to.
        public var catalog: Swift.String?
        /// The timestamp when the benefit allocation was created.
        public var createdAt: Foundation.Date?
        /// The timestamp when the benefit allocation expires.
        public var expiresAt: Foundation.Date?
        /// The fulfillment types used for this benefit allocation.
        public var fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]?
        /// The unique identifier of the benefit allocation.
        public var id: Swift.String?
        /// The human-readable name of the benefit allocation.
        public var name: Swift.String?
        /// The current status of the benefit allocation.
        public var status: PartnerCentralBenefitsClientTypes.BenefitAllocationStatus?
        /// Additional information explaining the current status of the benefit allocation.
        public var statusReason: Swift.String?

        public init(
            applicableBenefitIds: [Swift.String]? = nil,
            arn: Swift.String? = nil,
            benefitApplicationId: Swift.String? = nil,
            benefitId: Swift.String? = nil,
            catalog: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            expiresAt: Foundation.Date? = nil,
            fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: PartnerCentralBenefitsClientTypes.BenefitAllocationStatus? = nil,
            statusReason: Swift.String? = nil
        ) {
            self.applicableBenefitIds = applicableBenefitIds
            self.arn = arn
            self.benefitApplicationId = benefitApplicationId
            self.benefitId = benefitId
            self.catalog = catalog
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.fulfillmentTypes = fulfillmentTypes
            self.id = id
            self.name = name
            self.status = status
            self.statusReason = statusReason
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    public enum BenefitApplicationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionRequired
        case approved
        case canceled
        case inReview
        case pendingSubmission
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [BenefitApplicationStatus] {
            return [
                .actionRequired,
                .approved,
                .canceled,
                .inReview,
                .pendingSubmission,
                .rejected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionRequired: return "ACTION_REQUIRED"
            case .approved: return "APPROVED"
            case .canceled: return "CANCELED"
            case .inReview: return "IN_REVIEW"
            case .pendingSubmission: return "PENDING_SUBMISSION"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    /// A summary view of a benefit application containing key information for list operations.
    public struct BenefitApplicationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the benefit application.
        public var arn: Swift.String?
        /// AWS resources that are associated with this benefit application.
        public var associatedResources: [Swift.String]?
        /// Additional attributes and metadata associated with the benefit application.
        public var benefitApplicationDetails: [Swift.String: Swift.String]?
        /// The identifier of the benefit being requested in this application.
        public var benefitId: Swift.String?
        /// The catalog identifier that the benefit application belongs to.
        public var catalog: Swift.String?
        /// The timestamp when the benefit application was created.
        public var createdAt: Foundation.Date?
        /// The fulfillment types requested for this benefit application.
        public var fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]?
        /// The unique identifier of the benefit application.
        public var id: Swift.String?
        /// The human-readable name of the benefit application.
        public var name: Swift.String?
        /// The AWS partner programs associated with this benefit application.
        public var programs: [Swift.String]?
        /// The current stage in the benefit application processing workflow..
        public var stage: Swift.String?
        /// The current processing status of the benefit application.
        public var status: PartnerCentralBenefitsClientTypes.BenefitApplicationStatus?
        /// The timestamp when the benefit application was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            associatedResources: [Swift.String]? = nil,
            benefitApplicationDetails: [Swift.String: Swift.String]? = nil,
            benefitId: Swift.String? = nil,
            catalog: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            programs: [Swift.String]? = nil,
            stage: Swift.String? = nil,
            status: PartnerCentralBenefitsClientTypes.BenefitApplicationStatus? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.associatedResources = associatedResources
            self.benefitApplicationDetails = benefitApplicationDetails
            self.benefitId = benefitId
            self.catalog = catalog
            self.createdAt = createdAt
            self.fulfillmentTypes = fulfillmentTypes
            self.id = id
            self.name = name
            self.programs = programs
            self.stage = stage
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    public enum BenefitStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [BenefitStatus] {
            return [
                .active,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    /// A summary view of a benefit containing key information for list operations.
    public struct BenefitSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the benefit.
        public var arn: Swift.String?
        /// The catalog identifier that the benefit belongs to.
        public var catalog: Swift.String?
        /// A brief description of the benefit and its purpose.
        public var description: Swift.String?
        /// The available fulfillment types for this benefit.
        public var fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]?
        /// The unique identifier of the benefit.
        public var id: Swift.String?
        /// The human-readable name of the benefit.
        public var name: Swift.String?
        /// The AWS partner programs that this benefit is associated with.
        public var programs: [Swift.String]?
        /// The current status of the benefit.
        public var status: PartnerCentralBenefitsClientTypes.BenefitStatus?

        public init(
            arn: Swift.String? = nil,
            catalog: Swift.String? = nil,
            description: Swift.String? = nil,
            fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            programs: [Swift.String]? = nil,
            status: PartnerCentralBenefitsClientTypes.BenefitStatus? = nil
        ) {
            self.arn = arn
            self.catalog = catalog
            self.description = description
            self.fulfillmentTypes = fulfillmentTypes
            self.id = id
            self.name = name
            self.programs = programs
            self.status = status
        }
    }
}

public struct CancelBenefitApplicationInput: Swift.Sendable {
    /// The catalog identifier that specifies which benefit catalog the application belongs to.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotent processing of the cancellation request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The unique identifier of the benefit application to cancel.
    /// This member is required.
    public var identifier: Swift.String?
    /// A descriptive reason explaining why the benefit application is being cancelled.
    public var reason: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        reason: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.identifier = identifier
        self.reason = reason
    }
}

public struct CancelBenefitApplicationOutput: Swift.Sendable {

    public init() { }
}

extension PartnerCentralBenefitsClientTypes {

    public enum CurrencyCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aed
        case amd
        case ars
        case aud
        case awg
        case azn
        case bbd
        case bdt
        case bgn
        case bmd
        case bnd
        case bob
        case brl
        case bsd
        case byr
        case bzd
        case cad
        case chf
        case clp
        case cny
        case cop
        case crc
        case czk
        case dkk
        case dop
        case eek
        case egp
        case eur
        case gbp
        case gel
        case ghs
        case gtq
        case gyd
        case hkd
        case hnl
        case hrk
        case htg
        case huf
        case idr
        case ils
        case inr
        case isk
        case jmd
        case jpy
        case kes
        case khr
        case krw
        case kyd
        case kzt
        case lbp
        case lkr
        case ltl
        case lvl
        case mad
        case mnt
        case mop
        case mur
        case mvr
        case mxn
        case myr
        case nad
        case ngn
        case nio
        case nok
        case nzd
        case pab
        case pen
        case php
        case pkr
        case pln
        case pyg
        case qar
        case ron
        case rub
        case sar
        case sek
        case sgd
        case sit
        case skk
        case thb
        case tnd
        case `try`
        case ttd
        case twd
        case tzs
        case uah
        case usd
        case uyu
        case uzs
        case vnd
        case xaf
        case xcd
        case xof
        case xpf
        case zar
        case sdkUnknown(Swift.String)

        public static var allCases: [CurrencyCode] {
            return [
                .aed,
                .amd,
                .ars,
                .aud,
                .awg,
                .azn,
                .bbd,
                .bdt,
                .bgn,
                .bmd,
                .bnd,
                .bob,
                .brl,
                .bsd,
                .byr,
                .bzd,
                .cad,
                .chf,
                .clp,
                .cny,
                .cop,
                .crc,
                .czk,
                .dkk,
                .dop,
                .eek,
                .egp,
                .eur,
                .gbp,
                .gel,
                .ghs,
                .gtq,
                .gyd,
                .hkd,
                .hnl,
                .hrk,
                .htg,
                .huf,
                .idr,
                .ils,
                .inr,
                .isk,
                .jmd,
                .jpy,
                .kes,
                .khr,
                .krw,
                .kyd,
                .kzt,
                .lbp,
                .lkr,
                .ltl,
                .lvl,
                .mad,
                .mnt,
                .mop,
                .mur,
                .mvr,
                .mxn,
                .myr,
                .nad,
                .ngn,
                .nio,
                .nok,
                .nzd,
                .pab,
                .pen,
                .php,
                .pkr,
                .pln,
                .pyg,
                .qar,
                .ron,
                .rub,
                .sar,
                .sek,
                .sgd,
                .sit,
                .skk,
                .thb,
                .tnd,
                .try,
                .ttd,
                .twd,
                .tzs,
                .uah,
                .usd,
                .uyu,
                .uzs,
                .vnd,
                .xaf,
                .xcd,
                .xof,
                .xpf,
                .zar
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aed: return "AED"
            case .amd: return "AMD"
            case .ars: return "ARS"
            case .aud: return "AUD"
            case .awg: return "AWG"
            case .azn: return "AZN"
            case .bbd: return "BBD"
            case .bdt: return "BDT"
            case .bgn: return "BGN"
            case .bmd: return "BMD"
            case .bnd: return "BND"
            case .bob: return "BOB"
            case .brl: return "BRL"
            case .bsd: return "BSD"
            case .byr: return "BYR"
            case .bzd: return "BZD"
            case .cad: return "CAD"
            case .chf: return "CHF"
            case .clp: return "CLP"
            case .cny: return "CNY"
            case .cop: return "COP"
            case .crc: return "CRC"
            case .czk: return "CZK"
            case .dkk: return "DKK"
            case .dop: return "DOP"
            case .eek: return "EEK"
            case .egp: return "EGP"
            case .eur: return "EUR"
            case .gbp: return "GBP"
            case .gel: return "GEL"
            case .ghs: return "GHS"
            case .gtq: return "GTQ"
            case .gyd: return "GYD"
            case .hkd: return "HKD"
            case .hnl: return "HNL"
            case .hrk: return "HRK"
            case .htg: return "HTG"
            case .huf: return "HUF"
            case .idr: return "IDR"
            case .ils: return "ILS"
            case .inr: return "INR"
            case .isk: return "ISK"
            case .jmd: return "JMD"
            case .jpy: return "JPY"
            case .kes: return "KES"
            case .khr: return "KHR"
            case .krw: return "KRW"
            case .kyd: return "KYD"
            case .kzt: return "KZT"
            case .lbp: return "LBP"
            case .lkr: return "LKR"
            case .ltl: return "LTL"
            case .lvl: return "LVL"
            case .mad: return "MAD"
            case .mnt: return "MNT"
            case .mop: return "MOP"
            case .mur: return "MUR"
            case .mvr: return "MVR"
            case .mxn: return "MXN"
            case .myr: return "MYR"
            case .nad: return "NAD"
            case .ngn: return "NGN"
            case .nio: return "NIO"
            case .nok: return "NOK"
            case .nzd: return "NZD"
            case .pab: return "PAB"
            case .pen: return "PEN"
            case .php: return "PHP"
            case .pkr: return "PKR"
            case .pln: return "PLN"
            case .pyg: return "PYG"
            case .qar: return "QAR"
            case .ron: return "RON"
            case .rub: return "RUB"
            case .sar: return "SAR"
            case .sek: return "SEK"
            case .sgd: return "SGD"
            case .sit: return "SIT"
            case .skk: return "SKK"
            case .thb: return "THB"
            case .tnd: return "TND"
            case .try: return "TRY"
            case .ttd: return "TTD"
            case .twd: return "TWD"
            case .tzs: return "TZS"
            case .uah: return "UAH"
            case .usd: return "USD"
            case .uyu: return "UYU"
            case .uzs: return "UZS"
            case .vnd: return "VND"
            case .xaf: return "XAF"
            case .xcd: return "XCD"
            case .xof: return "XOF"
            case .xpf: return "XPF"
            case .zar: return "ZAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    /// Represents a monetary amount with its associated currency.
    public struct MonetaryValue: Swift.Sendable {
        /// The numeric amount of the monetary value.
        /// This member is required.
        public var amount: Swift.String?
        /// The ISO 4217 currency code (e.g., USD, EUR) for the monetary amount.
        /// This member is required.
        public var currencyCode: PartnerCentralBenefitsClientTypes.CurrencyCode?

        public init(
            amount: Swift.String? = nil,
            currencyCode: PartnerCentralBenefitsClientTypes.CurrencyCode? = nil
        ) {
            self.amount = amount
            self.currencyCode = currencyCode
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    /// Represents detailed information about a specific issuance of benefit value.
    public struct IssuanceDetail: Swift.Sendable {
        /// The monetary amount or value that was issued in this specific issuance.
        public var issuanceAmount: PartnerCentralBenefitsClientTypes.MonetaryValue?
        /// The unique identifier for this specific issuance.
        public var issuanceId: Swift.String?
        /// The timestamp when this specific issuance was processed.
        public var issuedAt: Foundation.Date?

        public init(
            issuanceAmount: PartnerCentralBenefitsClientTypes.MonetaryValue? = nil,
            issuanceId: Swift.String? = nil,
            issuedAt: Foundation.Date? = nil
        ) {
            self.issuanceAmount = issuanceAmount
            self.issuanceId = issuanceId
            self.issuedAt = issuedAt
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    /// Contains information about consumable benefit fulfillment, such as usage quotas or service limits.
    public struct ConsumableDetails: Swift.Sendable {
        /// The total amount of the consumable benefit that has been allocated.
        public var allocatedAmount: PartnerCentralBenefitsClientTypes.MonetaryValue?
        /// Detailed information about how the consumable benefit was issued and distributed.
        public var issuanceDetails: PartnerCentralBenefitsClientTypes.IssuanceDetail?
        /// The remaining amount of the consumable benefit that is still available for use.
        public var remainingAmount: PartnerCentralBenefitsClientTypes.MonetaryValue?
        /// The amount of the consumable benefit that has already been used.
        public var utilizedAmount: PartnerCentralBenefitsClientTypes.MonetaryValue?

        public init(
            allocatedAmount: PartnerCentralBenefitsClientTypes.MonetaryValue? = nil,
            issuanceDetails: PartnerCentralBenefitsClientTypes.IssuanceDetail? = nil,
            remainingAmount: PartnerCentralBenefitsClientTypes.MonetaryValue? = nil,
            utilizedAmount: PartnerCentralBenefitsClientTypes.MonetaryValue? = nil
        ) {
            self.allocatedAmount = allocatedAmount
            self.issuanceDetails = issuanceDetails
            self.remainingAmount = remainingAmount
            self.utilizedAmount = utilizedAmount
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    /// Represents contact information for a partner representative.
    public struct Contact: Swift.Sendable {
        /// The business title or role of the contact person within the organization.
        public var businessTitle: Swift.String?
        /// The email address of the contact person.
        public var email: Swift.String?
        /// The first name of the contact person.
        public var firstName: Swift.String?
        /// The last name of the contact person.
        public var lastName: Swift.String?
        /// The phone number of the contact person.
        public var phone: Swift.String?

        public init(
            businessTitle: Swift.String? = nil,
            email: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            phone: Swift.String? = nil
        ) {
            self.businessTitle = businessTitle
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
            self.phone = phone
        }
    }
}

extension PartnerCentralBenefitsClientTypes.Contact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Contact(businessTitle: \(Swift.String(describing: businessTitle)), email: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralBenefitsClientTypes {

    /// Represents input information for uploading a file to a benefit application.
    public struct FileInput: Swift.Sendable {
        /// The business purpose or use case that this file supports in the benefit application.
        public var businessUseCase: Swift.String?
        /// The URI or location where the file should be stored or has been uploaded.
        /// This member is required.
        public var fileURI: Swift.String?

        public init(
            businessUseCase: Swift.String? = nil,
            fileURI: Swift.String? = nil
        ) {
            self.businessUseCase = businessUseCase
            self.fileURI = fileURI
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    /// Represents a key-value pair used for categorizing and organizing AWS resources.
    public struct Tag: Swift.Sendable {
        /// The tag key, which acts as a category or label for the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The tag value, which provides additional information or context for the tag key.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateBenefitApplicationInput: Swift.Sendable {
    /// AWS resources that are associated with this benefit application.
    public var associatedResources: [Swift.String]?
    /// Detailed information and requirements specific to the benefit being requested.
    public var benefitApplicationDetails: Smithy.Document?
    /// The unique identifier of the benefit being requested in this application.
    /// This member is required.
    public var benefitIdentifier: Swift.String?
    /// The catalog identifier that specifies which benefit catalog to create the application in.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotent processing of the creation request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// A detailed description of the benefit application and its intended use.
    public var description: Swift.String?
    /// Supporting documents and files attached to the benefit application.
    public var fileDetails: [PartnerCentralBenefitsClientTypes.FileInput]?
    /// The types of fulfillment requested for this benefit application (e.g., credits, access, disbursement).
    public var fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]?
    /// A human-readable name for the benefit application.
    public var name: Swift.String?
    /// Contact information for partner representatives responsible for this benefit application.
    public var partnerContacts: [PartnerCentralBenefitsClientTypes.Contact]?
    /// Key-value pairs to categorize and organize the benefit application.
    public var tags: [PartnerCentralBenefitsClientTypes.Tag]?

    public init(
        associatedResources: [Swift.String]? = nil,
        benefitApplicationDetails: Smithy.Document? = nil,
        benefitIdentifier: Swift.String? = nil,
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        fileDetails: [PartnerCentralBenefitsClientTypes.FileInput]? = nil,
        fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]? = nil,
        name: Swift.String? = nil,
        partnerContacts: [PartnerCentralBenefitsClientTypes.Contact]? = nil,
        tags: [PartnerCentralBenefitsClientTypes.Tag]? = nil
    ) {
        self.associatedResources = associatedResources
        self.benefitApplicationDetails = benefitApplicationDetails
        self.benefitIdentifier = benefitIdentifier
        self.catalog = catalog
        self.clientToken = clientToken
        self.description = description
        self.fileDetails = fileDetails
        self.fulfillmentTypes = fulfillmentTypes
        self.name = name
        self.partnerContacts = partnerContacts
        self.tags = tags
    }
}

public struct CreateBenefitApplicationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the newly created benefit application.
    public var arn: Swift.String?
    /// The unique identifier assigned to the newly created benefit application.
    public var id: Swift.String?
    /// The initial revision number of the newly created benefit application.
    public var revision: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        revision: Swift.String? = nil
    ) {
        self.arn = arn
        self.id = id
        self.revision = revision
    }
}

extension PartnerCentralBenefitsClientTypes {

    /// Represents an AWS credit code that can be applied to an AWS account for billing purposes.
    public struct CreditCode: Swift.Sendable {
        /// The AWS account ID that the credit code is associated with or can be applied to.
        /// This member is required.
        public var awsAccountId: Swift.String?
        /// The actual credit code string that can be redeemed in the AWS billing console.
        /// This member is required.
        public var awsCreditCode: Swift.String?
        /// The timestamp when the credit code expires and can no longer be redeemed.
        /// This member is required.
        public var expiresAt: Foundation.Date?
        /// The timestamp when the credit code was issued.
        /// This member is required.
        public var issuedAt: Foundation.Date?
        /// The current status of the credit code (e.g., active, redeemed, expired).
        /// This member is required.
        public var status: PartnerCentralBenefitsClientTypes.BenefitAllocationStatus?
        /// The monetary value of the credit code.
        /// This member is required.
        public var value: PartnerCentralBenefitsClientTypes.MonetaryValue?

        public init(
            awsAccountId: Swift.String? = nil,
            awsCreditCode: Swift.String? = nil,
            expiresAt: Foundation.Date? = nil,
            issuedAt: Foundation.Date? = nil,
            status: PartnerCentralBenefitsClientTypes.BenefitAllocationStatus? = nil,
            value: PartnerCentralBenefitsClientTypes.MonetaryValue? = nil
        ) {
            self.awsAccountId = awsAccountId
            self.awsCreditCode = awsCreditCode
            self.expiresAt = expiresAt
            self.issuedAt = issuedAt
            self.status = status
            self.value = value
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    /// Contains information about credit-based benefit fulfillment, including AWS promotional credits.
    public struct CreditDetails: Swift.Sendable {
        /// The total amount of credits that have been allocated for this benefit.
        /// This member is required.
        public var allocatedAmount: PartnerCentralBenefitsClientTypes.MonetaryValue?
        /// A list of credit codes that have been generated for this benefit allocation.
        /// This member is required.
        public var codes: [PartnerCentralBenefitsClientTypes.CreditCode]?
        /// The amount of credits that have actually been issued and are available for use.
        /// This member is required.
        public var issuedAmount: PartnerCentralBenefitsClientTypes.MonetaryValue?

        public init(
            allocatedAmount: PartnerCentralBenefitsClientTypes.MonetaryValue? = nil,
            codes: [PartnerCentralBenefitsClientTypes.CreditCode]? = nil,
            issuedAmount: PartnerCentralBenefitsClientTypes.MonetaryValue? = nil
        ) {
            self.allocatedAmount = allocatedAmount
            self.codes = codes
            self.issuedAmount = issuedAmount
        }
    }
}

public struct DisassociateBenefitApplicationResourceInput: Swift.Sendable {
    /// The unique identifier of the benefit application to disassociate the resource from.
    /// This member is required.
    public var benefitApplicationIdentifier: Swift.String?
    /// The catalog identifier that specifies which benefit catalog the application belongs to.
    /// This member is required.
    public var catalog: Swift.String?
    /// The Amazon Resource Name (ARN) of the AWS resource to disassociate from the benefit application.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        benefitApplicationIdentifier: Swift.String? = nil,
        catalog: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    ) {
        self.benefitApplicationIdentifier = benefitApplicationIdentifier
        self.catalog = catalog
        self.resourceArn = resourceArn
    }
}

public struct DisassociateBenefitApplicationResourceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the benefit application after the resource disassociation.
    public var arn: Swift.String?
    /// The unique identifier of the benefit application after the resource disassociation.
    public var id: Swift.String?
    /// The updated revision number of the benefit application after the resource disassociation.
    public var revision: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        revision: Swift.String? = nil
    ) {
        self.arn = arn
        self.id = id
        self.revision = revision
    }
}

extension PartnerCentralBenefitsClientTypes {

    /// Contains information about disbursement-based benefit fulfillment, such as direct payments or reimbursements.
    public struct DisbursementDetails: Swift.Sendable {
        /// The total amount that has been disbursed for this benefit allocation.
        public var disbursedAmount: PartnerCentralBenefitsClientTypes.MonetaryValue?
        /// Detailed information about how the disbursement was issued and processed.
        public var issuanceDetails: PartnerCentralBenefitsClientTypes.IssuanceDetail?

        public init(
            disbursedAmount: PartnerCentralBenefitsClientTypes.MonetaryValue? = nil,
            issuanceDetails: PartnerCentralBenefitsClientTypes.IssuanceDetail? = nil
        ) {
            self.disbursedAmount = disbursedAmount
            self.issuanceDetails = issuanceDetails
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    public enum FileType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case doc
        case docx
        case jpg
        case pdf
        case png
        case pptx
        case svg
        case xlsx
        case sdkUnknown(Swift.String)

        public static var allCases: [FileType] {
            return [
                .csv,
                .doc,
                .docx,
                .jpg,
                .pdf,
                .png,
                .pptx,
                .svg,
                .xlsx
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "text/csv"
            case .doc: return "application/msword"
            case .docx: return "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
            case .jpg: return "image/jpeg"
            case .pdf: return "application/pdf"
            case .png: return "image/png"
            case .pptx: return "application/vnd.openxmlformats-officedocument.presentationml.presentation"
            case .svg: return "image/svg+xml"
            case .xlsx: return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    /// Represents detailed information about a file attached to a benefit application.
    public struct FileDetail: Swift.Sendable {
        /// The business purpose or use case that this file supports in the benefit application.
        public var businessUseCase: Swift.String?
        /// The timestamp when the file was uploaded.
        public var createdAt: Foundation.Date?
        /// The identifier of the user who uploaded the file.
        public var createdBy: Swift.String?
        /// The original name of the uploaded file.
        public var fileName: Swift.String?
        /// The current processing status of the file (e.g., uploaded, processing, approved, rejected).
        public var fileStatus: Swift.String?
        /// The reason for that particulat file status.
        public var fileStatusReason: Swift.String?
        /// The type or category of the file (e.g., document, image, spreadsheet).
        public var fileType: PartnerCentralBenefitsClientTypes.FileType?
        /// The URI or location where the file is stored.
        /// This member is required.
        public var fileURI: Swift.String?

        public init(
            businessUseCase: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            fileName: Swift.String? = nil,
            fileStatus: Swift.String? = nil,
            fileStatusReason: Swift.String? = nil,
            fileType: PartnerCentralBenefitsClientTypes.FileType? = nil,
            fileURI: Swift.String? = nil
        ) {
            self.businessUseCase = businessUseCase
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.fileName = fileName
            self.fileStatus = fileStatus
            self.fileStatusReason = fileStatusReason
            self.fileType = fileType
            self.fileURI = fileURI
        }
    }
}

extension PartnerCentralBenefitsClientTypes {

    /// Contains comprehensive information about how a benefit allocation is fulfilled across different fulfillment types.
    public enum FulfillmentDetails: Swift.Sendable {
        /// Details about disbursement-based fulfillment, if applicable to this benefit allocation.
        case disbursementdetails(PartnerCentralBenefitsClientTypes.DisbursementDetails)
        /// Details about consumable-based fulfillment, if applicable to this benefit allocation.
        case consumabledetails(PartnerCentralBenefitsClientTypes.ConsumableDetails)
        /// Details about credit-based fulfillment, if applicable to this benefit allocation.
        case creditdetails(PartnerCentralBenefitsClientTypes.CreditDetails)
        /// Details about access-based fulfillment, if applicable to this benefit allocation.
        case accessdetails(PartnerCentralBenefitsClientTypes.AccessDetails)
        case sdkUnknown(Swift.String)
    }
}

public struct GetBenefitInput: Swift.Sendable {
    /// The catalog identifier that specifies which benefit catalog to query.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the benefit to retrieve.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
    }
}

public struct GetBenefitOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the benefit.
    public var arn: Swift.String?
    /// The schema definition that describes the required fields for requesting this benefit.
    public var benefitRequestSchema: Smithy.Document?
    /// The catalog identifier that the benefit belongs to.
    public var catalog: Swift.String?
    /// A detailed description of the benefit and its purpose.
    public var description: Swift.String?
    /// The available fulfillment types for this benefit (e.g., credits, access, disbursement).
    public var fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]?
    /// The unique identifier of the benefit.
    public var id: Swift.String?
    /// The human-readable name of the benefit.
    public var name: Swift.String?
    /// The AWS partner programs that this benefit is associated with.
    public var programs: [Swift.String]?
    /// The current status of the benefit (e.g., active, inactive, deprecated).
    public var status: PartnerCentralBenefitsClientTypes.BenefitStatus?

    public init(
        arn: Swift.String? = nil,
        benefitRequestSchema: Smithy.Document? = nil,
        catalog: Swift.String? = nil,
        description: Swift.String? = nil,
        fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        programs: [Swift.String]? = nil,
        status: PartnerCentralBenefitsClientTypes.BenefitStatus? = nil
    ) {
        self.arn = arn
        self.benefitRequestSchema = benefitRequestSchema
        self.catalog = catalog
        self.description = description
        self.fulfillmentTypes = fulfillmentTypes
        self.id = id
        self.name = name
        self.programs = programs
        self.status = status
    }
}

public struct GetBenefitAllocationInput: Swift.Sendable {
    /// The catalog identifier that specifies which benefit catalog to query.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the benefit allocation to retrieve.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
    }
}

public struct GetBenefitAllocationOutput: Swift.Sendable {
    /// A list of benefit identifiers that this allocation can be applied to.
    public var applicableBenefitIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the benefit allocation.
    public var arn: Swift.String?
    /// The identifier of the benefit application that resulted in this allocation.
    public var benefitApplicationId: Swift.String?
    /// The identifier of the benefit that this allocation is based on.
    public var benefitId: Swift.String?
    /// The catalog identifier that the benefit allocation belongs to.
    public var catalog: Swift.String?
    /// The timestamp when the benefit allocation was created.
    public var createdAt: Foundation.Date?
    /// A detailed description of the benefit allocation.
    public var description: Swift.String?
    /// The timestamp when the benefit allocation expires and is no longer usable.
    public var expiresAt: Foundation.Date?
    /// Detailed information about how the benefit allocation is fulfilled.
    public var fulfillmentDetail: PartnerCentralBenefitsClientTypes.FulfillmentDetails?
    /// The fulfillment type used for this benefit allocation.
    public var fulfillmentType: PartnerCentralBenefitsClientTypes.FulfillmentType?
    /// The unique identifier of the benefit allocation.
    public var id: Swift.String?
    /// The human-readable name of the benefit allocation.
    public var name: Swift.String?
    /// The timestamp when the benefit allocation becomes active and usable.
    public var startsAt: Foundation.Date?
    /// The current status of the benefit allocation (e.g., active, expired, consumed).
    public var status: PartnerCentralBenefitsClientTypes.BenefitAllocationStatus?
    /// Additional information explaining the current status of the benefit allocation.
    public var statusReason: Swift.String?
    /// The timestamp when the benefit allocation was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        applicableBenefitIds: [Swift.String]? = nil,
        arn: Swift.String? = nil,
        benefitApplicationId: Swift.String? = nil,
        benefitId: Swift.String? = nil,
        catalog: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        expiresAt: Foundation.Date? = nil,
        fulfillmentDetail: PartnerCentralBenefitsClientTypes.FulfillmentDetails? = nil,
        fulfillmentType: PartnerCentralBenefitsClientTypes.FulfillmentType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        startsAt: Foundation.Date? = nil,
        status: PartnerCentralBenefitsClientTypes.BenefitAllocationStatus? = nil,
        statusReason: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.applicableBenefitIds = applicableBenefitIds
        self.arn = arn
        self.benefitApplicationId = benefitApplicationId
        self.benefitId = benefitId
        self.catalog = catalog
        self.createdAt = createdAt
        self.description = description
        self.expiresAt = expiresAt
        self.fulfillmentDetail = fulfillmentDetail
        self.fulfillmentType = fulfillmentType
        self.id = id
        self.name = name
        self.startsAt = startsAt
        self.status = status
        self.statusReason = statusReason
        self.updatedAt = updatedAt
    }
}

public struct GetBenefitApplicationInput: Swift.Sendable {
    /// The catalog identifier that specifies which benefit catalog to query.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the benefit application to retrieve.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
    }
}

public struct GetBenefitApplicationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the benefit application.
    public var arn: Swift.String?
    /// AWS resources that are associated with this benefit application.
    public var associatedResources: [Swift.String]?
    /// Detailed information and requirements specific to the benefit being requested.
    public var benefitApplicationDetails: Smithy.Document?
    /// The identifier of the benefit being requested in this application.
    public var benefitId: Swift.String?
    /// The catalog identifier that the benefit application belongs to.
    public var catalog: Swift.String?
    /// The timestamp when the benefit application was created.
    public var createdAt: Foundation.Date?
    /// A detailed description of the benefit application.
    public var description: Swift.String?
    /// Supporting documents and files attached to the benefit application.
    public var fileDetails: [PartnerCentralBenefitsClientTypes.FileDetail]?
    /// The fulfillment types requested for this benefit application.
    public var fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]?
    /// The unique identifier of the benefit application.
    public var id: Swift.String?
    /// The human-readable name of the benefit application.
    public var name: Swift.String?
    /// Contact information for partner representatives responsible for this benefit application.
    public var partnerContacts: [PartnerCentralBenefitsClientTypes.Contact]?
    /// The AWS partner programs associated with this benefit application.
    public var programs: [Swift.String]?
    /// The current revision number of the benefit application.
    public var revision: Swift.String?
    /// The current stage in the benefit application processing workflow.
    public var stage: Swift.String?
    /// The current processing status of the benefit application.
    public var status: PartnerCentralBenefitsClientTypes.BenefitApplicationStatus?
    /// Additional information explaining the current status of the benefit application.
    public var statusReason: Swift.String?
    /// A standardized code representing the reason for the current status.
    @available(*, deprecated, message: "This field is no longer used API deprecated since Nov 08 2025")
    public var statusReasonCode: Swift.String?
    /// The list of standardized codes representing the reason for the current status.
    public var statusReasonCodes: [Swift.String]?
    /// The timestamp when the benefit application was last updated.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        associatedResources: [Swift.String]? = nil,
        benefitApplicationDetails: Smithy.Document? = nil,
        benefitId: Swift.String? = nil,
        catalog: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        fileDetails: [PartnerCentralBenefitsClientTypes.FileDetail]? = nil,
        fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        partnerContacts: [PartnerCentralBenefitsClientTypes.Contact]? = nil,
        programs: [Swift.String]? = nil,
        revision: Swift.String? = nil,
        stage: Swift.String? = nil,
        status: PartnerCentralBenefitsClientTypes.BenefitApplicationStatus? = nil,
        statusReason: Swift.String? = nil,
        statusReasonCode: Swift.String? = nil,
        statusReasonCodes: [Swift.String]? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.associatedResources = associatedResources
        self.benefitApplicationDetails = benefitApplicationDetails
        self.benefitId = benefitId
        self.catalog = catalog
        self.createdAt = createdAt
        self.description = description
        self.fileDetails = fileDetails
        self.fulfillmentTypes = fulfillmentTypes
        self.id = id
        self.name = name
        self.partnerContacts = partnerContacts
        self.programs = programs
        self.revision = revision
        self.stage = stage
        self.status = status
        self.statusReason = statusReason
        self.statusReasonCode = statusReasonCode
        self.statusReasonCodes = statusReasonCodes
        self.updatedAt = updatedAt
    }
}

public struct ListBenefitAllocationsInput: Swift.Sendable {
    /// Filter benefit allocations by specific benefit application identifiers.
    public var benefitApplicationIdentifiers: [Swift.String]?
    /// Filter benefit allocations by specific benefit identifiers.
    public var benefitIdentifiers: [Swift.String]?
    /// The catalog identifier to filter benefit allocations by catalog.
    /// This member is required.
    public var catalog: Swift.String?
    /// Filter benefit allocations by specific fulfillment types.
    public var fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]?
    /// The maximum number of benefit allocations to return in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token to retrieve the next set of results from a previous request.
    public var nextToken: Swift.String?
    /// Filter benefit allocations by their current status.
    public var status: [PartnerCentralBenefitsClientTypes.BenefitAllocationStatus]?

    public init(
        benefitApplicationIdentifiers: [Swift.String]? = nil,
        benefitIdentifiers: [Swift.String]? = nil,
        catalog: Swift.String? = nil,
        fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: [PartnerCentralBenefitsClientTypes.BenefitAllocationStatus]? = nil
    ) {
        self.benefitApplicationIdentifiers = benefitApplicationIdentifiers
        self.benefitIdentifiers = benefitIdentifiers
        self.catalog = catalog
        self.fulfillmentTypes = fulfillmentTypes
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

public struct ListBenefitAllocationsOutput: Swift.Sendable {
    /// A list of benefit allocation summaries matching the specified criteria.
    public var benefitAllocationSummaries: [PartnerCentralBenefitsClientTypes.BenefitAllocationSummary]?
    /// A pagination token to retrieve the next set of results, if more results are available.
    public var nextToken: Swift.String?

    public init(
        benefitAllocationSummaries: [PartnerCentralBenefitsClientTypes.BenefitAllocationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.benefitAllocationSummaries = benefitAllocationSummaries
        self.nextToken = nextToken
    }
}

public struct ListBenefitApplicationsInput: Swift.Sendable {
    /// Filter benefit applications by specific AWS resource ARNs.
    public var associatedResourceArns: [Swift.String]?
    /// Filter benefit applications by associated AWS resources.
    @available(*, deprecated, message: "This field is no longer used. API deprecated since Oct 08 2025")
    public var associatedResources: [PartnerCentralBenefitsClientTypes.AssociatedResource]?
    /// Filter benefit applications by specific benefit identifiers.
    public var benefitIdentifiers: [Swift.String]?
    /// The catalog identifier to filter benefit applications by catalog.
    /// This member is required.
    public var catalog: Swift.String?
    /// Filter benefit applications by specific fulfillment types.
    public var fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]?
    /// The maximum number of benefit applications to return in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token to retrieve the next set of results from a previous request.
    public var nextToken: Swift.String?
    /// Filter benefit applications by specific AWS partner programs.
    public var programs: [Swift.String]?
    /// Filter benefit applications by their current processing stage.
    public var stages: [Swift.String]?
    /// Filter benefit applications by their current processing status.
    public var status: [PartnerCentralBenefitsClientTypes.BenefitApplicationStatus]?

    public init(
        associatedResourceArns: [Swift.String]? = nil,
        associatedResources: [PartnerCentralBenefitsClientTypes.AssociatedResource]? = nil,
        benefitIdentifiers: [Swift.String]? = nil,
        catalog: Swift.String? = nil,
        fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        programs: [Swift.String]? = nil,
        stages: [Swift.String]? = nil,
        status: [PartnerCentralBenefitsClientTypes.BenefitApplicationStatus]? = nil
    ) {
        self.associatedResourceArns = associatedResourceArns
        self.associatedResources = associatedResources
        self.benefitIdentifiers = benefitIdentifiers
        self.catalog = catalog
        self.fulfillmentTypes = fulfillmentTypes
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.programs = programs
        self.stages = stages
        self.status = status
    }
}

public struct ListBenefitApplicationsOutput: Swift.Sendable {
    /// A list of benefit application summaries matching the specified criteria.
    public var benefitApplicationSummaries: [PartnerCentralBenefitsClientTypes.BenefitApplicationSummary]?
    /// A pagination token to retrieve the next set of results, if more results are available.
    public var nextToken: Swift.String?

    public init(
        benefitApplicationSummaries: [PartnerCentralBenefitsClientTypes.BenefitApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.benefitApplicationSummaries = benefitApplicationSummaries
        self.nextToken = nextToken
    }
}

public struct ListBenefitsInput: Swift.Sendable {
    /// The catalog identifier to filter benefits by catalog.
    /// This member is required.
    public var catalog: Swift.String?
    /// Filter benefits by specific fulfillment types.
    public var fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]?
    /// The maximum number of benefits to return in a single response.
    public var maxResults: Swift.Int?
    /// A pagination token to retrieve the next set of results from a previous request.
    public var nextToken: Swift.String?
    /// Filter benefits by specific AWS partner programs.
    public var programs: [Swift.String]?
    /// Filter benefits by their current status.
    public var status: [PartnerCentralBenefitsClientTypes.BenefitStatus]?

    public init(
        catalog: Swift.String? = nil,
        fulfillmentTypes: [PartnerCentralBenefitsClientTypes.FulfillmentType]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        programs: [Swift.String]? = nil,
        status: [PartnerCentralBenefitsClientTypes.BenefitStatus]? = nil
    ) {
        self.catalog = catalog
        self.fulfillmentTypes = fulfillmentTypes
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.programs = programs
        self.status = status
    }
}

public struct ListBenefitsOutput: Swift.Sendable {
    /// A list of benefit summaries matching the specified criteria.
    public var benefitSummaries: [PartnerCentralBenefitsClientTypes.BenefitSummary]?
    /// A pagination token to retrieve the next set of results, if more results are available.
    public var nextToken: Swift.String?

    public init(
        benefitSummaries: [PartnerCentralBenefitsClientTypes.BenefitSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.benefitSummaries = benefitSummaries
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to list tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A list of key-value pairs representing the tags associated with the resource.
    public var tags: [PartnerCentralBenefitsClientTypes.Tag]?

    public init(
        tags: [PartnerCentralBenefitsClientTypes.Tag]? = nil
    ) {
        self.tags = tags
    }
}

public struct RecallBenefitApplicationInput: Swift.Sendable {
    /// The catalog identifier that specifies which benefit catalog the application belongs to.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotent processing of the recall request.
    public var clientToken: Swift.String?
    /// The unique identifier of the benefit application to recall.
    /// This member is required.
    public var identifier: Swift.String?
    /// A descriptive reason explaining why the benefit application is being recalled.
    /// This member is required.
    public var reason: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        reason: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.identifier = identifier
        self.reason = reason
    }
}

public struct RecallBenefitApplicationOutput: Swift.Sendable {

    public init() { }
}

public struct SubmitBenefitApplicationInput: Swift.Sendable {
    /// The catalog identifier that specifies which benefit catalog the application belongs to.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the benefit application to submit.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
    }
}

public struct SubmitBenefitApplicationOutput: Swift.Sendable {

    public init() { }
}

/// Thrown when the request would exceed the service quotas or limits for the account.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A message describing the service quota exceeded error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The code identifying the specific quota that would be exceeded.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The identifier of the resource that would exceed the quota.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that would exceed the quota.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to add tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of key-value pairs to add as tags to the resource.
    /// This member is required.
    public var tags: [PartnerCentralBenefitsClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [PartnerCentralBenefitsClientTypes.Tag]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateBenefitApplicationInput: Swift.Sendable {
    /// Updated detailed information and requirements specific to the benefit being requested.
    public var benefitApplicationDetails: Smithy.Document?
    /// The catalog identifier that specifies which benefit catalog the application belongs to.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotent processing of the update request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The updated detailed description of the benefit application.
    public var description: Swift.String?
    /// Updated supporting documents and files attached to the benefit application.
    public var fileDetails: [PartnerCentralBenefitsClientTypes.FileInput]?
    /// The unique identifier of the benefit application to update.
    /// This member is required.
    public var identifier: Swift.String?
    /// The updated human-readable name for the benefit application.
    public var name: Swift.String?
    /// Updated contact information for partner representatives responsible for this benefit application.
    public var partnerContacts: [PartnerCentralBenefitsClientTypes.Contact]?
    /// The current revision number of the benefit application to ensure optimistic concurrency control.
    /// This member is required.
    public var revision: Swift.String?

    public init(
        benefitApplicationDetails: Smithy.Document? = nil,
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        fileDetails: [PartnerCentralBenefitsClientTypes.FileInput]? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil,
        partnerContacts: [PartnerCentralBenefitsClientTypes.Contact]? = nil,
        revision: Swift.String? = nil
    ) {
        self.benefitApplicationDetails = benefitApplicationDetails
        self.catalog = catalog
        self.clientToken = clientToken
        self.description = description
        self.fileDetails = fileDetails
        self.identifier = identifier
        self.name = name
        self.partnerContacts = partnerContacts
        self.revision = revision
    }
}

public struct UpdateBenefitApplicationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the updated benefit application.
    public var arn: Swift.String?
    /// The unique identifier of the updated benefit application.
    public var id: Swift.String?
    /// The new revision number of the benefit application after the update.
    public var revision: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        revision: Swift.String? = nil
    ) {
        self.arn = arn
        self.id = id
        self.revision = revision
    }
}

extension AmendBenefitApplicationInput {

    static func urlPathProvider(_ value: AmendBenefitApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateBenefitApplicationResourceInput {

    static func urlPathProvider(_ value: AssociateBenefitApplicationResourceInput) -> Swift.String? {
        return "/"
    }
}

extension CancelBenefitApplicationInput {

    static func urlPathProvider(_ value: CancelBenefitApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateBenefitApplicationInput {

    static func urlPathProvider(_ value: CreateBenefitApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateBenefitApplicationResourceInput {

    static func urlPathProvider(_ value: DisassociateBenefitApplicationResourceInput) -> Swift.String? {
        return "/"
    }
}

extension GetBenefitInput {

    static func urlPathProvider(_ value: GetBenefitInput) -> Swift.String? {
        return "/"
    }
}

extension GetBenefitAllocationInput {

    static func urlPathProvider(_ value: GetBenefitAllocationInput) -> Swift.String? {
        return "/"
    }
}

extension GetBenefitApplicationInput {

    static func urlPathProvider(_ value: GetBenefitApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension ListBenefitAllocationsInput {

    static func urlPathProvider(_ value: ListBenefitAllocationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListBenefitApplicationsInput {

    static func urlPathProvider(_ value: ListBenefitApplicationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListBenefitsInput {

    static func urlPathProvider(_ value: ListBenefitsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension RecallBenefitApplicationInput {

    static func urlPathProvider(_ value: RecallBenefitApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension SubmitBenefitApplicationInput {

    static func urlPathProvider(_ value: SubmitBenefitApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateBenefitApplicationInput {

    static func urlPathProvider(_ value: UpdateBenefitApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension AmendBenefitApplicationInput {

    static func write(value: AmendBenefitApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AmendmentReason"].write(value.amendmentReason)
        try writer["Amendments"].writeList(value.amendments, memberWritingClosure: PartnerCentralBenefitsClientTypes.Amendment.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Identifier"].write(value.identifier)
        try writer["Revision"].write(value.revision)
    }
}

extension AssociateBenefitApplicationResourceInput {

    static func write(value: AssociateBenefitApplicationResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BenefitApplicationIdentifier"].write(value.benefitApplicationIdentifier)
        try writer["Catalog"].write(value.catalog)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension CancelBenefitApplicationInput {

    static func write(value: CancelBenefitApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Identifier"].write(value.identifier)
        try writer["Reason"].write(value.reason)
    }
}

extension CreateBenefitApplicationInput {

    static func write(value: CreateBenefitApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociatedResources"].writeList(value.associatedResources, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BenefitApplicationDetails"].write(value.benefitApplicationDetails)
        try writer["BenefitIdentifier"].write(value.benefitIdentifier)
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["FileDetails"].writeList(value.fileDetails, memberWritingClosure: PartnerCentralBenefitsClientTypes.FileInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["FulfillmentTypes"].writeList(value.fulfillmentTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralBenefitsClientTypes.FulfillmentType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["PartnerContacts"].writeList(value.partnerContacts, memberWritingClosure: PartnerCentralBenefitsClientTypes.Contact.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PartnerCentralBenefitsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DisassociateBenefitApplicationResourceInput {

    static func write(value: DisassociateBenefitApplicationResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BenefitApplicationIdentifier"].write(value.benefitApplicationIdentifier)
        try writer["Catalog"].write(value.catalog)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension GetBenefitInput {

    static func write(value: GetBenefitInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
    }
}

extension GetBenefitAllocationInput {

    static func write(value: GetBenefitAllocationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
    }
}

extension GetBenefitApplicationInput {

    static func write(value: GetBenefitApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
    }
}

extension ListBenefitAllocationsInput {

    static func write(value: ListBenefitAllocationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BenefitApplicationIdentifiers"].writeList(value.benefitApplicationIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BenefitIdentifiers"].writeList(value.benefitIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Catalog"].write(value.catalog)
        try writer["FulfillmentTypes"].writeList(value.fulfillmentTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralBenefitsClientTypes.FulfillmentType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Status"].writeList(value.status, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralBenefitsClientTypes.BenefitAllocationStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListBenefitApplicationsInput {

    static func write(value: ListBenefitApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociatedResourceArns"].writeList(value.associatedResourceArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AssociatedResources"].writeList(value.associatedResources, memberWritingClosure: PartnerCentralBenefitsClientTypes.AssociatedResource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["BenefitIdentifiers"].writeList(value.benefitIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Catalog"].write(value.catalog)
        try writer["FulfillmentTypes"].writeList(value.fulfillmentTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralBenefitsClientTypes.FulfillmentType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Programs"].writeList(value.programs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Stages"].writeList(value.stages, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Status"].writeList(value.status, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralBenefitsClientTypes.BenefitApplicationStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListBenefitsInput {

    static func write(value: ListBenefitsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["FulfillmentTypes"].writeList(value.fulfillmentTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralBenefitsClientTypes.FulfillmentType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Programs"].writeList(value.programs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Status"].writeList(value.status, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralBenefitsClientTypes.BenefitStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension RecallBenefitApplicationInput {

    static func write(value: RecallBenefitApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Identifier"].write(value.identifier)
        try writer["Reason"].write(value.reason)
    }
}

extension SubmitBenefitApplicationInput {

    static func write(value: SubmitBenefitApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeList(value.tags, memberWritingClosure: PartnerCentralBenefitsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateBenefitApplicationInput {

    static func write(value: UpdateBenefitApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BenefitApplicationDetails"].write(value.benefitApplicationDetails)
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["FileDetails"].writeList(value.fileDetails, memberWritingClosure: PartnerCentralBenefitsClientTypes.FileInput.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Identifier"].write(value.identifier)
        try writer["Name"].write(value.name)
        try writer["PartnerContacts"].writeList(value.partnerContacts, memberWritingClosure: PartnerCentralBenefitsClientTypes.Contact.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Revision"].write(value.revision)
    }
}

extension AmendBenefitApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AmendBenefitApplicationOutput {
        return AmendBenefitApplicationOutput()
    }
}

extension AssociateBenefitApplicationResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateBenefitApplicationResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateBenefitApplicationResourceOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.revision = try reader["Revision"].readIfPresent()
        return value
    }
}

extension CancelBenefitApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelBenefitApplicationOutput {
        return CancelBenefitApplicationOutput()
    }
}

extension CreateBenefitApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBenefitApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBenefitApplicationOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.revision = try reader["Revision"].readIfPresent()
        return value
    }
}

extension DisassociateBenefitApplicationResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateBenefitApplicationResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateBenefitApplicationResourceOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.revision = try reader["Revision"].readIfPresent()
        return value
    }
}

extension GetBenefitOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBenefitOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBenefitOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.benefitRequestSchema = try reader["BenefitRequestSchema"].readIfPresent()
        value.catalog = try reader["Catalog"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.fulfillmentTypes = try reader["FulfillmentTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PartnerCentralBenefitsClientTypes.FulfillmentType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.programs = try reader["Programs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension GetBenefitAllocationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBenefitAllocationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBenefitAllocationOutput()
        value.applicableBenefitIds = try reader["ApplicableBenefitIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.arn = try reader["Arn"].readIfPresent()
        value.benefitApplicationId = try reader["BenefitApplicationId"].readIfPresent()
        value.benefitId = try reader["BenefitId"].readIfPresent()
        value.catalog = try reader["Catalog"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["Description"].readIfPresent()
        value.expiresAt = try reader["ExpiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.fulfillmentDetail = try reader["FulfillmentDetail"].readIfPresent(with: PartnerCentralBenefitsClientTypes.FulfillmentDetails.read(from:))
        value.fulfillmentType = try reader["FulfillmentType"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.startsAt = try reader["StartsAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension GetBenefitApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBenefitApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBenefitApplicationOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.associatedResources = try reader["AssociatedResources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.benefitApplicationDetails = try reader["BenefitApplicationDetails"].readIfPresent()
        value.benefitId = try reader["BenefitId"].readIfPresent()
        value.catalog = try reader["Catalog"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["Description"].readIfPresent()
        value.fileDetails = try reader["FileDetails"].readListIfPresent(memberReadingClosure: PartnerCentralBenefitsClientTypes.FileDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.fulfillmentTypes = try reader["FulfillmentTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PartnerCentralBenefitsClientTypes.FulfillmentType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.partnerContacts = try reader["PartnerContacts"].readListIfPresent(memberReadingClosure: PartnerCentralBenefitsClientTypes.Contact.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.programs = try reader["Programs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.revision = try reader["Revision"].readIfPresent()
        value.stage = try reader["Stage"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.statusReasonCode = try reader["StatusReasonCode"].readIfPresent()
        value.statusReasonCodes = try reader["StatusReasonCodes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension ListBenefitAllocationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBenefitAllocationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBenefitAllocationsOutput()
        value.benefitAllocationSummaries = try reader["BenefitAllocationSummaries"].readListIfPresent(memberReadingClosure: PartnerCentralBenefitsClientTypes.BenefitAllocationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListBenefitApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBenefitApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBenefitApplicationsOutput()
        value.benefitApplicationSummaries = try reader["BenefitApplicationSummaries"].readListIfPresent(memberReadingClosure: PartnerCentralBenefitsClientTypes.BenefitApplicationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListBenefitsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBenefitsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBenefitsOutput()
        value.benefitSummaries = try reader["BenefitSummaries"].readListIfPresent(memberReadingClosure: PartnerCentralBenefitsClientTypes.BenefitSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: PartnerCentralBenefitsClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension RecallBenefitApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RecallBenefitApplicationOutput {
        return RecallBenefitApplicationOutput()
    }
}

extension SubmitBenefitApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SubmitBenefitApplicationOutput {
        return SubmitBenefitApplicationOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateBenefitApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBenefitApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBenefitApplicationOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.revision = try reader["Revision"].readIfPresent()
        return value
    }
}

enum AmendBenefitApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateBenefitApplicationResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelBenefitApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBenefitApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateBenefitApplicationResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBenefitOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBenefitAllocationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBenefitApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBenefitAllocationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBenefitApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBenefitsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RecallBenefitApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SubmitBenefitApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBenefitApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["FieldList"].readListIfPresent(memberReadingClosure: PartnerCentralBenefitsClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PartnerCentralBenefitsClientTypes.FulfillmentDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralBenefitsClientTypes.FulfillmentDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "DisbursementDetails":
                return .disbursementdetails(try reader["DisbursementDetails"].read(with: PartnerCentralBenefitsClientTypes.DisbursementDetails.read(from:)))
            case "ConsumableDetails":
                return .consumabledetails(try reader["ConsumableDetails"].read(with: PartnerCentralBenefitsClientTypes.ConsumableDetails.read(from:)))
            case "CreditDetails":
                return .creditdetails(try reader["CreditDetails"].read(with: PartnerCentralBenefitsClientTypes.CreditDetails.read(from:)))
            case "AccessDetails":
                return .accessdetails(try reader["AccessDetails"].read(with: PartnerCentralBenefitsClientTypes.AccessDetails.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension PartnerCentralBenefitsClientTypes.AccessDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralBenefitsClientTypes.AccessDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralBenefitsClientTypes.AccessDetails()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension PartnerCentralBenefitsClientTypes.CreditDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralBenefitsClientTypes.CreditDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralBenefitsClientTypes.CreditDetails()
        value.allocatedAmount = try reader["AllocatedAmount"].readIfPresent(with: PartnerCentralBenefitsClientTypes.MonetaryValue.read(from:))
        value.issuedAmount = try reader["IssuedAmount"].readIfPresent(with: PartnerCentralBenefitsClientTypes.MonetaryValue.read(from:))
        value.codes = try reader["Codes"].readListIfPresent(memberReadingClosure: PartnerCentralBenefitsClientTypes.CreditCode.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PartnerCentralBenefitsClientTypes.CreditCode {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralBenefitsClientTypes.CreditCode {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralBenefitsClientTypes.CreditCode()
        value.awsAccountId = try reader["AwsAccountId"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent(with: PartnerCentralBenefitsClientTypes.MonetaryValue.read(from:))
        value.awsCreditCode = try reader["AwsCreditCode"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.issuedAt = try reader["IssuedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.expiresAt = try reader["ExpiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PartnerCentralBenefitsClientTypes.MonetaryValue {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralBenefitsClientTypes.MonetaryValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralBenefitsClientTypes.MonetaryValue()
        value.amount = try reader["Amount"].readIfPresent() ?? ""
        value.currencyCode = try reader["CurrencyCode"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension PartnerCentralBenefitsClientTypes.ConsumableDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralBenefitsClientTypes.ConsumableDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralBenefitsClientTypes.ConsumableDetails()
        value.allocatedAmount = try reader["AllocatedAmount"].readIfPresent(with: PartnerCentralBenefitsClientTypes.MonetaryValue.read(from:))
        value.remainingAmount = try reader["RemainingAmount"].readIfPresent(with: PartnerCentralBenefitsClientTypes.MonetaryValue.read(from:))
        value.utilizedAmount = try reader["UtilizedAmount"].readIfPresent(with: PartnerCentralBenefitsClientTypes.MonetaryValue.read(from:))
        value.issuanceDetails = try reader["IssuanceDetails"].readIfPresent(with: PartnerCentralBenefitsClientTypes.IssuanceDetail.read(from:))
        return value
    }
}

extension PartnerCentralBenefitsClientTypes.IssuanceDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralBenefitsClientTypes.IssuanceDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralBenefitsClientTypes.IssuanceDetail()
        value.issuanceId = try reader["IssuanceId"].readIfPresent()
        value.issuanceAmount = try reader["IssuanceAmount"].readIfPresent(with: PartnerCentralBenefitsClientTypes.MonetaryValue.read(from:))
        value.issuedAt = try reader["IssuedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension PartnerCentralBenefitsClientTypes.DisbursementDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralBenefitsClientTypes.DisbursementDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralBenefitsClientTypes.DisbursementDetails()
        value.disbursedAmount = try reader["DisbursedAmount"].readIfPresent(with: PartnerCentralBenefitsClientTypes.MonetaryValue.read(from:))
        value.issuanceDetails = try reader["IssuanceDetails"].readIfPresent(with: PartnerCentralBenefitsClientTypes.IssuanceDetail.read(from:))
        return value
    }
}

extension PartnerCentralBenefitsClientTypes.Contact {

    static func write(value: PartnerCentralBenefitsClientTypes.Contact?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BusinessTitle"].write(value.businessTitle)
        try writer["Email"].write(value.email)
        try writer["FirstName"].write(value.firstName)
        try writer["LastName"].write(value.lastName)
        try writer["Phone"].write(value.phone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralBenefitsClientTypes.Contact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralBenefitsClientTypes.Contact()
        value.email = try reader["Email"].readIfPresent()
        value.firstName = try reader["FirstName"].readIfPresent()
        value.lastName = try reader["LastName"].readIfPresent()
        value.businessTitle = try reader["BusinessTitle"].readIfPresent()
        value.phone = try reader["Phone"].readIfPresent()
        return value
    }
}

extension PartnerCentralBenefitsClientTypes.FileDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralBenefitsClientTypes.FileDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralBenefitsClientTypes.FileDetail()
        value.fileURI = try reader["FileURI"].readIfPresent() ?? ""
        value.businessUseCase = try reader["BusinessUseCase"].readIfPresent()
        value.fileName = try reader["FileName"].readIfPresent()
        value.fileStatus = try reader["FileStatus"].readIfPresent()
        value.fileStatusReason = try reader["FileStatusReason"].readIfPresent()
        value.fileType = try reader["FileType"].readIfPresent()
        value.createdBy = try reader["CreatedBy"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension PartnerCentralBenefitsClientTypes.BenefitAllocationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralBenefitsClientTypes.BenefitAllocationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralBenefitsClientTypes.BenefitAllocationSummary()
        value.id = try reader["Id"].readIfPresent()
        value.catalog = try reader["Catalog"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.benefitId = try reader["BenefitId"].readIfPresent()
        value.benefitApplicationId = try reader["BenefitApplicationId"].readIfPresent()
        value.fulfillmentTypes = try reader["FulfillmentTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PartnerCentralBenefitsClientTypes.FulfillmentType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.expiresAt = try reader["ExpiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.applicableBenefitIds = try reader["ApplicableBenefitIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PartnerCentralBenefitsClientTypes.BenefitApplicationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralBenefitsClientTypes.BenefitApplicationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralBenefitsClientTypes.BenefitApplicationSummary()
        value.catalog = try reader["Catalog"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.benefitId = try reader["BenefitId"].readIfPresent()
        value.programs = try reader["Programs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.fulfillmentTypes = try reader["FulfillmentTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PartnerCentralBenefitsClientTypes.FulfillmentType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        value.stage = try reader["Stage"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.benefitApplicationDetails = try reader["BenefitApplicationDetails"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.associatedResources = try reader["AssociatedResources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PartnerCentralBenefitsClientTypes.BenefitSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralBenefitsClientTypes.BenefitSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralBenefitsClientTypes.BenefitSummary()
        value.id = try reader["Id"].readIfPresent()
        value.catalog = try reader["Catalog"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.programs = try reader["Programs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.fulfillmentTypes = try reader["FulfillmentTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PartnerCentralBenefitsClientTypes.FulfillmentType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension PartnerCentralBenefitsClientTypes.Tag {

    static func write(value: PartnerCentralBenefitsClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralBenefitsClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralBenefitsClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension PartnerCentralBenefitsClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralBenefitsClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralBenefitsClientTypes.ValidationExceptionField()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        value.code = try reader["Code"].readIfPresent()
        return value
    }
}

extension PartnerCentralBenefitsClientTypes.Amendment {

    static func write(value: PartnerCentralBenefitsClientTypes.Amendment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FieldPath"].write(value.fieldPath)
        try writer["NewValue"].write(value.newValue)
    }
}

extension PartnerCentralBenefitsClientTypes.FileInput {

    static func write(value: PartnerCentralBenefitsClientTypes.FileInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BusinessUseCase"].write(value.businessUseCase)
        try writer["FileURI"].write(value.fileURI)
    }
}

extension PartnerCentralBenefitsClientTypes.AssociatedResource {

    static func write(value: PartnerCentralBenefitsClientTypes.AssociatedResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["ResourceIdentifier"].write(value.resourceIdentifier)
        try writer["ResourceType"].write(value.resourceType)
    }
}

public enum PartnerCentralBenefitsClientTypes {}
