//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension ComputeOptimizerAutomationClient {
    /// Paginate over `[ListAccountsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAccountsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAccountsOutput`
    public func listAccountsPaginated(input: ListAccountsInput) -> ClientRuntime.PaginatorSequence<ListAccountsInput, ListAccountsOutput> {
        return ClientRuntime.PaginatorSequence<ListAccountsInput, ListAccountsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAccounts(input:))
    }
}

extension ListAccountsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAccountsInput {
        return ListAccountsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAccountsInput, OperationStackOutput == ListAccountsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAccountsPaginated`
    /// to access the nested member `[ComputeOptimizerAutomationClientTypes.AccountInfo]`
    /// - Returns: `[ComputeOptimizerAutomationClientTypes.AccountInfo]`
    public func accounts() async throws -> [ComputeOptimizerAutomationClientTypes.AccountInfo] {
        return try await self.asyncCompactMap { item in item.accounts }
    }
}
extension ComputeOptimizerAutomationClient {
    /// Paginate over `[ListAutomationEventsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAutomationEventsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAutomationEventsOutput`
    public func listAutomationEventsPaginated(input: ListAutomationEventsInput) -> ClientRuntime.PaginatorSequence<ListAutomationEventsInput, ListAutomationEventsOutput> {
        return ClientRuntime.PaginatorSequence<ListAutomationEventsInput, ListAutomationEventsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAutomationEvents(input:))
    }
}

extension ListAutomationEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAutomationEventsInput {
        return ListAutomationEventsInput(
            endTimeExclusive: self.endTimeExclusive,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            startTimeInclusive: self.startTimeInclusive
        )}
}

extension PaginatorSequence where OperationStackInput == ListAutomationEventsInput, OperationStackOutput == ListAutomationEventsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAutomationEventsPaginated`
    /// to access the nested member `[ComputeOptimizerAutomationClientTypes.AutomationEvent]`
    /// - Returns: `[ComputeOptimizerAutomationClientTypes.AutomationEvent]`
    public func automationEvents() async throws -> [ComputeOptimizerAutomationClientTypes.AutomationEvent] {
        return try await self.asyncCompactMap { item in item.automationEvents }
    }
}
extension ComputeOptimizerAutomationClient {
    /// Paginate over `[ListAutomationEventStepsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAutomationEventStepsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAutomationEventStepsOutput`
    public func listAutomationEventStepsPaginated(input: ListAutomationEventStepsInput) -> ClientRuntime.PaginatorSequence<ListAutomationEventStepsInput, ListAutomationEventStepsOutput> {
        return ClientRuntime.PaginatorSequence<ListAutomationEventStepsInput, ListAutomationEventStepsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAutomationEventSteps(input:))
    }
}

extension ListAutomationEventStepsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAutomationEventStepsInput {
        return ListAutomationEventStepsInput(
            eventId: self.eventId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAutomationEventStepsInput, OperationStackOutput == ListAutomationEventStepsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAutomationEventStepsPaginated`
    /// to access the nested member `[ComputeOptimizerAutomationClientTypes.AutomationEventStep]`
    /// - Returns: `[ComputeOptimizerAutomationClientTypes.AutomationEventStep]`
    public func automationEventSteps() async throws -> [ComputeOptimizerAutomationClientTypes.AutomationEventStep] {
        return try await self.asyncCompactMap { item in item.automationEventSteps }
    }
}
extension ComputeOptimizerAutomationClient {
    /// Paginate over `[ListAutomationEventSummariesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAutomationEventSummariesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAutomationEventSummariesOutput`
    public func listAutomationEventSummariesPaginated(input: ListAutomationEventSummariesInput) -> ClientRuntime.PaginatorSequence<ListAutomationEventSummariesInput, ListAutomationEventSummariesOutput> {
        return ClientRuntime.PaginatorSequence<ListAutomationEventSummariesInput, ListAutomationEventSummariesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAutomationEventSummaries(input:))
    }
}

extension ListAutomationEventSummariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAutomationEventSummariesInput {
        return ListAutomationEventSummariesInput(
            endDateExclusive: self.endDateExclusive,
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token,
            startDateInclusive: self.startDateInclusive
        )}
}

extension PaginatorSequence where OperationStackInput == ListAutomationEventSummariesInput, OperationStackOutput == ListAutomationEventSummariesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAutomationEventSummariesPaginated`
    /// to access the nested member `[ComputeOptimizerAutomationClientTypes.AutomationEventSummary]`
    /// - Returns: `[ComputeOptimizerAutomationClientTypes.AutomationEventSummary]`
    public func automationEventSummaries() async throws -> [ComputeOptimizerAutomationClientTypes.AutomationEventSummary] {
        return try await self.asyncCompactMap { item in item.automationEventSummaries }
    }
}
extension ComputeOptimizerAutomationClient {
    /// Paginate over `[ListAutomationRulePreviewOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAutomationRulePreviewInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAutomationRulePreviewOutput`
    public func listAutomationRulePreviewPaginated(input: ListAutomationRulePreviewInput) -> ClientRuntime.PaginatorSequence<ListAutomationRulePreviewInput, ListAutomationRulePreviewOutput> {
        return ClientRuntime.PaginatorSequence<ListAutomationRulePreviewInput, ListAutomationRulePreviewOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAutomationRulePreview(input:))
    }
}

extension ListAutomationRulePreviewInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAutomationRulePreviewInput {
        return ListAutomationRulePreviewInput(
            criteria: self.criteria,
            maxResults: self.maxResults,
            nextToken: token,
            organizationScope: self.organizationScope,
            recommendedActionTypes: self.recommendedActionTypes,
            ruleType: self.ruleType
        )}
}

extension PaginatorSequence where OperationStackInput == ListAutomationRulePreviewInput, OperationStackOutput == ListAutomationRulePreviewOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAutomationRulePreviewPaginated`
    /// to access the nested member `[ComputeOptimizerAutomationClientTypes.PreviewResult]`
    /// - Returns: `[ComputeOptimizerAutomationClientTypes.PreviewResult]`
    public func previewResults() async throws -> [ComputeOptimizerAutomationClientTypes.PreviewResult] {
        return try await self.asyncCompactMap { item in item.previewResults }
    }
}
extension ComputeOptimizerAutomationClient {
    /// Paginate over `[ListAutomationRulePreviewSummariesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAutomationRulePreviewSummariesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAutomationRulePreviewSummariesOutput`
    public func listAutomationRulePreviewSummariesPaginated(input: ListAutomationRulePreviewSummariesInput) -> ClientRuntime.PaginatorSequence<ListAutomationRulePreviewSummariesInput, ListAutomationRulePreviewSummariesOutput> {
        return ClientRuntime.PaginatorSequence<ListAutomationRulePreviewSummariesInput, ListAutomationRulePreviewSummariesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAutomationRulePreviewSummaries(input:))
    }
}

extension ListAutomationRulePreviewSummariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAutomationRulePreviewSummariesInput {
        return ListAutomationRulePreviewSummariesInput(
            criteria: self.criteria,
            maxResults: self.maxResults,
            nextToken: token,
            organizationScope: self.organizationScope,
            recommendedActionTypes: self.recommendedActionTypes,
            ruleType: self.ruleType
        )}
}

extension PaginatorSequence where OperationStackInput == ListAutomationRulePreviewSummariesInput, OperationStackOutput == ListAutomationRulePreviewSummariesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAutomationRulePreviewSummariesPaginated`
    /// to access the nested member `[ComputeOptimizerAutomationClientTypes.PreviewResultSummary]`
    /// - Returns: `[ComputeOptimizerAutomationClientTypes.PreviewResultSummary]`
    public func previewResultSummaries() async throws -> [ComputeOptimizerAutomationClientTypes.PreviewResultSummary] {
        return try await self.asyncCompactMap { item in item.previewResultSummaries }
    }
}
extension ComputeOptimizerAutomationClient {
    /// Paginate over `[ListAutomationRulesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAutomationRulesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAutomationRulesOutput`
    public func listAutomationRulesPaginated(input: ListAutomationRulesInput) -> ClientRuntime.PaginatorSequence<ListAutomationRulesInput, ListAutomationRulesOutput> {
        return ClientRuntime.PaginatorSequence<ListAutomationRulesInput, ListAutomationRulesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listAutomationRules(input:))
    }
}

extension ListAutomationRulesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAutomationRulesInput {
        return ListAutomationRulesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListAutomationRulesInput, OperationStackOutput == ListAutomationRulesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAutomationRulesPaginated`
    /// to access the nested member `[ComputeOptimizerAutomationClientTypes.AutomationRule]`
    /// - Returns: `[ComputeOptimizerAutomationClientTypes.AutomationRule]`
    public func automationRules() async throws -> [ComputeOptimizerAutomationClientTypes.AutomationRule] {
        return try await self.asyncCompactMap { item in item.automationRules }
    }
}
extension ComputeOptimizerAutomationClient {
    /// Paginate over `[ListRecommendedActionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecommendedActionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecommendedActionsOutput`
    public func listRecommendedActionsPaginated(input: ListRecommendedActionsInput) -> ClientRuntime.PaginatorSequence<ListRecommendedActionsInput, ListRecommendedActionsOutput> {
        return ClientRuntime.PaginatorSequence<ListRecommendedActionsInput, ListRecommendedActionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRecommendedActions(input:))
    }
}

extension ListRecommendedActionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecommendedActionsInput {
        return ListRecommendedActionsInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListRecommendedActionsInput, OperationStackOutput == ListRecommendedActionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRecommendedActionsPaginated`
    /// to access the nested member `[ComputeOptimizerAutomationClientTypes.RecommendedAction]`
    /// - Returns: `[ComputeOptimizerAutomationClientTypes.RecommendedAction]`
    public func recommendedActions() async throws -> [ComputeOptimizerAutomationClientTypes.RecommendedAction] {
        return try await self.asyncCompactMap { item in item.recommendedActions }
    }
}
extension ComputeOptimizerAutomationClient {
    /// Paginate over `[ListRecommendedActionSummariesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRecommendedActionSummariesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRecommendedActionSummariesOutput`
    public func listRecommendedActionSummariesPaginated(input: ListRecommendedActionSummariesInput) -> ClientRuntime.PaginatorSequence<ListRecommendedActionSummariesInput, ListRecommendedActionSummariesOutput> {
        return ClientRuntime.PaginatorSequence<ListRecommendedActionSummariesInput, ListRecommendedActionSummariesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRecommendedActionSummaries(input:))
    }
}

extension ListRecommendedActionSummariesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRecommendedActionSummariesInput {
        return ListRecommendedActionSummariesInput(
            filters: self.filters,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListRecommendedActionSummariesInput, OperationStackOutput == ListRecommendedActionSummariesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRecommendedActionSummariesPaginated`
    /// to access the nested member `[ComputeOptimizerAutomationClientTypes.RecommendedActionSummary]`
    /// - Returns: `[ComputeOptimizerAutomationClientTypes.RecommendedActionSummary]`
    public func recommendedActionSummaries() async throws -> [ComputeOptimizerAutomationClientTypes.RecommendedActionSummary] {
        return try await self.asyncCompactMap { item in item.recommendedActionSummaries }
    }
}
