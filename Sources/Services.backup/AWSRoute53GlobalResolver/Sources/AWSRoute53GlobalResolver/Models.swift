//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You don't have permission to perform this operation. Check your IAM permissions and try again.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request conflicts with the current state of the resource. This can occur when trying to modify a resource that is not in a valid state for the requested operation.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the conflicting resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the conflicting resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// An internal server error occurred. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Number of seconds in which the caller can retry the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    ) {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The specified resource was not found. Verify the resource ID and try again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The unique ID of the resource referenced in the failed request.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type of the resource referenced in the failed request.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request would exceed one or more service quotas. Check your current usage and quotas, then try again.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code recognized by the AWS Service Quotas service.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The unique ID of the resource referenced in the failed request.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resource type of the resource referenced in the failed request.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The code for the AWS service that owns the quota.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// The request was throttled due to too many requests. Wait a moment and try again.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code recognized by the AWS Service Quotas service.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Number of seconds in which the caller can retry the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The code for the AWS service that owns the quota.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension Route53GlobalResolverClientTypes {

    /// Information about a field that failed validation.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The validation error message for the field.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
        }
    }
}

extension Route53GlobalResolverClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input parameters are invalid. Check the parameter values and try again.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// The list of fields that aren't valid.
        public internal(set) var fieldList: [Route53GlobalResolverClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Reason the request failed validation.
        /// This member is required.
        public internal(set) var reason: Route53GlobalResolverClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [Route53GlobalResolverClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: Route53GlobalResolverClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension Route53GlobalResolverClientTypes {

    public enum IpAddressType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ipv4
        case ipv6
        case sdkUnknown(Swift.String)

        public static var allCases: [IpAddressType] {
            return [
                .ipv4,
                .ipv6
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ipv4: return "IPV4"
            case .ipv6: return "IPV6"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53GlobalResolverClientTypes {

    public enum DnsProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case do53
        case doh
        case dot
        case sdkUnknown(Swift.String)

        public static var allCases: [DnsProtocol] {
            return [
                .do53,
                .doh,
                .dot
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .do53: return "DO53"
            case .doh: return "DOH"
            case .dot: return "DOT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateAccessSourceInput: Swift.Sendable {
    /// The IP address or CIDR range that is allowed to send DNS queries to the Route 53 Global Resolver.
    /// This member is required.
    public var cidr: Swift.String?
    /// A unique string that identifies the request and ensures idempotency.
    public var clientToken: Swift.String?
    /// The ID of the DNS view to associate with this access source.
    /// This member is required.
    public var dnsViewId: Swift.String?
    /// The IP address type for this access source. Valid values are IPv4 and IPv6 (if the Route 53 Global Resolver supports dual-stack).
    public var ipAddressType: Route53GlobalResolverClientTypes.IpAddressType?
    /// A descriptive name for the access source.
    public var name: Swift.String?
    /// The DNS protocol that is permitted for this access source. Valid values are Do53 (DNS over port 53), DoT (DNS over TLS), and DoH (DNS over HTTPS).
    /// This member is required.
    public var `protocol`: Route53GlobalResolverClientTypes.DnsProtocol?
    /// Tags to associate with the access source.
    public var tags: [Swift.String: Swift.String]?

    public init(
        cidr: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        dnsViewId: Swift.String? = nil,
        ipAddressType: Route53GlobalResolverClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil,
        `protocol`: Route53GlobalResolverClientTypes.DnsProtocol? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.cidr = cidr
        self.clientToken = clientToken
        self.dnsViewId = dnsViewId
        self.ipAddressType = ipAddressType
        self.name = name
        self.`protocol` = `protocol`
        self.tags = tags
    }
}

extension Route53GlobalResolverClientTypes {

    public enum CRResourceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case operational
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [CRResourceStatus] {
            return [
                .creating,
                .deleting,
                .operational,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .operational: return "OPERATIONAL"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateAccessSourceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the access source.
    /// This member is required.
    public var arn: Swift.String?
    /// The IP address or CIDR range that is allowed to send DNS queries to the Route 53 Global Resolver.
    /// This member is required.
    public var cidr: Swift.String?
    /// The date and time when the access source was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The ID of the DNS view associated with this access source.
    /// This member is required.
    public var dnsViewId: Swift.String?
    /// The unique identifier for the access source.
    /// This member is required.
    public var id: Swift.String?
    /// The IP address type for this access source (IPv4 or IPv6).
    /// This member is required.
    public var ipAddressType: Route53GlobalResolverClientTypes.IpAddressType?
    /// The descriptive name of the access source.
    public var name: Swift.String?
    /// The DNS protocol that is permitted for this access source (Do53, DoT, or DoH).
    /// This member is required.
    public var `protocol`: Route53GlobalResolverClientTypes.DnsProtocol?
    /// The operational status of the access source.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
    /// The date and time when the access source was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        cidr: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        dnsViewId: Swift.String? = nil,
        id: Swift.String? = nil,
        ipAddressType: Route53GlobalResolverClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil,
        `protocol`: Route53GlobalResolverClientTypes.DnsProtocol? = nil,
        status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.cidr = cidr
        self.createdAt = createdAt
        self.dnsViewId = dnsViewId
        self.id = id
        self.ipAddressType = ipAddressType
        self.name = name
        self.`protocol` = `protocol`
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct DeleteAccessSourceInput: Swift.Sendable {
    /// The unique identifier of the access source to delete.
    /// This member is required.
    public var accessSourceId: Swift.String?

    public init(
        accessSourceId: Swift.String? = nil
    ) {
        self.accessSourceId = accessSourceId
    }
}

public struct DeleteAccessSourceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the deleted access source.
    /// This member is required.
    public var arn: Swift.String?
    /// The IP address or CIDR range of the deleted access source.
    /// This member is required.
    public var cidr: Swift.String?
    /// The date and time when the access source was originally created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The ID of the DNS view that was associated with the deleted access source.
    /// This member is required.
    public var dnsViewId: Swift.String?
    /// The unique identifier of the deleted access source.
    /// This member is required.
    public var id: Swift.String?
    /// The IP address type of the deleted access source (IPv4 or IPv6).
    /// This member is required.
    public var ipAddressType: Route53GlobalResolverClientTypes.IpAddressType?
    /// The name of the deleted access source.
    public var name: Swift.String?
    /// The DNS protocol that was permitted for the deleted access source.
    /// This member is required.
    public var `protocol`: Route53GlobalResolverClientTypes.DnsProtocol?
    /// The final status of the deleted access source.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
    /// The date and time when the access source was last updated before deletion.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        cidr: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        dnsViewId: Swift.String? = nil,
        id: Swift.String? = nil,
        ipAddressType: Route53GlobalResolverClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil,
        `protocol`: Route53GlobalResolverClientTypes.DnsProtocol? = nil,
        status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.cidr = cidr
        self.createdAt = createdAt
        self.dnsViewId = dnsViewId
        self.id = id
        self.ipAddressType = ipAddressType
        self.name = name
        self.`protocol` = `protocol`
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct GetAccessSourceInput: Swift.Sendable {
    /// The unique identifier of the access source to retrieve.
    /// This member is required.
    public var accessSourceId: Swift.String?

    public init(
        accessSourceId: Swift.String? = nil
    ) {
        self.accessSourceId = accessSourceId
    }
}

public struct GetAccessSourceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the access source.
    /// This member is required.
    public var arn: Swift.String?
    /// The IP range for the rule's parameters in CIDR notation.
    /// This member is required.
    public var cidr: Swift.String?
    /// The time and date the rule was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// ID for the DNS view that the rule is associated to.
    /// This member is required.
    public var dnsViewId: Swift.String?
    /// ID for the rule.
    /// This member is required.
    public var id: Swift.String?
    /// The IP address type.
    /// This member is required.
    public var ipAddressType: Route53GlobalResolverClientTypes.IpAddressType?
    /// Name for the access source.
    public var name: Swift.String?
    /// The protocol determines how data is transmitted to a Global Resolver instance.
    /// This member is required.
    public var `protocol`: Route53GlobalResolverClientTypes.DnsProtocol?
    /// Information about the status of the rule.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
    /// The time and date the access source was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        cidr: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        dnsViewId: Swift.String? = nil,
        id: Swift.String? = nil,
        ipAddressType: Route53GlobalResolverClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil,
        `protocol`: Route53GlobalResolverClientTypes.DnsProtocol? = nil,
        status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.cidr = cidr
        self.createdAt = createdAt
        self.dnsViewId = dnsViewId
        self.id = id
        self.ipAddressType = ipAddressType
        self.name = name
        self.`protocol` = `protocol`
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct ListAccessSourcesInput: Swift.Sendable {
    /// Values to filter the results.
    public var filters: [Swift.String: [Swift.String]]?
    /// The maximum number of results to retrieve in a single call.
    public var maxResults: Swift.Int?
    /// A pagination token used for large sets of results that can't be returned in a single response.
    public var nextToken: Swift.String?

    public init(
        filters: [Swift.String: [Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension Route53GlobalResolverClientTypes {

    /// Summary information about an access source.
    public struct AccessSourcesItem: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the access source.
        /// This member is required.
        public var arn: Swift.String?
        /// The CIDR block that defines the IP address range for the access source.
        /// This member is required.
        public var cidr: Swift.String?
        /// The date and time when the access source was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The ID of the DNS view that the access source is associated with.
        /// This member is required.
        public var dnsViewId: Swift.String?
        /// The unique identifier of the access source.
        /// This member is required.
        public var id: Swift.String?
        /// The IP address type of the access source.
        /// This member is required.
        public var ipAddressType: Route53GlobalResolverClientTypes.IpAddressType?
        /// The name of the access source.
        public var name: Swift.String?
        /// The protocol used by the access source.
        /// This member is required.
        public var `protocol`: Route53GlobalResolverClientTypes.DnsProtocol?
        /// The current status of the access source.
        /// This member is required.
        public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
        /// The date and time when the access source was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            cidr: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            dnsViewId: Swift.String? = nil,
            id: Swift.String? = nil,
            ipAddressType: Route53GlobalResolverClientTypes.IpAddressType? = nil,
            name: Swift.String? = nil,
            `protocol`: Route53GlobalResolverClientTypes.DnsProtocol? = nil,
            status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.cidr = cidr
            self.createdAt = createdAt
            self.dnsViewId = dnsViewId
            self.id = id
            self.ipAddressType = ipAddressType
            self.name = name
            self.`protocol` = `protocol`
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListAccessSourcesOutput: Swift.Sendable {
    /// An array containing information about the access sources, such as the ID, CIDR etc.
    /// This member is required.
    public var accessSources: [Route53GlobalResolverClientTypes.AccessSourcesItem]?
    /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
    public var nextToken: Swift.String?

    public init(
        accessSources: [Route53GlobalResolverClientTypes.AccessSourcesItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.accessSources = accessSources
        self.nextToken = nextToken
    }
}

public struct UpdateAccessSourceInput: Swift.Sendable {
    /// The unique identifier of the access source to update.
    /// This member is required.
    public var accessSourceId: Swift.String?
    /// The CIDR block for the access source.
    public var cidr: Swift.String?
    /// The IP address type for the access source.
    public var ipAddressType: Route53GlobalResolverClientTypes.IpAddressType?
    /// The name of the access source.
    public var name: Swift.String?
    /// The protocol for the access source.
    public var `protocol`: Route53GlobalResolverClientTypes.DnsProtocol?

    public init(
        accessSourceId: Swift.String? = nil,
        cidr: Swift.String? = nil,
        ipAddressType: Route53GlobalResolverClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil,
        `protocol`: Route53GlobalResolverClientTypes.DnsProtocol? = nil
    ) {
        self.accessSourceId = accessSourceId
        self.cidr = cidr
        self.ipAddressType = ipAddressType
        self.name = name
        self.`protocol` = `protocol`
    }
}

public struct UpdateAccessSourceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the updated access source.
    /// This member is required.
    public var arn: Swift.String?
    /// The CIDR block of the updated access source.
    /// This member is required.
    public var cidr: Swift.String?
    /// The date and time when the access source was originally created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The ID of the DNS view associated with the updated access source.
    /// This member is required.
    public var dnsViewId: Swift.String?
    /// The unique identifier of the updated access source.
    /// This member is required.
    public var id: Swift.String?
    /// The IP address type of the updated access source.
    /// This member is required.
    public var ipAddressType: Route53GlobalResolverClientTypes.IpAddressType?
    /// The name of the updated access source.
    public var name: Swift.String?
    /// The protocol of the updated access source.
    /// This member is required.
    public var `protocol`: Route53GlobalResolverClientTypes.DnsProtocol?
    /// The current status of the updated access source.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
    /// The date and time when the access source was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        cidr: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        dnsViewId: Swift.String? = nil,
        id: Swift.String? = nil,
        ipAddressType: Route53GlobalResolverClientTypes.IpAddressType? = nil,
        name: Swift.String? = nil,
        `protocol`: Route53GlobalResolverClientTypes.DnsProtocol? = nil,
        status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.cidr = cidr
        self.createdAt = createdAt
        self.dnsViewId = dnsViewId
        self.id = id
        self.ipAddressType = ipAddressType
        self.name = name
        self.`protocol` = `protocol`
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct CreateAccessTokenInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
    public var clientToken: Swift.String?
    /// The ID of the DNS view to associate with this token.
    /// This member is required.
    public var dnsViewId: Swift.String?
    /// The date and time when the token expires. Tokens can have a minimum expiration of 30 days and maximum of 365 days from creation.
    public var expiresAt: Foundation.Date?
    /// A descriptive name for the access token.
    public var name: Swift.String?
    /// An array of user-defined keys and optional values. These tags can be used for categorization and organization.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        dnsViewId: Swift.String? = nil,
        expiresAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.dnsViewId = dnsViewId
        self.expiresAt = expiresAt
        self.name = name
        self.tags = tags
    }
}

extension Route53GlobalResolverClientTypes {

    public enum TokenStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case operational
        case sdkUnknown(Swift.String)

        public static var allCases: [TokenStatus] {
            return [
                .creating,
                .deleting,
                .operational
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .operational: return "OPERATIONAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateAccessTokenOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the access token.
    /// This member is required.
    public var arn: Swift.String?
    /// The unique string that identifies the request and ensures idempotency.
    public var clientToken: Swift.String?
    /// The date and time when the access token was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The ID of the DNS view associated with this access token.
    /// This member is required.
    public var dnsViewId: Swift.String?
    /// The date and time when the access token expires.
    /// This member is required.
    public var expiresAt: Foundation.Date?
    /// The unique identifier for the access token.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the access token.
    public var name: Swift.String?
    /// The operational status of the access token.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.TokenStatus?
    /// The access token value. This token should be included in DoH and DoT requests for authentication. Keep this value secure as it provides access to your Route 53 Global Resolver.
    /// This member is required.
    public var value: Swift.String?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        dnsViewId: Swift.String? = nil,
        expiresAt: Foundation.Date? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.TokenStatus? = nil,
        value: Swift.String? = nil
    ) {
        self.arn = arn
        self.clientToken = clientToken
        self.createdAt = createdAt
        self.dnsViewId = dnsViewId
        self.expiresAt = expiresAt
        self.id = id
        self.name = name
        self.status = status
        self.value = value
    }
}

extension CreateAccessTokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAccessTokenOutput(arn: \(Swift.String(describing: arn)), clientToken: \(Swift.String(describing: clientToken)), createdAt: \(Swift.String(describing: createdAt)), dnsViewId: \(Swift.String(describing: dnsViewId)), expiresAt: \(Swift.String(describing: expiresAt)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), value: \"CONTENT_REDACTED\")"}
}

public struct DeleteAccessTokenInput: Swift.Sendable {
    /// The unique identifier of the access token to delete.
    /// This member is required.
    public var accessTokenId: Swift.String?

    public init(
        accessTokenId: Swift.String? = nil
    ) {
        self.accessTokenId = accessTokenId
    }
}

public struct DeleteAccessTokenOutput: Swift.Sendable {
    /// The date and time when the access token was deleted.
    /// This member is required.
    public var deletedAt: Foundation.Date?
    /// The unique identifier of the deleted access token.
    /// This member is required.
    public var id: Swift.String?
    /// The final status of the deleted access token.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.TokenStatus?

    public init(
        deletedAt: Foundation.Date? = nil,
        id: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.TokenStatus? = nil
    ) {
        self.deletedAt = deletedAt
        self.id = id
        self.status = status
    }
}

public struct GetAccessTokenInput: Swift.Sendable {
    /// ID of the token.
    /// This member is required.
    public var accessTokenId: Swift.String?

    public init(
        accessTokenId: Swift.String? = nil
    ) {
        self.accessTokenId = accessTokenId
    }
}

public struct GetAccessTokenOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the token.
    /// This member is required.
    public var arn: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
    public var clientToken: Swift.String?
    /// The time and date the token was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// ID of the DNS view the token is associated to.
    /// This member is required.
    public var dnsViewId: Swift.String?
    /// The token's expiration time and date.
    /// This member is required.
    public var expiresAt: Foundation.Date?
    /// ID of the Global Resolver.
    /// This member is required.
    public var globalResolverId: Swift.String?
    /// ID of the token.
    /// This member is required.
    public var id: Swift.String?
    /// Name of the token.
    public var name: Swift.String?
    /// The operational status of the token.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.TokenStatus?
    /// The time and date the token was created.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// The value of the token.
    /// This member is required.
    public var value: Swift.String?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        dnsViewId: Swift.String? = nil,
        expiresAt: Foundation.Date? = nil,
        globalResolverId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.TokenStatus? = nil,
        updatedAt: Foundation.Date? = nil,
        value: Swift.String? = nil
    ) {
        self.arn = arn
        self.clientToken = clientToken
        self.createdAt = createdAt
        self.dnsViewId = dnsViewId
        self.expiresAt = expiresAt
        self.globalResolverId = globalResolverId
        self.id = id
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
        self.value = value
    }
}

extension GetAccessTokenOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccessTokenOutput(arn: \(Swift.String(describing: arn)), clientToken: \(Swift.String(describing: clientToken)), createdAt: \(Swift.String(describing: createdAt)), dnsViewId: \(Swift.String(describing: dnsViewId)), expiresAt: \(Swift.String(describing: expiresAt)), globalResolverId: \(Swift.String(describing: globalResolverId)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), value: \"CONTENT_REDACTED\")"}
}

public struct ListAccessTokensInput: Swift.Sendable {
    /// The ID of the DNS view to list the tokens for.
    /// This member is required.
    public var dnsViewId: Swift.String?
    /// Filtering parameters.
    public var filters: [Swift.String: [Swift.String]]?
    /// The maximum number of results to retrieve in a single call.
    public var maxResults: Swift.Int?
    /// A pagination token used for large sets of results that can't be returned in a single response.
    public var nextToken: Swift.String?

    public init(
        dnsViewId: Swift.String? = nil,
        filters: [Swift.String: [Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.dnsViewId = dnsViewId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension Route53GlobalResolverClientTypes {

    /// Summary information about a token.
    public struct AccessTokenItem: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the token.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time when the token was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The ID of the DNS view associated with the token.
        /// This member is required.
        public var dnsViewId: Swift.String?
        /// The date and time when the token expires.
        /// This member is required.
        public var expiresAt: Foundation.Date?
        /// The ID of the global resolver associated with the token.
        /// This member is required.
        public var globalResolverId: Swift.String?
        /// The unique identifier of the token.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the token.
        public var name: Swift.String?
        /// The current status of the token.
        /// This member is required.
        public var status: Route53GlobalResolverClientTypes.TokenStatus?
        /// The date and time when the token was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            dnsViewId: Swift.String? = nil,
            expiresAt: Foundation.Date? = nil,
            globalResolverId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: Route53GlobalResolverClientTypes.TokenStatus? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.dnsViewId = dnsViewId
            self.expiresAt = expiresAt
            self.globalResolverId = globalResolverId
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListAccessTokensOutput: Swift.Sendable {
    /// List of the tokens.
    public var accessTokens: [Route53GlobalResolverClientTypes.AccessTokenItem]?
    /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
    public var nextToken: Swift.String?

    public init(
        accessTokens: [Route53GlobalResolverClientTypes.AccessTokenItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.accessTokens = accessTokens
        self.nextToken = nextToken
    }
}

public struct UpdateAccessTokenInput: Swift.Sendable {
    /// The ID of the token.
    /// This member is required.
    public var accessTokenId: Swift.String?
    /// The new name of the token.
    /// This member is required.
    public var name: Swift.String?

    public init(
        accessTokenId: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.accessTokenId = accessTokenId
        self.name = name
    }
}

public struct UpdateAccessTokenOutput: Swift.Sendable {
    /// The ID of the token.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the token.
    /// This member is required.
    public var name: Swift.String?

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.id = id
        self.name = name
    }
}

public struct AssociateHostedZoneInput: Swift.Sendable {
    /// The ID of the Route 53 private hosted zone to associate with the Route 53 Global Resolver resource.
    /// This member is required.
    public var hostedZoneId: Swift.String?
    /// Name for the private hosted zone association.
    /// This member is required.
    public var name: Swift.String?
    /// An Amazon Resource Name (ARN) of the Route 53 Global Resolver the private hosted zone will be associated to.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        hostedZoneId: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    ) {
        self.hostedZoneId = hostedZoneId
        self.name = name
        self.resourceArn = resourceArn
    }
}

extension Route53GlobalResolverClientTypes {

    public enum HostedZoneAssociationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case operational
        case sdkUnknown(Swift.String)

        public static var allCases: [HostedZoneAssociationStatus] {
            return [
                .creating,
                .deleting,
                .operational
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .operational: return "OPERATIONAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AssociateHostedZoneOutput: Swift.Sendable {
    /// The date and time the private hosted zone association was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// ID of the private hosted zone.
    /// This member is required.
    public var hostedZoneId: Swift.String?
    /// Name of the hosted zone (also the domain associated with the hosted zone).
    /// This member is required.
    public var hostedZoneName: Swift.String?
    /// ID of the association.
    /// This member is required.
    public var id: Swift.String?
    /// Name for the private hosted zone association.
    /// This member is required.
    public var name: Swift.String?
    /// An Amazon Resource Name (ARN) of the Route 53 Global Resolver the private hosted zone is associated to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Aggregate status for all the AWS Regions in which the Route 53 Global Resolver exists.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.HostedZoneAssociationStatus?
    /// The date and time the private hosted zone association was modified.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        hostedZoneId: Swift.String? = nil,
        hostedZoneName: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.HostedZoneAssociationStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.createdAt = createdAt
        self.hostedZoneId = hostedZoneId
        self.hostedZoneName = hostedZoneName
        self.id = id
        self.name = name
        self.resourceArn = resourceArn
        self.status = status
        self.updatedAt = updatedAt
    }
}

extension Route53GlobalResolverClientTypes {

    public enum FirewallRuleAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case alert
        case allow
        case block
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallRuleAction] {
            return [
                .alert,
                .allow,
                .block
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alert: return "ALERT"
            case .allow: return "ALLOW"
            case .block: return "BLOCK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53GlobalResolverClientTypes {

    public enum BlockOverrideDnsQueryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cname
        case sdkUnknown(Swift.String)

        public static var allCases: [BlockOverrideDnsQueryType] {
            return [
                .cname
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cname: return "CNAME"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53GlobalResolverClientTypes {

    public enum FirewallBlockResponse: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case nodata
        case nxdomain
        case `override`
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallBlockResponse] {
            return [
                .nodata,
                .nxdomain,
                .override
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .nodata: return "NODATA"
            case .nxdomain: return "NXDOMAIN"
            case .override: return "OVERRIDE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53GlobalResolverClientTypes {

    public enum ConfidenceThreshold: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfidenceThreshold] {
            return [
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53GlobalResolverClientTypes {

    public enum DnsAdvancedProtection: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dga
        case dnsTunneling
        case sdkUnknown(Swift.String)

        public static var allCases: [DnsAdvancedProtection] {
            return [
                .dga,
                .dnsTunneling
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dga: return "DGA"
            case .dnsTunneling: return "DNS_TUNNELING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53GlobalResolverClientTypes {

    /// Information about a DNS Firewall rule to create in a batch operation.
    public struct BatchCreateFirewallRuleInputItem: Swift.Sendable {
        /// The action to take when a DNS query matches the firewall rule.
        /// This member is required.
        public var action: Route53GlobalResolverClientTypes.FirewallRuleAction?
        /// The DNS record type for the custom response when the action is BLOCK.
        public var blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType?
        /// The custom domain name for the BLOCK response.
        public var blockOverrideDomain: Swift.String?
        /// The TTL value for the custom response when the action is BLOCK.
        public var blockOverrideTtl: Swift.Int?
        /// The type of block response to return when the action is BLOCK.
        public var blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse?
        /// A unique string that identifies the request and ensures idempotency.
        /// This member is required.
        public var clientToken: Swift.String?
        /// The confidence threshold for advanced threat detection.
        public var confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold?
        /// A description of the firewall rule.
        public var description: Swift.String?
        /// Whether to enable advanced DNS threat protection for the firewall rule.
        public var dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection?
        /// The ID of the DNS view to associate the firewall rule with.
        /// This member is required.
        public var dnsViewId: Swift.String?
        /// The ID of the firewall domain list to associate with the rule.
        public var firewallDomainListId: Swift.String?
        /// A name for the firewall rule.
        /// This member is required.
        public var name: Swift.String?
        /// The priority of the firewall rule.
        public var priority: Swift.Int?
        /// The DNS query type that the firewall rule should match.
        public var qType: Swift.String?

        public init(
            action: Route53GlobalResolverClientTypes.FirewallRuleAction? = nil,
            blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType? = nil,
            blockOverrideDomain: Swift.String? = nil,
            blockOverrideTtl: Swift.Int? = nil,
            blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse? = nil,
            clientToken: Swift.String? = nil,
            confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold? = nil,
            description: Swift.String? = nil,
            dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection? = nil,
            dnsViewId: Swift.String? = nil,
            firewallDomainListId: Swift.String? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            qType: Swift.String? = nil
        ) {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.clientToken = clientToken
            self.confidenceThreshold = confidenceThreshold
            self.description = description
            self.dnsAdvancedProtection = dnsAdvancedProtection
            self.dnsViewId = dnsViewId
            self.firewallDomainListId = firewallDomainListId
            self.name = name
            self.priority = priority
            self.qType = qType
        }
    }
}

public struct BatchCreateFirewallRuleInput: Swift.Sendable {
    /// The BatchCreateFirewallRuleInputItem objects contain the information for each Firewall rule.
    /// This member is required.
    public var firewallRules: [Route53GlobalResolverClientTypes.BatchCreateFirewallRuleInputItem]?

    public init(
        firewallRules: [Route53GlobalResolverClientTypes.BatchCreateFirewallRuleInputItem]? = nil
    ) {
        self.firewallRules = firewallRules
    }
}

extension Route53GlobalResolverClientTypes {

    /// The result of creating a firewall rule in a batch operation.
    public struct BatchCreateFirewallRuleResult: Swift.Sendable {
        /// The action configured for the created firewall rule.
        /// This member is required.
        public var action: Route53GlobalResolverClientTypes.FirewallRuleAction?
        /// The DNS record type configured for the created firewall rule's custom response.
        public var blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType?
        /// The custom domain name configured for the created firewall rule's BLOCK response.
        public var blockOverrideDomain: Swift.String?
        /// The TTL value configured for the created firewall rule's custom response.
        public var blockOverrideTtl: Swift.Int?
        /// The type of block response configured for the created firewall rule.
        public var blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse?
        /// The unique string that identified the request and ensured idempotency.
        /// This member is required.
        public var clientToken: Swift.String?
        /// The confidence threshold configured for the created firewall rule's advanced threat detection.
        public var confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold?
        /// The date and time when the firewall rule was created.
        public var createdAt: Foundation.Date?
        /// The description of the created firewall rule.
        public var description: Swift.String?
        /// Whether advanced DNS threat protection is enabled for the created firewall rule.
        public var dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection?
        /// The ID of the DNS view associated with the created firewall rule.
        /// This member is required.
        public var dnsViewId: Swift.String?
        /// The ID of the firewall domain list associated with the created firewall rule.
        public var firewallDomainListId: Swift.String?
        /// The unique identifier of the created firewall rule.
        public var id: Swift.String?
        /// The name of the managed domain list associated with the created firewall rule.
        public var managedDomainListName: Swift.String?
        /// The name of the created firewall rule.
        /// This member is required.
        public var name: Swift.String?
        /// The priority of the created firewall rule.
        public var priority: Swift.Int?
        /// The DNS query type that the created firewall rule matches.
        public var queryType: Swift.String?
        /// The current status of the created firewall rule.
        public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
        /// The date and time when the firewall rule was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            action: Route53GlobalResolverClientTypes.FirewallRuleAction? = nil,
            blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType? = nil,
            blockOverrideDomain: Swift.String? = nil,
            blockOverrideTtl: Swift.Int? = nil,
            blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse? = nil,
            clientToken: Swift.String? = nil,
            confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection? = nil,
            dnsViewId: Swift.String? = nil,
            firewallDomainListId: Swift.String? = nil,
            id: Swift.String? = nil,
            managedDomainListName: Swift.String? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            queryType: Swift.String? = nil,
            status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.clientToken = clientToken
            self.confidenceThreshold = confidenceThreshold
            self.createdAt = createdAt
            self.description = description
            self.dnsAdvancedProtection = dnsAdvancedProtection
            self.dnsViewId = dnsViewId
            self.firewallDomainListId = firewallDomainListId
            self.id = id
            self.managedDomainListName = managedDomainListName
            self.name = name
            self.priority = priority
            self.queryType = queryType
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

extension Route53GlobalResolverClientTypes {

    /// Information about the result of creating a DNS Firewall rule in a batch operation.
    public struct BatchCreateFirewallRuleOutputItem: Swift.Sendable {
        /// The HTTP response code for the batch operation result.
        /// This member is required.
        public var code: Swift.Int?
        /// The firewall rule that was created in the batch operation.
        /// This member is required.
        public var firewallRule: Route53GlobalResolverClientTypes.BatchCreateFirewallRuleResult?
        /// A message describing the result of the batch operation, including error details if applicable.
        public var message: Swift.String?

        public init(
            code: Swift.Int? = nil,
            firewallRule: Route53GlobalResolverClientTypes.BatchCreateFirewallRuleResult? = nil,
            message: Swift.String? = nil
        ) {
            self.code = code
            self.firewallRule = firewallRule
            self.message = message
        }
    }
}

public struct BatchCreateFirewallRuleOutput: Swift.Sendable {
    /// High level information about the DNS Firewall rules that failed to create.
    /// This member is required.
    public var failures: [Route53GlobalResolverClientTypes.BatchCreateFirewallRuleOutputItem]?
    /// High level information about the DNS Firewall rules that were created.
    /// This member is required.
    public var successes: [Route53GlobalResolverClientTypes.BatchCreateFirewallRuleOutputItem]?

    public init(
        failures: [Route53GlobalResolverClientTypes.BatchCreateFirewallRuleOutputItem]? = nil,
        successes: [Route53GlobalResolverClientTypes.BatchCreateFirewallRuleOutputItem]? = nil
    ) {
        self.failures = failures
        self.successes = successes
    }
}

extension Route53GlobalResolverClientTypes {

    /// Information about a DNS Firewall rule to delete in a batch operation.
    public struct BatchDeleteFirewallRuleInputItem: Swift.Sendable {
        /// The ID of the DNS Firewall rule to delete.
        /// This member is required.
        public var firewallRuleId: Swift.String?

        public init(
            firewallRuleId: Swift.String? = nil
        ) {
            self.firewallRuleId = firewallRuleId
        }
    }
}

public struct BatchDeleteFirewallRuleInput: Swift.Sendable {
    /// An array of the DNS Firewall IDs to be deleted.
    /// This member is required.
    public var firewallRules: [Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleInputItem]?

    public init(
        firewallRules: [Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleInputItem]? = nil
    ) {
        self.firewallRules = firewallRules
    }
}

extension Route53GlobalResolverClientTypes {

    /// Information about a firewall rule that was deleted in a batch operation.
    public struct BatchDeleteFirewallRuleResult: Swift.Sendable {
        /// The unique string that identified the request and ensured idempotency.
        public var clientToken: Swift.String?
        /// The unique identifier of the deleted firewall rule.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the deleted firewall rule.
        public var name: Swift.String?
        /// The final status of the deleted firewall rule.
        public var status: Route53GlobalResolverClientTypes.CRResourceStatus?

        public init(
            clientToken: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil
        ) {
            self.clientToken = clientToken
            self.id = id
            self.name = name
            self.status = status
        }
    }
}

extension Route53GlobalResolverClientTypes {

    /// The result of deleting a firewall rule in a batch operation.
    public struct BatchDeleteFirewallRuleOutputItem: Swift.Sendable {
        /// The response code for the delete operation.
        /// This member is required.
        public var code: Swift.Int?
        /// The firewall rule that was deleted in the batch operation.
        /// This member is required.
        public var firewallRule: Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleResult?
        /// The response message for the delete operation.
        public var message: Swift.String?

        public init(
            code: Swift.Int? = nil,
            firewallRule: Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleResult? = nil,
            message: Swift.String? = nil
        ) {
            self.code = code
            self.firewallRule = firewallRule
            self.message = message
        }
    }
}

public struct BatchDeleteFirewallRuleOutput: Swift.Sendable {
    /// High level information about the DNS Firewall rules that failed to delete.
    /// This member is required.
    public var failures: [Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleOutputItem]?
    /// High level information about the DNS Firewall rules that were deleted successfully.
    /// This member is required.
    public var successes: [Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleOutputItem]?

    public init(
        failures: [Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleOutputItem]? = nil,
        successes: [Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleOutputItem]? = nil
    ) {
        self.failures = failures
        self.successes = successes
    }
}

extension Route53GlobalResolverClientTypes {

    /// Information for updating a firewall rule in a batch operation.
    public struct BatchUpdateFirewallRuleInputItem: Swift.Sendable {
        /// The action to take when a DNS query matches the firewall rule.
        public var action: Route53GlobalResolverClientTypes.FirewallRuleAction?
        /// The DNS record type for the custom response when the action is BLOCK.
        public var blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType?
        /// The custom domain name for the BLOCK response.
        public var blockOverrideDomain: Swift.String?
        /// The TTL value for the custom response when the action is BLOCK.
        public var blockOverrideTtl: Swift.Int?
        /// The type of block response to return when the action is BLOCK.
        public var blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse?
        /// The confidence threshold for advanced threat detection.
        public var confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold?
        /// A description of the firewall rule.
        public var description: Swift.String?
        /// Whether to enable advanced DNS threat protection for the firewall rule.
        public var dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection?
        /// The unique identifier of the firewall rule to update.
        /// This member is required.
        public var firewallRuleId: Swift.String?
        /// A name for the firewall rule.
        public var name: Swift.String?
        /// The priority of the firewall rule.
        public var priority: Swift.Int?

        public init(
            action: Route53GlobalResolverClientTypes.FirewallRuleAction? = nil,
            blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType? = nil,
            blockOverrideDomain: Swift.String? = nil,
            blockOverrideTtl: Swift.Int? = nil,
            blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse? = nil,
            confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold? = nil,
            description: Swift.String? = nil,
            dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection? = nil,
            firewallRuleId: Swift.String? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil
        ) {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.confidenceThreshold = confidenceThreshold
            self.description = description
            self.dnsAdvancedProtection = dnsAdvancedProtection
            self.firewallRuleId = firewallRuleId
            self.name = name
            self.priority = priority
        }
    }
}

public struct BatchUpdateFirewallRuleInput: Swift.Sendable {
    /// The DNS Firewall rule IDs to be updated.
    /// This member is required.
    public var firewallRules: [Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleInputItem]?

    public init(
        firewallRules: [Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleInputItem]? = nil
    ) {
        self.firewallRules = firewallRules
    }
}

extension Route53GlobalResolverClientTypes {

    /// Information about a firewall rule that was updated in a batch operation.
    public struct BatchUpdateFirewallRuleResult: Swift.Sendable {
        /// The action configured for the updated firewall rule.
        public var action: Route53GlobalResolverClientTypes.FirewallRuleAction?
        /// The DNS record type configured for the updated firewall rule's custom response.
        public var blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType?
        /// The custom domain name configured for the updated firewall rule's BLOCK response.
        public var blockOverrideDomain: Swift.String?
        /// The TTL value configured for the updated firewall rule's custom response.
        public var blockOverrideTtl: Swift.Int?
        /// The type of block response configured for the updated firewall rule.
        public var blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse?
        /// The unique string that identified the request and ensured idempotency.
        public var clientToken: Swift.String?
        /// The confidence threshold configured for the updated firewall rule's advanced threat detection.
        public var confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold?
        /// The date and time when the firewall rule was originally created.
        public var createdAt: Foundation.Date?
        /// The description of the updated firewall rule.
        public var description: Swift.String?
        /// Whether advanced DNS threat protection is enabled for the updated firewall rule.
        public var dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection?
        /// The ID of the DNS view associated with the updated firewall rule.
        public var dnsViewId: Swift.String?
        /// The ID of the firewall domain list associated with the updated firewall rule.
        public var firewallDomainListId: Swift.String?
        /// The unique identifier of the updated firewall rule.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the updated firewall rule.
        public var name: Swift.String?
        /// The priority of the updated firewall rule.
        public var priority: Swift.Int?
        /// The DNS query type that the updated firewall rule matches.
        public var queryType: Swift.String?
        /// The current status of the updated firewall rule.
        public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
        /// The date and time when the firewall rule was last updated.
        public var updatedAt: Foundation.Date?

        public init(
            action: Route53GlobalResolverClientTypes.FirewallRuleAction? = nil,
            blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType? = nil,
            blockOverrideDomain: Swift.String? = nil,
            blockOverrideTtl: Swift.Int? = nil,
            blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse? = nil,
            clientToken: Swift.String? = nil,
            confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection? = nil,
            dnsViewId: Swift.String? = nil,
            firewallDomainListId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            queryType: Swift.String? = nil,
            status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.clientToken = clientToken
            self.confidenceThreshold = confidenceThreshold
            self.createdAt = createdAt
            self.description = description
            self.dnsAdvancedProtection = dnsAdvancedProtection
            self.dnsViewId = dnsViewId
            self.firewallDomainListId = firewallDomainListId
            self.id = id
            self.name = name
            self.priority = priority
            self.queryType = queryType
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

extension Route53GlobalResolverClientTypes {

    /// The result of updating a firewall rule in a batch operation.
    public struct BatchUpdateFirewallRuleOutputItem: Swift.Sendable {
        /// The response code for the update operation.
        /// This member is required.
        public var code: Swift.Int?
        /// The firewall rule that was updated in the batch operation.
        /// This member is required.
        public var firewallRule: Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleResult?
        /// The response message for the update operation.
        public var message: Swift.String?

        public init(
            code: Swift.Int? = nil,
            firewallRule: Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleResult? = nil,
            message: Swift.String? = nil
        ) {
            self.code = code
            self.firewallRule = firewallRule
            self.message = message
        }
    }
}

public struct BatchUpdateFirewallRuleOutput: Swift.Sendable {
    /// High level information about the DNS Firewall rules that failed to update.
    /// This member is required.
    public var failures: [Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleOutputItem]?
    /// High level information about the DNS Firewall rules that were successfully updated.
    /// This member is required.
    public var successes: [Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleOutputItem]?

    public init(
        failures: [Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleOutputItem]? = nil,
        successes: [Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleOutputItem]? = nil
    ) {
        self.failures = failures
        self.successes = successes
    }
}

extension Route53GlobalResolverClientTypes {

    public enum DnsSecValidationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DnsSecValidationType] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53GlobalResolverClientTypes {

    public enum EdnsClientSubnetType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EdnsClientSubnetType] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension Route53GlobalResolverClientTypes {

    public enum FirewallRulesFailOpenType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [FirewallRulesFailOpenType] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDNSViewInput: Swift.Sendable {
    /// A unique string that identifies the request and ensures idempotency.
    public var clientToken: Swift.String?
    /// An optional description for the DNS view.
    public var description: Swift.String?
    /// Whether to enable DNSSEC validation for DNS queries in this DNS view. When enabled, the resolver verifies the authenticity and integrity of DNS responses from public name servers for DNSSEC-signed domains.
    public var dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType?
    /// Whether to enable EDNS Client Subnet injection for DNS queries in this DNS view. When enabled, client subnet information is forwarded to provide more accurate geographic-based DNS responses.
    public var ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType?
    /// Determines the behavior when Route 53 Global Resolver cannot apply DNS firewall rules due to service impairment. When enabled, DNS queries are allowed through; when disabled, queries are blocked.
    public var firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType?
    /// The ID of the Route 53 Global Resolver to associate with this DNS view.
    /// This member is required.
    public var globalResolverId: Swift.String?
    /// A descriptive name for the DNS view.
    /// This member is required.
    public var name: Swift.String?
    /// Tags to associate with the DNS view.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType? = nil,
        ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType? = nil,
        firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType? = nil,
        globalResolverId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.dnssecValidation = dnssecValidation
        self.ednsClientSubnet = ednsClientSubnet
        self.firewallRulesFailOpen = firewallRulesFailOpen
        self.globalResolverId = globalResolverId
        self.name = name
        self.tags = tags
    }
}

extension Route53GlobalResolverClientTypes {

    public enum ProfileResourceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creating
        case deleting
        case disabled
        case disabling
        case enabling
        case operational
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [ProfileResourceStatus] {
            return [
                .creating,
                .deleting,
                .disabled,
                .disabling,
                .enabling,
                .operational,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .disabled: return "DISABLED"
            case .disabling: return "DISABLING"
            case .enabling: return "ENABLING"
            case .operational: return "OPERATIONAL"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateDNSViewOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the DNS view.
    /// This member is required.
    public var arn: Swift.String?
    /// The unique string that identifies the request and ensures idempotency.
    public var clientToken: Swift.String?
    /// The date and time when the DNS view was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the DNS view.
    public var description: Swift.String?
    /// Whether DNSSEC validation is enabled for DNS queries in this DNS view.
    /// This member is required.
    public var dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType?
    /// Whether EDNS Client Subnet injection is enabled for DNS queries in this DNS view.
    /// This member is required.
    public var ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType?
    /// The behavior when Route 53 Global Resolver cannot apply DNS firewall rules due to service impairment.
    /// This member is required.
    public var firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType?
    /// The ID of the Route 53 Global Resolver instance the DNS view is created for.
    /// This member is required.
    public var globalResolverId: Swift.String?
    /// The unique identifier for the DNS view.
    /// This member is required.
    public var id: Swift.String?
    /// The descriptive name of the DNS view.
    /// This member is required.
    public var name: Swift.String?
    /// The operational status of the DNS view.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.ProfileResourceStatus?
    /// The date and time when the DNS view was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType? = nil,
        ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType? = nil,
        firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType? = nil,
        globalResolverId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.ProfileResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.clientToken = clientToken
        self.createdAt = createdAt
        self.description = description
        self.dnssecValidation = dnssecValidation
        self.ednsClientSubnet = ednsClientSubnet
        self.firewallRulesFailOpen = firewallRulesFailOpen
        self.globalResolverId = globalResolverId
        self.id = id
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct CreateFirewallDomainListInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
    public var clientToken: Swift.String?
    /// An optional description for the firewall domain list.
    public var description: Swift.String?
    /// The ID of the Route 53 Global Resolver that the domain list will be associated with.
    /// This member is required.
    public var globalResolverId: Swift.String?
    /// A descriptive name for the firewall domain list.
    /// This member is required.
    public var name: Swift.String?
    /// An array of user-defined keys and optional values. These tags can be used for categorization and organization.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        globalResolverId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.globalResolverId = globalResolverId
        self.name = name
        self.tags = tags
    }
}

public struct CreateFirewallDomainListOutput: Swift.Sendable {
    /// An Amazon Resource Name (ARN) for the domain list.
    /// This member is required.
    public var arn: Swift.String?
    /// The time and date the domain list was created on.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Description for the domain list.
    public var description: Swift.String?
    /// Number of domains in the domain list.
    /// This member is required.
    public var domainCount: Swift.Int?
    /// The ID of the Route 53 Global Resolver that the domain list is associated with.
    /// This member is required.
    public var globalResolverId: Swift.String?
    /// ID of the domain list.
    /// This member is required.
    public var id: Swift.String?
    /// Name of the domain list.
    /// This member is required.
    public var name: Swift.String?
    /// Creation status of the domain list.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
    /// The time and date the domain list was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        domainCount: Swift.Int? = nil,
        globalResolverId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.domainCount = domainCount
        self.globalResolverId = globalResolverId
        self.id = id
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct CreateFirewallRuleInput: Swift.Sendable {
    /// The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list:
    ///
    /// * ALLOW - Permit the request to go through.
    ///
    /// * ALERT - Permit the request and send metrics and logs to CloudWatch.
    ///
    /// * BLOCK - Disallow the request. This option requires additional details in the rule's BlockResponse.
    /// This member is required.
    public var action: Route53GlobalResolverClientTypes.FirewallRuleAction?
    /// The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    public var blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType?
    /// The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    public var blockOverrideDomain: Swift.String?
    /// The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE. This setting is required if the BlockResponse setting is OVERRIDE.
    public var blockOverrideTtl: Swift.Int?
    /// The response to return when the action is BLOCK. Valid values are NXDOMAIN (domain does not exist), NODATA (domain exists but no records), or OVERRIDE (return custom response).
    public var blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse?
    /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
    public var clientToken: Swift.String?
    /// The confidence threshold for advanced threat detection. Valid values are HIGH, MEDIUM, or LOW, indicating the accuracy level required for threat detection.
    public var confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold?
    /// An optional description for the firewall rule.
    public var description: Swift.String?
    /// Whether to enable advanced DNS threat protection for this rule. Advanced protection can detect and block DNS tunneling and Domain Generation Algorithm (DGA) threats.
    public var dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection?
    /// The ID of the DNS view to associate with this firewall rule.
    /// This member is required.
    public var dnsViewId: Swift.String?
    /// The ID of the firewall domain list to use in this rule.
    public var firewallDomainListId: Swift.String?
    /// A descriptive name for the firewall rule.
    /// This member is required.
    public var name: Swift.String?
    /// The priority of this rule. Rules are evaluated in priority order, with lower numbers having higher priority. When a DNS query matches multiple rules, the rule with the highest priority (lowest number) is applied.
    public var priority: Swift.Int?
    /// The DNS query type to match for this rule. Examples include A (IPv4 address), AAAA (IPv6 address), MX (mail exchange), or TXT (text record).
    public var qType: Swift.String?

    public init(
        action: Route53GlobalResolverClientTypes.FirewallRuleAction? = nil,
        blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType? = nil,
        blockOverrideDomain: Swift.String? = nil,
        blockOverrideTtl: Swift.Int? = nil,
        blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse? = nil,
        clientToken: Swift.String? = nil,
        confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold? = nil,
        description: Swift.String? = nil,
        dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection? = nil,
        dnsViewId: Swift.String? = nil,
        firewallDomainListId: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        qType: Swift.String? = nil
    ) {
        self.action = action
        self.blockOverrideDnsType = blockOverrideDnsType
        self.blockOverrideDomain = blockOverrideDomain
        self.blockOverrideTtl = blockOverrideTtl
        self.blockResponse = blockResponse
        self.clientToken = clientToken
        self.confidenceThreshold = confidenceThreshold
        self.description = description
        self.dnsAdvancedProtection = dnsAdvancedProtection
        self.dnsViewId = dnsViewId
        self.firewallDomainListId = firewallDomainListId
        self.name = name
        self.priority = priority
        self.qType = qType
    }
}

public struct CreateFirewallRuleOutput: Swift.Sendable {
    /// The action that DNS Firewall takes on DNS queries that match this rule.
    /// This member is required.
    public var action: Route53GlobalResolverClientTypes.FirewallRuleAction?
    /// The DNS record type for the custom response when blockResponse is OVERRIDE.
    public var blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType?
    /// The custom domain to return when the action is BLOCK and blockResponse is OVERRIDE.
    public var blockOverrideDomain: Swift.String?
    /// The time-to-live (TTL) value for the custom response when blockResponse is OVERRIDE.
    public var blockOverrideTtl: Swift.Int?
    /// The response to return when the action is BLOCK.
    public var blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse?
    /// The confidence threshold for advanced threat detection.
    public var confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold?
    /// The date and time when the firewall rule was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the firewall rule.
    public var description: Swift.String?
    /// Whether advanced DNS threat protection is enabled for this rule.
    public var dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection?
    /// The ID of the DNS view associated with this firewall rule.
    /// This member is required.
    public var dnsViewId: Swift.String?
    /// The ID of the firewall domain list used in this rule.
    public var firewallDomainListId: Swift.String?
    /// The unique identifier for the firewall rule.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the firewall rule.
    /// This member is required.
    public var name: Swift.String?
    /// The priority of the firewall rule.
    /// This member is required.
    public var priority: Swift.Int?
    /// The DNS query type that this rule matches.
    public var queryType: Swift.String?
    /// The operational status of the firewall rule.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
    /// The date and time when the firewall rule was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        action: Route53GlobalResolverClientTypes.FirewallRuleAction? = nil,
        blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType? = nil,
        blockOverrideDomain: Swift.String? = nil,
        blockOverrideTtl: Swift.Int? = nil,
        blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse? = nil,
        confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection? = nil,
        dnsViewId: Swift.String? = nil,
        firewallDomainListId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        queryType: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.action = action
        self.blockOverrideDnsType = blockOverrideDnsType
        self.blockOverrideDomain = blockOverrideDomain
        self.blockOverrideTtl = blockOverrideTtl
        self.blockResponse = blockResponse
        self.confidenceThreshold = confidenceThreshold
        self.createdAt = createdAt
        self.description = description
        self.dnsAdvancedProtection = dnsAdvancedProtection
        self.dnsViewId = dnsViewId
        self.firewallDomainListId = firewallDomainListId
        self.id = id
        self.name = name
        self.priority = priority
        self.queryType = queryType
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct CreateGlobalResolverInput: Swift.Sendable {
    /// A unique string that identifies the request and ensures idempotency. If you make multiple requests with the same client token, only one Route 53 Global Resolver is created.
    public var clientToken: Swift.String?
    /// An optional description for the Route 53 Global Resolver instance. Maximum length of 1024 characters.
    public var description: Swift.String?
    /// A descriptive name for the Route 53 Global Resolver instance. Maximum length of 64 characters.
    /// This member is required.
    public var name: Swift.String?
    /// The AWS region where query resolution logs and metrics will be aggregated and delivered. If not specified, logging is not enabled.
    public var observabilityRegion: Swift.String?
    /// List of AWS regions where the Route 53 Global Resolver will operate. The resolver will be distributed across these regions to provide global availability and low-latency DNS resolution.
    /// This member is required.
    public var regions: [Swift.String]?
    /// Tags to associate with the Route 53 Global Resolver. Tags are key-value pairs that help you organize and identify your resources.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        observabilityRegion: Swift.String? = nil,
        regions: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.observabilityRegion = observabilityRegion
        self.regions = regions
        self.tags = tags
    }
}

public struct CreateGlobalResolverOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Route 53 Global Resolver.
    /// This member is required.
    public var arn: Swift.String?
    /// The unique string that identifies the request and ensures idempotency.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The date and time when the Route 53 Global Resolver was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the Route 53 Global Resolver.
    public var description: Swift.String?
    /// The hostname that DNS clients should use for TLS certificate validation when connecting to the Route 53 Global Resolver. This value resolves to the global anycast IP addresses for the resolver.
    /// This member is required.
    public var dnsName: Swift.String?
    /// The unique identifier for the Route 53 Global Resolver.
    /// This member is required.
    public var id: Swift.String?
    /// The global anycast IPv4 addresses associated with the Route 53 Global Resolver. DNS clients can send queries to these addresses from anywhere on the internet.
    /// This member is required.
    public var ipv4Addresses: [Swift.String]?
    /// The name of the Route 53 Global Resolver.
    /// This member is required.
    public var name: Swift.String?
    /// The AWS Region where observability data for the Route 53 Global Resolver is stored.
    public var observabilityRegion: Swift.String?
    /// The AWS Regions where the Route 53 Global Resolver is deployed and operational.
    /// This member is required.
    public var regions: [Swift.String]?
    /// The current status of the Route 53 Global Resolver. Possible values are CREATING (being provisioned), UPDATING (being modified), OPERATIONAL (ready to serve queries), or DELETING (being removed).
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
    /// The date and time when the Route 53 Global Resolver was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        dnsName: Swift.String? = nil,
        id: Swift.String? = nil,
        ipv4Addresses: [Swift.String]? = nil,
        name: Swift.String? = nil,
        observabilityRegion: Swift.String? = nil,
        regions: [Swift.String]? = nil,
        status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.clientToken = clientToken
        self.createdAt = createdAt
        self.description = description
        self.dnsName = dnsName
        self.id = id
        self.ipv4Addresses = ipv4Addresses
        self.name = name
        self.observabilityRegion = observabilityRegion
        self.regions = regions
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct DeleteDNSViewInput: Swift.Sendable {
    /// The unique identifier of the DNS view to delete.
    /// This member is required.
    public var dnsViewId: Swift.String?

    public init(
        dnsViewId: Swift.String? = nil
    ) {
        self.dnsViewId = dnsViewId
    }
}

public struct DeleteDNSViewOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the deleted DNS view.
    /// This member is required.
    public var arn: Swift.String?
    /// The unique string that identifies the request and ensures idempotency.
    public var clientToken: Swift.String?
    /// The date and time when the DNS view was originally created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the deleted DNS view.
    public var description: Swift.String?
    /// Whether DNSSEC validation was enabled for the deleted DNS view.
    /// This member is required.
    public var dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType?
    /// Whether EDNS Client Subnet injection was enabled for the deleted DNS view.
    /// This member is required.
    public var ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType?
    /// The firewall rules fail-open behavior that was configured for the deleted DNS view.
    /// This member is required.
    public var firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType?
    /// The ID of the Route 53 Global Resolver that the deleted DNS view was associated with.
    /// This member is required.
    public var globalResolverId: Swift.String?
    /// The unique identifier of the deleted DNS view.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the deleted DNS view.
    /// This member is required.
    public var name: Swift.String?
    /// The final status of the deleted DNS view.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.ProfileResourceStatus?
    /// The date and time when the DNS view was last updated before deletion.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType? = nil,
        ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType? = nil,
        firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType? = nil,
        globalResolverId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.ProfileResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.clientToken = clientToken
        self.createdAt = createdAt
        self.description = description
        self.dnssecValidation = dnssecValidation
        self.ednsClientSubnet = ednsClientSubnet
        self.firewallRulesFailOpen = firewallRulesFailOpen
        self.globalResolverId = globalResolverId
        self.id = id
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct DeleteFirewallDomainListInput: Swift.Sendable {
    /// The unique identifier of the firewall domain list to delete.
    /// This member is required.
    public var firewallDomainListId: Swift.String?

    public init(
        firewallDomainListId: Swift.String? = nil
    ) {
        self.firewallDomainListId = firewallDomainListId
    }
}

public struct DeleteFirewallDomainListOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the deleted firewall domain list.
    /// This member is required.
    public var arn: Swift.String?
    /// The unique identifier of the deleted firewall domain list.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the deleted firewall domain list.
    /// This member is required.
    public var name: Swift.String?
    /// The final status of the deleted firewall domain list.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.CRResourceStatus?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil
    ) {
        self.arn = arn
        self.id = id
        self.name = name
        self.status = status
    }
}

public struct DeleteFirewallRuleInput: Swift.Sendable {
    /// The unique identifier of the firewall rule to delete.
    /// This member is required.
    public var firewallRuleId: Swift.String?

    public init(
        firewallRuleId: Swift.String? = nil
    ) {
        self.firewallRuleId = firewallRuleId
    }
}

public struct DeleteFirewallRuleOutput: Swift.Sendable {
    /// The action that was configured for the deleted firewall rule.
    /// This member is required.
    public var action: Route53GlobalResolverClientTypes.FirewallRuleAction?
    /// The DNS record type that was configured for the deleted firewall rule's custom response.
    public var blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType?
    /// The custom domain that was configured for the deleted firewall rule's BLOCK response.
    public var blockOverrideDomain: Swift.String?
    /// The TTL value that was configured for the deleted firewall rule's custom response.
    public var blockOverrideTtl: Swift.Int?
    /// The block response type that was configured for the deleted firewall rule.
    public var blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse?
    /// The confidence threshold that was configured for the deleted firewall rule's advanced threat detection.
    public var confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold?
    /// The date and time when the firewall rule was originally created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the deleted firewall rule.
    public var description: Swift.String?
    /// Whether advanced DNS threat protection was enabled for the deleted firewall rule.
    public var dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection?
    /// The ID of the DNS view that was associated with the deleted firewall rule.
    /// This member is required.
    public var dnsViewId: Swift.String?
    /// The ID of the firewall domain list that was associated with the deleted firewall rule.
    public var firewallDomainListId: Swift.String?
    /// The unique identifier of the deleted firewall rule.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the deleted firewall rule.
    /// This member is required.
    public var name: Swift.String?
    /// The priority that was configured for the deleted firewall rule.
    /// This member is required.
    public var priority: Swift.Int?
    /// The DNS query type that the deleted firewall rule was configured to match.
    public var queryType: Swift.String?
    /// The final status of the deleted firewall rule.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
    /// The date and time when the firewall rule was last updated before deletion.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        action: Route53GlobalResolverClientTypes.FirewallRuleAction? = nil,
        blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType? = nil,
        blockOverrideDomain: Swift.String? = nil,
        blockOverrideTtl: Swift.Int? = nil,
        blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse? = nil,
        confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection? = nil,
        dnsViewId: Swift.String? = nil,
        firewallDomainListId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        queryType: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.action = action
        self.blockOverrideDnsType = blockOverrideDnsType
        self.blockOverrideDomain = blockOverrideDomain
        self.blockOverrideTtl = blockOverrideTtl
        self.blockResponse = blockResponse
        self.confidenceThreshold = confidenceThreshold
        self.createdAt = createdAt
        self.description = description
        self.dnsAdvancedProtection = dnsAdvancedProtection
        self.dnsViewId = dnsViewId
        self.firewallDomainListId = firewallDomainListId
        self.id = id
        self.name = name
        self.priority = priority
        self.queryType = queryType
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct DeleteGlobalResolverInput: Swift.Sendable {
    /// The unique identifier of the Route 53 Global Resolver to delete.
    /// This member is required.
    public var globalResolverId: Swift.String?

    public init(
        globalResolverId: Swift.String? = nil
    ) {
        self.globalResolverId = globalResolverId
    }
}

public struct DeleteGlobalResolverOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the deleted Route 53 Global Resolver.
    /// This member is required.
    public var arn: Swift.String?
    /// The unique string that identifies the request and ensures idempotency.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The date and time when the Route 53 Global Resolver was originally created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the deleted Route 53 Global Resolver.
    public var description: Swift.String?
    /// The hostname that DNS clients used for TLS certificate validation when connecting to the deleted Route 53 Global Resolver.
    /// This member is required.
    public var dnsName: Swift.String?
    /// The unique identifier of the deleted Route 53 Global Resolver.
    /// This member is required.
    public var id: Swift.String?
    /// The global anycast IPv4 addresses that were associated with the deleted Route 53 Global Resolver.
    /// This member is required.
    public var ipv4Addresses: [Swift.String]?
    /// The name of the deleted Route 53 Global Resolver.
    /// This member is required.
    public var name: Swift.String?
    /// The AWS Region where observability data for the deleted Route 53 Global Resolver was stored.
    public var observabilityRegion: Swift.String?
    /// The AWS Regions where the deleted Route 53 Global Resolver was deployed and operational.
    /// This member is required.
    public var regions: [Swift.String]?
    /// The final status of the deleted Route 53 Global Resolver.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
    /// The date and time when the Route 53 Global Resolver was last updated before deletion.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        dnsName: Swift.String? = nil,
        id: Swift.String? = nil,
        ipv4Addresses: [Swift.String]? = nil,
        name: Swift.String? = nil,
        observabilityRegion: Swift.String? = nil,
        regions: [Swift.String]? = nil,
        status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.clientToken = clientToken
        self.createdAt = createdAt
        self.description = description
        self.dnsName = dnsName
        self.id = id
        self.ipv4Addresses = ipv4Addresses
        self.name = name
        self.observabilityRegion = observabilityRegion
        self.regions = regions
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct DisableDNSViewInput: Swift.Sendable {
    /// The unique identifier of the DNS view to disable.
    /// This member is required.
    public var dnsViewId: Swift.String?

    public init(
        dnsViewId: Swift.String? = nil
    ) {
        self.dnsViewId = dnsViewId
    }
}

public struct DisableDNSViewOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the disabled DNS view.
    /// This member is required.
    public var arn: Swift.String?
    /// The unique string that identifies the request and ensures idempotency.
    public var clientToken: Swift.String?
    /// The date and time when the DNS view was originally created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the disabled DNS view.
    public var description: Swift.String?
    /// Whether DNSSEC validation is enabled for the disabled DNS view.
    /// This member is required.
    public var dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType?
    /// Whether EDNS Client Subnet injection is enabled for the disabled DNS view.
    /// This member is required.
    public var ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType?
    /// The firewall rules fail-open behavior configured for the disabled DNS view.
    /// This member is required.
    public var firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType?
    /// The ID of the Route 53 Global Resolver that the disabled DNS view is associated with.
    /// This member is required.
    public var globalResolverId: Swift.String?
    /// The unique identifier of the disabled DNS view.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the disabled DNS view.
    /// This member is required.
    public var name: Swift.String?
    /// The current status of the disabled DNS view.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.ProfileResourceStatus?
    /// The date and time when the DNS view was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType? = nil,
        ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType? = nil,
        firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType? = nil,
        globalResolverId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.ProfileResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.clientToken = clientToken
        self.createdAt = createdAt
        self.description = description
        self.dnssecValidation = dnssecValidation
        self.ednsClientSubnet = ednsClientSubnet
        self.firewallRulesFailOpen = firewallRulesFailOpen
        self.globalResolverId = globalResolverId
        self.id = id
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct DisassociateHostedZoneInput: Swift.Sendable {
    /// The ID of the Route 53 private hosted zone to disassociate.
    /// This member is required.
    public var hostedZoneId: Swift.String?
    /// The Amazon Resource Name (ARN) of the Route 53 Global Resolver resource to disassociate the hosted zone from.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        hostedZoneId: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    ) {
        self.hostedZoneId = hostedZoneId
        self.resourceArn = resourceArn
    }
}

public struct DisassociateHostedZoneOutput: Swift.Sendable {
    /// The date and time when the association was originally created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The ID of the Route 53 private hosted zone that was disassociated.
    /// This member is required.
    public var hostedZoneId: Swift.String?
    /// The name of the Route 53 private hosted zone that was disassociated.
    /// This member is required.
    public var hostedZoneName: Swift.String?
    /// The unique identifier of the disassociation.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the association that was removed.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the Route 53 Global Resolver resource that the hosted zone was disassociated from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The final status of the disassociation.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.HostedZoneAssociationStatus?
    /// The date and time when the association was last updated before disassociation.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        hostedZoneId: Swift.String? = nil,
        hostedZoneName: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.HostedZoneAssociationStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.createdAt = createdAt
        self.hostedZoneId = hostedZoneId
        self.hostedZoneName = hostedZoneName
        self.id = id
        self.name = name
        self.resourceArn = resourceArn
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct EnableDNSViewInput: Swift.Sendable {
    /// The unique identifier of the DNS view to enable.
    /// This member is required.
    public var dnsViewId: Swift.String?

    public init(
        dnsViewId: Swift.String? = nil
    ) {
        self.dnsViewId = dnsViewId
    }
}

public struct EnableDNSViewOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the enabled DNS view.
    /// This member is required.
    public var arn: Swift.String?
    /// The unique string that identifies the request and ensures idempotency.
    public var clientToken: Swift.String?
    /// The date and time when the DNS view was originally created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the enabled DNS view.
    public var description: Swift.String?
    /// Whether DNSSEC validation is enabled for the enabled DNS view.
    /// This member is required.
    public var dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType?
    /// Whether EDNS Client Subnet injection is enabled for the enabled DNS view.
    /// This member is required.
    public var ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType?
    /// The firewall rules fail-open behavior configured for the enabled DNS view.
    /// This member is required.
    public var firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType?
    /// The ID of the Route 53 Global Resolver that the enabled DNS view is associated with.
    /// This member is required.
    public var globalResolverId: Swift.String?
    /// The unique identifier of the enabled DNS view.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the enabled DNS view.
    /// This member is required.
    public var name: Swift.String?
    /// The current status of the enabled DNS view.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.ProfileResourceStatus?
    /// The date and time when the DNS view was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType? = nil,
        ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType? = nil,
        firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType? = nil,
        globalResolverId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.ProfileResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.clientToken = clientToken
        self.createdAt = createdAt
        self.description = description
        self.dnssecValidation = dnssecValidation
        self.ednsClientSubnet = ednsClientSubnet
        self.firewallRulesFailOpen = firewallRulesFailOpen
        self.globalResolverId = globalResolverId
        self.id = id
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct GetDNSViewInput: Swift.Sendable {
    /// The ID of the DNS view to retrieve information about.
    /// This member is required.
    public var dnsViewId: Swift.String?

    public init(
        dnsViewId: Swift.String? = nil
    ) {
        self.dnsViewId = dnsViewId
    }
}

public struct GetDNSViewOutput: Swift.Sendable {
    /// Amazon Resource Name (ARN) of the DNS view.
    /// This member is required.
    public var arn: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
    public var clientToken: Swift.String?
    /// The time and date the DNS view was creates on.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Description of the DNS view.
    public var description: Swift.String?
    /// Specifies whether DNSSEC is enabled or disabled for the DNS view.
    /// This member is required.
    public var dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType?
    /// Specifies whether edns0 client subnet is enabled.
    /// This member is required.
    public var ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType?
    /// Specifies the DNS Firewall failure mode configuration. When enabled, the DNS Firewall allows DNS queries to proceed if it's unable to properly evaluate them. When disabled, the DNS Firewall blocks DNS queries it's unable to evaluate.
    /// This member is required.
    public var firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType?
    /// ID of the Global Resolver the DNS view is associated to.
    /// This member is required.
    public var globalResolverId: Swift.String?
    /// ID of the DNS view.
    /// This member is required.
    public var id: Swift.String?
    /// Name of the DNS view.
    /// This member is required.
    public var name: Swift.String?
    /// Operational status of the DNS view.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.ProfileResourceStatus?
    /// The time and date the DNS view was updated on.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType? = nil,
        ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType? = nil,
        firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType? = nil,
        globalResolverId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.ProfileResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.clientToken = clientToken
        self.createdAt = createdAt
        self.description = description
        self.dnssecValidation = dnssecValidation
        self.ednsClientSubnet = ednsClientSubnet
        self.firewallRulesFailOpen = firewallRulesFailOpen
        self.globalResolverId = globalResolverId
        self.id = id
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct ListDNSViewsInput: Swift.Sendable {
    /// The Global Resolver ID.
    /// This member is required.
    public var globalResolverId: Swift.String?
    /// The maximum number of results to retrieve in a single call.
    public var maxResults: Swift.Int?
    /// A pagination token used for large sets of results that can't be returned in a single response.
    public var nextToken: Swift.String?

    public init(
        globalResolverId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.globalResolverId = globalResolverId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension Route53GlobalResolverClientTypes {

    /// Summary information about a DNS view.
    public struct DNSViewSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the DNS view.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique string that identifies the request and ensures idempotency.
        /// This member is required.
        public var clientToken: Swift.String?
        /// The date and time when the DNS view was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// A description of the DNS view.
        public var description: Swift.String?
        /// Whether DNSSEC validation is enabled for the DNS view.
        /// This member is required.
        public var dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType?
        /// Whether EDNS Client Subnet injection is enabled for the DNS view.
        /// This member is required.
        public var ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType?
        /// Whether firewall rules fail open when they cannot be evaluated.
        /// This member is required.
        public var firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType?
        /// The ID of the global resolver that the DNS view is associated with.
        /// This member is required.
        public var globalResolverId: Swift.String?
        /// The unique identifier of the DNS view.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the DNS view.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the DNS view.
        /// This member is required.
        public var status: Route53GlobalResolverClientTypes.ProfileResourceStatus?
        /// The date and time when the DNS view was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            clientToken: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType? = nil,
            ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType? = nil,
            firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType? = nil,
            globalResolverId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: Route53GlobalResolverClientTypes.ProfileResourceStatus? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.dnssecValidation = dnssecValidation
            self.ednsClientSubnet = ednsClientSubnet
            self.firewallRulesFailOpen = firewallRulesFailOpen
            self.globalResolverId = globalResolverId
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListDNSViewsOutput: Swift.Sendable {
    /// An array of information about the DNS views, such as whether DNSSEC is enabled, creation time, etc.
    /// This member is required.
    public var dnsViews: [Route53GlobalResolverClientTypes.DNSViewSummary]?
    /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
    public var nextToken: Swift.String?

    public init(
        dnsViews: [Route53GlobalResolverClientTypes.DNSViewSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.dnsViews = dnsViews
        self.nextToken = nextToken
    }
}

public struct UpdateDNSViewInput: Swift.Sendable {
    /// A description of the DNS view.
    public var description: Swift.String?
    /// The unique identifier of the DNS view to update.
    /// This member is required.
    public var dnsViewId: Swift.String?
    /// Whether to enable DNSSEC validation for the DNS view.
    public var dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType?
    /// Whether to enable EDNS Client Subnet injection for the DNS view.
    public var ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType?
    /// Whether firewall rules should fail open when they cannot be evaluated.
    public var firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType?
    /// The name of the DNS view.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        dnsViewId: Swift.String? = nil,
        dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType? = nil,
        ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType? = nil,
        firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType? = nil,
        name: Swift.String? = nil
    ) {
        self.description = description
        self.dnsViewId = dnsViewId
        self.dnssecValidation = dnssecValidation
        self.ednsClientSubnet = ednsClientSubnet
        self.firewallRulesFailOpen = firewallRulesFailOpen
        self.name = name
    }
}

public struct UpdateDNSViewOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the updated DNS view.
    /// This member is required.
    public var arn: Swift.String?
    /// The unique string that identifies the request and ensures idempotency.
    public var clientToken: Swift.String?
    /// The date and time when the DNS view was originally created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the updated DNS view.
    public var description: Swift.String?
    /// Whether DNSSEC validation is enabled for the updated DNS view.
    /// This member is required.
    public var dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType?
    /// Whether EDNS Client Subnet injection is enabled for the updated DNS view.
    /// This member is required.
    public var ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType?
    /// Whether firewall rules fail open when they cannot be evaluated for the updated DNS view.
    /// This member is required.
    public var firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType?
    /// The ID of the global resolver associated with the updated DNS view.
    /// This member is required.
    public var globalResolverId: Swift.String?
    /// The unique identifier of the updated DNS view.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the updated DNS view.
    /// This member is required.
    public var name: Swift.String?
    /// The current status of the updated DNS view.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.ProfileResourceStatus?
    /// The date and time when the DNS view was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        dnssecValidation: Route53GlobalResolverClientTypes.DnsSecValidationType? = nil,
        ednsClientSubnet: Route53GlobalResolverClientTypes.EdnsClientSubnetType? = nil,
        firewallRulesFailOpen: Route53GlobalResolverClientTypes.FirewallRulesFailOpenType? = nil,
        globalResolverId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.ProfileResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.clientToken = clientToken
        self.createdAt = createdAt
        self.description = description
        self.dnssecValidation = dnssecValidation
        self.ednsClientSubnet = ednsClientSubnet
        self.firewallRulesFailOpen = firewallRulesFailOpen
        self.globalResolverId = globalResolverId
        self.id = id
        self.name = name
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct GetFirewallDomainListInput: Swift.Sendable {
    /// ID of the domain list.
    /// This member is required.
    public var firewallDomainListId: Swift.String?

    public init(
        firewallDomainListId: Swift.String? = nil
    ) {
        self.firewallDomainListId = firewallDomainListId
    }
}

public struct GetFirewallDomainListOutput: Swift.Sendable {
    /// Amazon Resource Name (ARN) of the domain list.
    /// This member is required.
    public var arn: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
    public var clientToken: Swift.String?
    /// The time and date the domain list was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the domain list.
    public var description: Swift.String?
    /// Number of domains in the domain list.
    /// This member is required.
    public var domainCount: Swift.Int?
    /// ID of the Global Resolver that the domain list is associated to.
    /// This member is required.
    public var globalResolverId: Swift.String?
    /// ID of the domain list.
    /// This member is required.
    public var id: Swift.String?
    /// Name of the domain list.
    /// This member is required.
    public var name: Swift.String?
    /// Operational status of the domain list.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
    /// Additional information about the status of the domain list.
    public var statusMessage: Swift.String?
    /// The date and time the domain list was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        domainCount: Swift.Int? = nil,
        globalResolverId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
        statusMessage: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.clientToken = clientToken
        self.createdAt = createdAt
        self.description = description
        self.domainCount = domainCount
        self.globalResolverId = globalResolverId
        self.id = id
        self.name = name
        self.status = status
        self.statusMessage = statusMessage
        self.updatedAt = updatedAt
    }
}

public struct ImportFirewallDomainsInput: Swift.Sendable {
    /// The fully qualified URL of the file in Amazon S3 that contains the list of domains to import. The file should contain one domain per line.
    /// This member is required.
    public var domainFileUrl: Swift.String?
    /// ID of the DNS Firewall domain list that you want to import the domain list to.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// This value is REPLACE, and it updates the domain list to match the list of domains in the imported file.
    /// This member is required.
    public var operation: Swift.String?

    public init(
        domainFileUrl: Swift.String? = nil,
        firewallDomainListId: Swift.String? = nil,
        operation: Swift.String? = nil
    ) {
        self.domainFileUrl = domainFileUrl
        self.firewallDomainListId = firewallDomainListId
        self.operation = operation
    }
}

public struct ImportFirewallDomainsOutput: Swift.Sendable {
    /// ID of the DNS Firewall domain list that you imported the domain list to.
    /// This member is required.
    public var id: Swift.String?
    /// Name of the DNS Firewall domain list.
    /// This member is required.
    public var name: Swift.String?
    /// Operational status of the DNS Firewall domain list.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.CRResourceStatus?

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil
    ) {
        self.id = id
        self.name = name
        self.status = status
    }
}

public struct ListFirewallDomainListsInput: Swift.Sendable {
    /// The ID of the Global Resolver that contains the DNS view the domain lists are associated to.
    public var globalResolverId: Swift.String?
    /// The maximum number of results to retrieve in a single call.
    public var maxResults: Swift.Int?
    /// A pagination token used for large sets of results that can't be returned in a single response.
    public var nextToken: Swift.String?

    public init(
        globalResolverId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.globalResolverId = globalResolverId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension Route53GlobalResolverClientTypes {

    /// Summary information about a firewall domain list.
    public struct FirewallDomainListsItem: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the firewall domain list.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time when the firewall domain list was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// A description of the firewall domain list.
        public var description: Swift.String?
        /// The ID of the global resolver that the firewall domain list is associated with.
        /// This member is required.
        public var globalResolverId: Swift.String?
        /// The unique identifier of the firewall domain list.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the firewall domain list.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the firewall domain list.
        /// This member is required.
        public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
        /// The date and time when the firewall domain list was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            globalResolverId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.globalResolverId = globalResolverId
            self.id = id
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListFirewallDomainListsOutput: Swift.Sendable {
    /// List of the DNS Firewall domain lists.
    /// This member is required.
    public var firewallDomainLists: [Route53GlobalResolverClientTypes.FirewallDomainListsItem]?
    /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
    public var nextToken: Swift.String?

    public init(
        firewallDomainLists: [Route53GlobalResolverClientTypes.FirewallDomainListsItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.firewallDomainLists = firewallDomainLists
        self.nextToken = nextToken
    }
}

public struct ListFirewallDomainsInput: Swift.Sendable {
    /// ID of the DNS Firewall domain list.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// The maximum number of results to retrieve in a single call.
    public var maxResults: Swift.Int?
    /// A pagination token used for large sets of results that can't be returned in a single response.
    public var nextToken: Swift.String?

    public init(
        firewallDomainListId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.firewallDomainListId = firewallDomainListId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFirewallDomainsOutput: Swift.Sendable {
    /// List of domains in the specified domain list.
    /// This member is required.
    public var domains: [Swift.String]?
    /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
    public var nextToken: Swift.String?

    public init(
        domains: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.domains = domains
        self.nextToken = nextToken
    }
}

public struct UpdateFirewallDomainsInput: Swift.Sendable {
    /// A list of the domains. You can add up to 1000 domains per request.
    /// This member is required.
    public var domains: [Swift.String]?
    /// The ID of the DNS Firewall domain list to which you want to add the domains.
    /// This member is required.
    public var firewallDomainListId: Swift.String?
    /// The operation for updating the domain list. The allowed values are ADD, REMOVE, and REPLACE.
    /// This member is required.
    public var operation: Swift.String?

    public init(
        domains: [Swift.String]? = nil,
        firewallDomainListId: Swift.String? = nil,
        operation: Swift.String? = nil
    ) {
        self.domains = domains
        self.firewallDomainListId = firewallDomainListId
        self.operation = operation
    }
}

public struct UpdateFirewallDomainsOutput: Swift.Sendable {
    /// The ID of the DNS Firewall domain list.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the domain list.
    /// This member is required.
    public var name: Swift.String?
    /// The operational status of the domain list.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.CRResourceStatus?

    public init(
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil
    ) {
        self.id = id
        self.name = name
        self.status = status
    }
}

public struct GetFirewallRuleInput: Swift.Sendable {
    /// ID of the DNS Firewall rule.
    /// This member is required.
    public var firewallRuleId: Swift.String?

    public init(
        firewallRuleId: Swift.String? = nil
    ) {
        self.firewallRuleId = firewallRuleId
    }
}

public struct GetFirewallRuleOutput: Swift.Sendable {
    /// The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list, or a threat in a DNS Firewall Advanced rule.
    /// This member is required.
    public var action: Route53GlobalResolverClientTypes.FirewallRuleAction?
    /// The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType?
    /// The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideDomain: Swift.String?
    /// The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideTtl: Swift.Int?
    /// The way that you want DNS Firewall to block the request. Used for the rule action setting BLOCK.
    public var blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse?
    /// The confidence threshold for DNS Firewall Advanced. You must provide this value when you create a DNS Firewall Advanced rule.
    public var confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold?
    /// The time and date the DNS Firewall rule was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the DNS Firewall rule.
    public var description: Swift.String?
    /// The type of the DNS Firewall Advanced rule. Valid values are DGA and DNS_TUNNELING.
    public var dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection?
    /// The DNS view ID the DNS Firewall is associated with.
    /// This member is required.
    public var dnsViewId: Swift.String?
    /// The ID of a DNS Firewall domain list.
    public var firewallDomainListId: Swift.String?
    /// ID of the DNS Firewall rule.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the DNS Firewall rule.
    /// This member is required.
    public var name: Swift.String?
    /// The setting that determines the processing order of the rule in the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting.
    /// This member is required.
    public var priority: Swift.Int?
    /// The DNS query type you want the rule to evaluate.
    public var queryType: Swift.String?
    /// The operational status of the DNS Firewall rule.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
    /// The date and time the DNS Firewall rule was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        action: Route53GlobalResolverClientTypes.FirewallRuleAction? = nil,
        blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType? = nil,
        blockOverrideDomain: Swift.String? = nil,
        blockOverrideTtl: Swift.Int? = nil,
        blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse? = nil,
        confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection? = nil,
        dnsViewId: Swift.String? = nil,
        firewallDomainListId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        queryType: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.action = action
        self.blockOverrideDnsType = blockOverrideDnsType
        self.blockOverrideDomain = blockOverrideDomain
        self.blockOverrideTtl = blockOverrideTtl
        self.blockResponse = blockResponse
        self.confidenceThreshold = confidenceThreshold
        self.createdAt = createdAt
        self.description = description
        self.dnsAdvancedProtection = dnsAdvancedProtection
        self.dnsViewId = dnsViewId
        self.firewallDomainListId = firewallDomainListId
        self.id = id
        self.name = name
        self.priority = priority
        self.queryType = queryType
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct ListFirewallRulesInput: Swift.Sendable {
    /// ID of the DNS view.
    /// This member is required.
    public var dnsViewId: Swift.String?
    /// Values to filter the results.
    public var filters: [Swift.String: [Swift.String]]?
    /// The maximum number of results to retrieve in a single call.
    public var maxResults: Swift.Int?
    /// A pagination token used for large sets of results that can't be returned in a single response.
    public var nextToken: Swift.String?

    public init(
        dnsViewId: Swift.String? = nil,
        filters: [Swift.String: [Swift.String]]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.dnsViewId = dnsViewId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension Route53GlobalResolverClientTypes {

    /// Summary information about a firewall rule.
    public struct FirewallRulesItem: Swift.Sendable {
        /// The action configured for the firewall rule.
        /// This member is required.
        public var action: Route53GlobalResolverClientTypes.FirewallRuleAction?
        /// The DNS record type configured for the firewall rule's custom response.
        public var blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType?
        /// The custom domain name configured for the firewall rule's BLOCK response.
        public var blockOverrideDomain: Swift.String?
        /// The TTL value configured for the firewall rule's custom response.
        public var blockOverrideTtl: Swift.Int?
        /// The type of block response configured for the firewall rule.
        public var blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse?
        /// The confidence threshold configured for the firewall rule's advanced threat detection.
        public var confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold?
        /// The date and time when the firewall rule was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the firewall rule.
        public var description: Swift.String?
        /// Whether advanced DNS threat protection is enabled for the firewall rule.
        public var dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection?
        /// The ID of the DNS view associated with the firewall rule.
        /// This member is required.
        public var dnsViewId: Swift.String?
        /// The ID of the firewall domain list associated with the firewall rule.
        public var firewallDomainListId: Swift.String?
        /// The unique identifier of the firewall rule.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the firewall rule.
        /// This member is required.
        public var name: Swift.String?
        /// The priority of the firewall rule.
        /// This member is required.
        public var priority: Swift.Int?
        /// The DNS query type that the firewall rule matches.
        public var queryType: Swift.String?
        /// The current status of the firewall rule.
        /// This member is required.
        public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
        /// The date and time when the firewall rule was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            action: Route53GlobalResolverClientTypes.FirewallRuleAction? = nil,
            blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType? = nil,
            blockOverrideDomain: Swift.String? = nil,
            blockOverrideTtl: Swift.Int? = nil,
            blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse? = nil,
            confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection? = nil,
            dnsViewId: Swift.String? = nil,
            firewallDomainListId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            queryType: Swift.String? = nil,
            status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.action = action
            self.blockOverrideDnsType = blockOverrideDnsType
            self.blockOverrideDomain = blockOverrideDomain
            self.blockOverrideTtl = blockOverrideTtl
            self.blockResponse = blockResponse
            self.confidenceThreshold = confidenceThreshold
            self.createdAt = createdAt
            self.description = description
            self.dnsAdvancedProtection = dnsAdvancedProtection
            self.dnsViewId = dnsViewId
            self.firewallDomainListId = firewallDomainListId
            self.id = id
            self.name = name
            self.priority = priority
            self.queryType = queryType
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListFirewallRulesOutput: Swift.Sendable {
    /// List of the firewall rules and information about them.
    /// This member is required.
    public var firewallRules: [Route53GlobalResolverClientTypes.FirewallRulesItem]?
    /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
    public var nextToken: Swift.String?

    public init(
        firewallRules: [Route53GlobalResolverClientTypes.FirewallRulesItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.firewallRules = firewallRules
        self.nextToken = nextToken
    }
}

public struct UpdateFirewallRuleInput: Swift.Sendable {
    /// The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list, or a threat in a DNS Firewall Advanced rule.
    public var action: Route53GlobalResolverClientTypes.FirewallRuleAction?
    /// The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType?
    /// The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideDomain: Swift.String?
    /// The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideTtl: Swift.Int?
    /// The way that you want DNS Firewall to block the request. Used for the rule action setting BLOCK.
    public var blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse?
    /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The confidence threshold for DNS Firewall Advanced. You must provide this value when you create a DNS Firewall Advanced rule.
    public var confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold?
    /// The description for the Firewall rule.
    public var description: Swift.String?
    /// The type of the DNS Firewall Advanced rule. Valid values are DGA and DNS_TUNNELING.
    public var dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection?
    /// The ID of the DNS Firewall rule.
    /// This member is required.
    public var firewallRuleId: Swift.String?
    /// The name of the DNS Firewall rule.
    public var name: Swift.String?
    /// The setting that determines the processing order of the rule in the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting.
    public var priority: Swift.Int?

    public init(
        action: Route53GlobalResolverClientTypes.FirewallRuleAction? = nil,
        blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType? = nil,
        blockOverrideDomain: Swift.String? = nil,
        blockOverrideTtl: Swift.Int? = nil,
        blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse? = nil,
        clientToken: Swift.String? = nil,
        confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold? = nil,
        description: Swift.String? = nil,
        dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection? = nil,
        firewallRuleId: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil
    ) {
        self.action = action
        self.blockOverrideDnsType = blockOverrideDnsType
        self.blockOverrideDomain = blockOverrideDomain
        self.blockOverrideTtl = blockOverrideTtl
        self.blockResponse = blockResponse
        self.clientToken = clientToken
        self.confidenceThreshold = confidenceThreshold
        self.description = description
        self.dnsAdvancedProtection = dnsAdvancedProtection
        self.firewallRuleId = firewallRuleId
        self.name = name
        self.priority = priority
    }
}

public struct UpdateFirewallRuleOutput: Swift.Sendable {
    /// The action that DNS Firewall should take on a DNS query when it matches one of the domains in the rule's domain list, or a threat in a DNS Firewall Advanced rule.
    /// This member is required.
    public var action: Route53GlobalResolverClientTypes.FirewallRuleAction?
    /// The DNS record's type. This determines the format of the record value that you provided in BlockOverrideDomain. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType?
    /// The custom DNS record to send back in response to the query. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideDomain: Swift.String?
    /// The recommended amount of time, in seconds, for the DNS resolver or web browser to cache the provided override record. Used for the rule action BLOCK with a BlockResponse setting of OVERRIDE.
    public var blockOverrideTtl: Swift.Int?
    /// The way that you want DNS Firewall to block the request. Used for the rule action setting BLOCK.
    public var blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse?
    /// The confidence threshold for DNS Firewall Advanced. You must provide this value when you create a DNS Firewall Advanced rule.
    public var confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold?
    /// The time and date the Firewall rule was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the Firewall rule.
    public var description: Swift.String?
    /// The type of the DNS Firewall Advanced rule. Valid values are DGA and DNS_TUNNELING.
    public var dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection?
    /// The ID of the DNS view the Firewall rule is associated with.
    /// This member is required.
    public var dnsViewId: Swift.String?
    /// The ID of the domain list associated with the Firewall rule.
    public var firewallDomainListId: Swift.String?
    /// The ID of the Firewall rule.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the Firewall rule.
    /// This member is required.
    public var name: Swift.String?
    /// The setting that determines the processing order of the rule in the rule group. DNS Firewall processes the rules in a rule group by order of priority, starting from the lowest setting.
    /// This member is required.
    public var priority: Swift.Int?
    /// The DNS query type you want the rule to evaluate.
    public var queryType: Swift.String?
    /// The operational status of the firewall rule.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
    /// The time and date the rule was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        action: Route53GlobalResolverClientTypes.FirewallRuleAction? = nil,
        blockOverrideDnsType: Route53GlobalResolverClientTypes.BlockOverrideDnsQueryType? = nil,
        blockOverrideDomain: Swift.String? = nil,
        blockOverrideTtl: Swift.Int? = nil,
        blockResponse: Route53GlobalResolverClientTypes.FirewallBlockResponse? = nil,
        confidenceThreshold: Route53GlobalResolverClientTypes.ConfidenceThreshold? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        dnsAdvancedProtection: Route53GlobalResolverClientTypes.DnsAdvancedProtection? = nil,
        dnsViewId: Swift.String? = nil,
        firewallDomainListId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        priority: Swift.Int? = nil,
        queryType: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.action = action
        self.blockOverrideDnsType = blockOverrideDnsType
        self.blockOverrideDomain = blockOverrideDomain
        self.blockOverrideTtl = blockOverrideTtl
        self.blockResponse = blockResponse
        self.confidenceThreshold = confidenceThreshold
        self.createdAt = createdAt
        self.description = description
        self.dnsAdvancedProtection = dnsAdvancedProtection
        self.dnsViewId = dnsViewId
        self.firewallDomainListId = firewallDomainListId
        self.id = id
        self.name = name
        self.priority = priority
        self.queryType = queryType
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct GetGlobalResolverInput: Swift.Sendable {
    /// The ID of the Route 53 Global Resolver to retrieve information about.
    /// This member is required.
    public var globalResolverId: Swift.String?

    public init(
        globalResolverId: Swift.String? = nil
    ) {
        self.globalResolverId = globalResolverId
    }
}

public struct GetGlobalResolverOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Global Resolver.
    /// This member is required.
    public var arn: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The date and time the Global Resolver was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the Global Resolver.
    public var description: Swift.String?
    /// The hostname used by the customers' DNS clients for certification validation.
    /// This member is required.
    public var dnsName: Swift.String?
    /// The ID of the Global Resolver.
    /// This member is required.
    public var id: Swift.String?
    /// List of anycast IPv4 addresses associated with the Global Resolver instance.
    /// This member is required.
    public var ipv4Addresses: [Swift.String]?
    /// The name of the Global Resolver.
    /// This member is required.
    public var name: Swift.String?
    /// The AWS Regions in which the users' Global Resolver query resolution logs will be propagated.
    public var observabilityRegion: Swift.String?
    /// The AWS Regions in which the Global Resolver operate.
    /// This member is required.
    public var regions: [Swift.String]?
    /// The operational status of the Global Resolver.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
    /// The date and time the Global Resolver was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        dnsName: Swift.String? = nil,
        id: Swift.String? = nil,
        ipv4Addresses: [Swift.String]? = nil,
        name: Swift.String? = nil,
        observabilityRegion: Swift.String? = nil,
        regions: [Swift.String]? = nil,
        status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.clientToken = clientToken
        self.createdAt = createdAt
        self.description = description
        self.dnsName = dnsName
        self.id = id
        self.ipv4Addresses = ipv4Addresses
        self.name = name
        self.observabilityRegion = observabilityRegion
        self.regions = regions
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct ListGlobalResolversInput: Swift.Sendable {
    /// The maximum number of Route 53 Global Resolver instances to return in the response. Valid range is 1-100.
    public var maxResults: Swift.Int?
    /// The token for the next page of results. This value is returned in the response if there are more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension Route53GlobalResolverClientTypes {

    /// Summary information about a global resolver.
    public struct GlobalResolversItem: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the global resolver.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique string that identifies the request and ensures idempotency.
        /// This member is required.
        public var clientToken: Swift.String?
        /// The date and time when the global resolver was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// A description of the global resolver.
        public var description: Swift.String?
        /// The DNS name of the global resolver.
        /// This member is required.
        public var dnsName: Swift.String?
        /// The unique identifier of the global resolver.
        /// This member is required.
        public var id: Swift.String?
        /// The IPv4 addresses assigned to the global resolver.
        /// This member is required.
        public var ipv4Addresses: [Swift.String]?
        /// The name of the global resolver.
        /// This member is required.
        public var name: Swift.String?
        /// The AWS Region where observability data is collected for the global resolver.
        public var observabilityRegion: Swift.String?
        /// The AWS Regions where the global resolver is deployed.
        /// This member is required.
        public var regions: [Swift.String]?
        /// The current status of the global resolver.
        /// This member is required.
        public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
        /// The date and time when the global resolver was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            clientToken: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            dnsName: Swift.String? = nil,
            id: Swift.String? = nil,
            ipv4Addresses: [Swift.String]? = nil,
            name: Swift.String? = nil,
            observabilityRegion: Swift.String? = nil,
            regions: [Swift.String]? = nil,
            status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.clientToken = clientToken
            self.createdAt = createdAt
            self.description = description
            self.dnsName = dnsName
            self.id = id
            self.ipv4Addresses = ipv4Addresses
            self.name = name
            self.observabilityRegion = observabilityRegion
            self.regions = regions
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListGlobalResolversOutput: Swift.Sendable {
    /// Paginated list of Global Resolvers.
    /// This member is required.
    public var globalResolvers: [Route53GlobalResolverClientTypes.GlobalResolversItem]?
    /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
    public var nextToken: Swift.String?

    public init(
        globalResolvers: [Route53GlobalResolverClientTypes.GlobalResolversItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.globalResolvers = globalResolvers
        self.nextToken = nextToken
    }
}

public struct UpdateGlobalResolverInput: Swift.Sendable {
    /// The description of the Global Resolver.
    public var description: Swift.String?
    /// The ID of the Global Resolver.
    /// This member is required.
    public var globalResolverId: Swift.String?
    /// The name of the Global Resolver.
    public var name: Swift.String?
    /// The AWS Regions in which the users' Global Resolver query resolution logs will be propagated.
    public var observabilityRegion: Swift.String?

    public init(
        description: Swift.String? = nil,
        globalResolverId: Swift.String? = nil,
        name: Swift.String? = nil,
        observabilityRegion: Swift.String? = nil
    ) {
        self.description = description
        self.globalResolverId = globalResolverId
        self.name = name
        self.observabilityRegion = observabilityRegion
    }
}

public struct UpdateGlobalResolverOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Global Resolver.
    /// This member is required.
    public var arn: Swift.String?
    /// A unique, case-sensitive identifier to ensure idempotency. This means that making the same request multiple times with the same clientToken has the same result every time.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The time and date the Global Resolverwas created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// Description of the Global Resolver.
    public var description: Swift.String?
    /// The hostname to be used by the customers' DNS clients for certification validation.
    /// This member is required.
    public var dnsName: Swift.String?
    /// The ID of the Global Resolver.
    /// This member is required.
    public var id: Swift.String?
    /// List of anycast IPv4 addresses associated with the Global Resolver instance.
    /// This member is required.
    public var ipv4Addresses: [Swift.String]?
    /// Name of the Global Resolver.
    /// This member is required.
    public var name: Swift.String?
    /// The AWS Regions in which the users' Global Resolver query resolution logs will be propagated.
    public var observabilityRegion: Swift.String?
    /// The AWS Regions in which the Global Resolver will operate.
    /// This member is required.
    public var regions: [Swift.String]?
    /// The operational status of the Global Resolver.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.CRResourceStatus?
    /// The time and date the Global Resolver was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        dnsName: Swift.String? = nil,
        id: Swift.String? = nil,
        ipv4Addresses: [Swift.String]? = nil,
        name: Swift.String? = nil,
        observabilityRegion: Swift.String? = nil,
        regions: [Swift.String]? = nil,
        status: Route53GlobalResolverClientTypes.CRResourceStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.clientToken = clientToken
        self.createdAt = createdAt
        self.description = description
        self.dnsName = dnsName
        self.id = id
        self.ipv4Addresses = ipv4Addresses
        self.name = name
        self.observabilityRegion = observabilityRegion
        self.regions = regions
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct GetHostedZoneAssociationInput: Swift.Sendable {
    /// ID of the private hosted zone association.
    /// This member is required.
    public var hostedZoneAssociationId: Swift.String?

    public init(
        hostedZoneAssociationId: Swift.String? = nil
    ) {
        self.hostedZoneAssociationId = hostedZoneAssociationId
    }
}

public struct GetHostedZoneAssociationOutput: Swift.Sendable {
    /// The time and date the private hosted zone association was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// ID of the hosted zone associated to the DNS view.
    /// This member is required.
    public var hostedZoneId: Swift.String?
    /// Name of the domain associated with the private hosted zone.
    /// This member is required.
    public var hostedZoneName: Swift.String?
    /// ID of the private hosted zone association.
    /// This member is required.
    public var id: Swift.String?
    /// Name of the private hosted zone association.
    /// This member is required.
    public var name: Swift.String?
    /// Amazon Resource Name (ARN) of the DNS view the private hosted zone is associated to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The operational status of the private hosted zone association.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.HostedZoneAssociationStatus?
    /// The time and date the private hosted zone association was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        hostedZoneId: Swift.String? = nil,
        hostedZoneName: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.HostedZoneAssociationStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.createdAt = createdAt
        self.hostedZoneId = hostedZoneId
        self.hostedZoneName = hostedZoneName
        self.id = id
        self.name = name
        self.resourceArn = resourceArn
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct ListHostedZoneAssociationsInput: Swift.Sendable {
    /// The maximum number of results to retrieve in a single call.
    public var maxResults: Swift.Int?
    /// A pagination token used for large sets of results that can't be returned in a single response.
    public var nextToken: Swift.String?
    /// Amazon Resource Name (ARN) of the DNS view.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

extension Route53GlobalResolverClientTypes {

    /// Summary information about a hosted zone association.
    public struct HostedZoneAssociationSummary: Swift.Sendable {
        /// The date and time when the hosted zone association was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The ID of the hosted zone.
        /// This member is required.
        public var hostedZoneId: Swift.String?
        /// The name of the hosted zone.
        /// This member is required.
        public var hostedZoneName: Swift.String?
        /// The unique identifier of the hosted zone association.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the hosted zone association.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the resource associated with the hosted zone.
        /// This member is required.
        public var resourceArn: Swift.String?
        /// The current status of the hosted zone association.
        /// This member is required.
        public var status: Route53GlobalResolverClientTypes.HostedZoneAssociationStatus?
        /// The date and time when the hosted zone association was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            createdAt: Foundation.Date? = nil,
            hostedZoneId: Swift.String? = nil,
            hostedZoneName: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            status: Route53GlobalResolverClientTypes.HostedZoneAssociationStatus? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.createdAt = createdAt
            self.hostedZoneId = hostedZoneId
            self.hostedZoneName = hostedZoneName
            self.id = id
            self.name = name
            self.resourceArn = resourceArn
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListHostedZoneAssociationsOutput: Swift.Sendable {
    /// List of the private hosted zone associations.
    /// This member is required.
    public var hostedZoneAssociations: [Route53GlobalResolverClientTypes.HostedZoneAssociationSummary]?
    /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
    public var nextToken: Swift.String?

    public init(
        hostedZoneAssociations: [Route53GlobalResolverClientTypes.HostedZoneAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.hostedZoneAssociations = hostedZoneAssociations
        self.nextToken = nextToken
    }
}

public struct UpdateHostedZoneAssociationInput: Swift.Sendable {
    /// The ID of the private hosted zone association.
    /// This member is required.
    public var hostedZoneAssociationId: Swift.String?
    /// The name you want to update the hosted zone association to.
    public var name: Swift.String?

    public init(
        hostedZoneAssociationId: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.hostedZoneAssociationId = hostedZoneAssociationId
        self.name = name
    }
}

public struct UpdateHostedZoneAssociationOutput: Swift.Sendable {
    /// The time and date the private hosted zone association was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The ID of the private hosted zone.
    /// This member is required.
    public var hostedZoneId: Swift.String?
    /// The name of the domain associated with the private hosted zone.
    /// This member is required.
    public var hostedZoneName: Swift.String?
    /// The ID of the private hosted zone association.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the private hosted zone association.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the private hosted zone association.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The operational status of the private hosted zone association.
    /// This member is required.
    public var status: Route53GlobalResolverClientTypes.HostedZoneAssociationStatus?
    /// The time and date the private hosted zone association was updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        createdAt: Foundation.Date? = nil,
        hostedZoneId: Swift.String? = nil,
        hostedZoneName: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        status: Route53GlobalResolverClientTypes.HostedZoneAssociationStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.createdAt = createdAt
        self.hostedZoneId = hostedZoneId
        self.hostedZoneName = hostedZoneName
        self.id = id
        self.name = name
        self.resourceArn = resourceArn
        self.status = status
        self.updatedAt = updatedAt
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// Amazon Resource Name (ARN) for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// An array of user-defined keys and optional values. These tags can be used for categorization and organization.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

public struct GetManagedFirewallDomainListInput: Swift.Sendable {
    /// ID of the Managed Domain List.
    /// This member is required.
    public var managedFirewallDomainListId: Swift.String?

    public init(
        managedFirewallDomainListId: Swift.String? = nil
    ) {
        self.managedFirewallDomainListId = managedFirewallDomainListId
    }
}

public struct GetManagedFirewallDomainListOutput: Swift.Sendable {
    /// Description of the Managed Domain List.
    public var description: Swift.String?
    /// ID of the Managed Domain List.
    /// This member is required.
    public var id: Swift.String?
    /// Type of the managed category. This is either THREAT or CONTENT.
    /// This member is required.
    public var managedListType: Swift.String?
    /// Name of the Managed Domain List.
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        managedListType: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.description = description
        self.id = id
        self.managedListType = managedListType
        self.name = name
    }
}

public struct ListManagedFirewallDomainListsInput: Swift.Sendable {
    /// The category of the Manage DNS list either THREAT or CONTENT.
    /// This member is required.
    public var managedFirewallDomainListType: Swift.String?
    /// The maximum number of results to retrieve in a single call.
    public var maxResults: Swift.Int?
    /// A pagination token used for large sets of results that can't be returned in a single response.
    public var nextToken: Swift.String?

    public init(
        managedFirewallDomainListType: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.managedFirewallDomainListType = managedFirewallDomainListType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension Route53GlobalResolverClientTypes {

    /// Summary information about a managed firewall domain list.
    public struct ManagedFirewallDomainListsItem: Swift.Sendable {
        /// A description of the managed firewall domain list.
        public var description: Swift.String?
        /// The unique identifier of the managed firewall domain list.
        /// This member is required.
        public var id: Swift.String?
        /// The type of the managed firewall domain list.
        /// This member is required.
        public var managedListType: Swift.String?
        /// The name of the managed firewall domain list.
        /// This member is required.
        public var name: Swift.String?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            managedListType: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.description = description
            self.id = id
            self.managedListType = managedListType
            self.name = name
        }
    }
}

public struct ListManagedFirewallDomainListsOutput: Swift.Sendable {
    /// List of the Managed Domain Lists.
    /// This member is required.
    public var managedFirewallDomainLists: [Route53GlobalResolverClientTypes.ManagedFirewallDomainListsItem]?
    /// A pagination token used for large sets of results that can't be returned in a single response. Provide this token in the next call to get the results not returned in this call.
    public var nextToken: Swift.String?

    public init(
        managedFirewallDomainLists: [Route53GlobalResolverClientTypes.ManagedFirewallDomainListsItem]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.managedFirewallDomainLists = managedFirewallDomainLists
        self.nextToken = nextToken
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// Amazon Resource Name (ARN) of the resource to be tagged.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of user-defined keys and optional values. These tags can be used for categorization and organization.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys associated with the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension AssociateHostedZoneInput {

    static func urlPathProvider(_ value: AssociateHostedZoneInput) -> Swift.String? {
        guard let hostedZoneId = value.hostedZoneId else {
            return nil
        }
        return "/hosted-zone-associations/\(hostedZoneId.urlPercentEncoding())"
    }
}

extension BatchCreateFirewallRuleInput {

    static func urlPathProvider(_ value: BatchCreateFirewallRuleInput) -> Swift.String? {
        return "/firewall-rules/batch-create"
    }
}

extension BatchDeleteFirewallRuleInput {

    static func urlPathProvider(_ value: BatchDeleteFirewallRuleInput) -> Swift.String? {
        return "/firewall-rules/batch-delete"
    }
}

extension BatchUpdateFirewallRuleInput {

    static func urlPathProvider(_ value: BatchUpdateFirewallRuleInput) -> Swift.String? {
        return "/firewall-rules/batch-update"
    }
}

extension CreateAccessSourceInput {

    static func urlPathProvider(_ value: CreateAccessSourceInput) -> Swift.String? {
        return "/access-sources"
    }
}

extension CreateAccessTokenInput {

    static func urlPathProvider(_ value: CreateAccessTokenInput) -> Swift.String? {
        guard let dnsViewId = value.dnsViewId else {
            return nil
        }
        return "/tokens/\(dnsViewId.urlPercentEncoding())"
    }
}

extension CreateDNSViewInput {

    static func urlPathProvider(_ value: CreateDNSViewInput) -> Swift.String? {
        guard let globalResolverId = value.globalResolverId else {
            return nil
        }
        return "/dns-views/\(globalResolverId.urlPercentEncoding())"
    }
}

extension CreateFirewallDomainListInput {

    static func urlPathProvider(_ value: CreateFirewallDomainListInput) -> Swift.String? {
        guard let globalResolverId = value.globalResolverId else {
            return nil
        }
        return "/firewall-domain-lists/\(globalResolverId.urlPercentEncoding())"
    }
}

extension CreateFirewallRuleInput {

    static func urlPathProvider(_ value: CreateFirewallRuleInput) -> Swift.String? {
        return "/firewall-rules"
    }
}

extension CreateGlobalResolverInput {

    static func urlPathProvider(_ value: CreateGlobalResolverInput) -> Swift.String? {
        return "/global-resolver"
    }
}

extension DeleteAccessSourceInput {

    static func urlPathProvider(_ value: DeleteAccessSourceInput) -> Swift.String? {
        guard let accessSourceId = value.accessSourceId else {
            return nil
        }
        return "/access-sources/\(accessSourceId.urlPercentEncoding())"
    }
}

extension DeleteAccessTokenInput {

    static func urlPathProvider(_ value: DeleteAccessTokenInput) -> Swift.String? {
        guard let accessTokenId = value.accessTokenId else {
            return nil
        }
        return "/tokens/\(accessTokenId.urlPercentEncoding())"
    }
}

extension DeleteDNSViewInput {

    static func urlPathProvider(_ value: DeleteDNSViewInput) -> Swift.String? {
        guard let dnsViewId = value.dnsViewId else {
            return nil
        }
        return "/dns-views/\(dnsViewId.urlPercentEncoding())"
    }
}

extension DeleteFirewallDomainListInput {

    static func urlPathProvider(_ value: DeleteFirewallDomainListInput) -> Swift.String? {
        guard let firewallDomainListId = value.firewallDomainListId else {
            return nil
        }
        return "/firewall-domain-lists/\(firewallDomainListId.urlPercentEncoding())"
    }
}

extension DeleteFirewallRuleInput {

    static func urlPathProvider(_ value: DeleteFirewallRuleInput) -> Swift.String? {
        guard let firewallRuleId = value.firewallRuleId else {
            return nil
        }
        return "/firewall-rules/\(firewallRuleId.urlPercentEncoding())"
    }
}

extension DeleteGlobalResolverInput {

    static func urlPathProvider(_ value: DeleteGlobalResolverInput) -> Swift.String? {
        guard let globalResolverId = value.globalResolverId else {
            return nil
        }
        return "/global-resolver/\(globalResolverId.urlPercentEncoding())"
    }
}

extension DisableDNSViewInput {

    static func urlPathProvider(_ value: DisableDNSViewInput) -> Swift.String? {
        guard let dnsViewId = value.dnsViewId else {
            return nil
        }
        return "/dns-views/\(dnsViewId.urlPercentEncoding())/disable"
    }
}

extension DisassociateHostedZoneInput {

    static func urlPathProvider(_ value: DisassociateHostedZoneInput) -> Swift.String? {
        guard let hostedZoneId = value.hostedZoneId else {
            return nil
        }
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/hosted-zone-associations/hosted-zone/\(hostedZoneId.urlPercentEncoding())/resource-arn/\(resourceArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension EnableDNSViewInput {

    static func urlPathProvider(_ value: EnableDNSViewInput) -> Swift.String? {
        guard let dnsViewId = value.dnsViewId else {
            return nil
        }
        return "/dns-views/\(dnsViewId.urlPercentEncoding())/enable"
    }
}

extension GetAccessSourceInput {

    static func urlPathProvider(_ value: GetAccessSourceInput) -> Swift.String? {
        guard let accessSourceId = value.accessSourceId else {
            return nil
        }
        return "/access-sources/\(accessSourceId.urlPercentEncoding())"
    }
}

extension GetAccessTokenInput {

    static func urlPathProvider(_ value: GetAccessTokenInput) -> Swift.String? {
        guard let accessTokenId = value.accessTokenId else {
            return nil
        }
        return "/tokens/\(accessTokenId.urlPercentEncoding())"
    }
}

extension GetDNSViewInput {

    static func urlPathProvider(_ value: GetDNSViewInput) -> Swift.String? {
        guard let dnsViewId = value.dnsViewId else {
            return nil
        }
        return "/dns-views/\(dnsViewId.urlPercentEncoding())"
    }
}

extension GetFirewallDomainListInput {

    static func urlPathProvider(_ value: GetFirewallDomainListInput) -> Swift.String? {
        guard let firewallDomainListId = value.firewallDomainListId else {
            return nil
        }
        return "/firewall-domain-lists/\(firewallDomainListId.urlPercentEncoding())"
    }
}

extension GetFirewallRuleInput {

    static func urlPathProvider(_ value: GetFirewallRuleInput) -> Swift.String? {
        guard let firewallRuleId = value.firewallRuleId else {
            return nil
        }
        return "/firewall-rules/\(firewallRuleId.urlPercentEncoding())"
    }
}

extension GetGlobalResolverInput {

    static func urlPathProvider(_ value: GetGlobalResolverInput) -> Swift.String? {
        guard let globalResolverId = value.globalResolverId else {
            return nil
        }
        return "/global-resolver/\(globalResolverId.urlPercentEncoding())"
    }
}

extension GetHostedZoneAssociationInput {

    static func urlPathProvider(_ value: GetHostedZoneAssociationInput) -> Swift.String? {
        guard let hostedZoneAssociationId = value.hostedZoneAssociationId else {
            return nil
        }
        return "/hosted-zone-associations/\(hostedZoneAssociationId.urlPercentEncoding())"
    }
}

extension GetManagedFirewallDomainListInput {

    static func urlPathProvider(_ value: GetManagedFirewallDomainListInput) -> Swift.String? {
        guard let managedFirewallDomainListId = value.managedFirewallDomainListId else {
            return nil
        }
        return "/managed-firewall-domain-lists/\(managedFirewallDomainListId.urlPercentEncoding())"
    }
}

extension ImportFirewallDomainsInput {

    static func urlPathProvider(_ value: ImportFirewallDomainsInput) -> Swift.String? {
        guard let firewallDomainListId = value.firewallDomainListId else {
            return nil
        }
        return "/firewall-domain-lists/\(firewallDomainListId.urlPercentEncoding())/domains/s3_file_url"
    }
}

extension ListAccessSourcesInput {

    static func urlPathProvider(_ value: ListAccessSourcesInput) -> Swift.String? {
        return "/access-sources"
    }
}

extension ListAccessSourcesInput {

    static func queryItemProvider(_ value: ListAccessSourcesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let filters = value.filters {
            let currentQueryItemNames = items.map({$0.name})
            filters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    value0.forEach { value1 in
                        let queryItem = Smithy.URIQueryItem(name: key0.urlPercentEncoding(), value: value1.urlPercentEncoding())
                        items.append(queryItem)
                    }
                }
            }
        }
        return items
    }
}

extension ListAccessTokensInput {

    static func urlPathProvider(_ value: ListAccessTokensInput) -> Swift.String? {
        guard let dnsViewId = value.dnsViewId else {
            return nil
        }
        return "/tokens/dns-view/\(dnsViewId.urlPercentEncoding())"
    }
}

extension ListAccessTokensInput {

    static func queryItemProvider(_ value: ListAccessTokensInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let filters = value.filters {
            let currentQueryItemNames = items.map({$0.name})
            filters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    value0.forEach { value1 in
                        let queryItem = Smithy.URIQueryItem(name: key0.urlPercentEncoding(), value: value1.urlPercentEncoding())
                        items.append(queryItem)
                    }
                }
            }
        }
        return items
    }
}

extension ListDNSViewsInput {

    static func urlPathProvider(_ value: ListDNSViewsInput) -> Swift.String? {
        guard let globalResolverId = value.globalResolverId else {
            return nil
        }
        return "/dns-views/resolver/\(globalResolverId.urlPercentEncoding())"
    }
}

extension ListDNSViewsInput {

    static func queryItemProvider(_ value: ListDNSViewsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListFirewallDomainListsInput {

    static func urlPathProvider(_ value: ListFirewallDomainListsInput) -> Swift.String? {
        return "/firewall-domain-lists"
    }
}

extension ListFirewallDomainListsInput {

    static func queryItemProvider(_ value: ListFirewallDomainListsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let globalResolverId = value.globalResolverId {
            let globalResolverIdQueryItem = Smithy.URIQueryItem(name: "global_resolver_id".urlPercentEncoding(), value: Swift.String(globalResolverId).urlPercentEncoding())
            items.append(globalResolverIdQueryItem)
        }
        return items
    }
}

extension ListFirewallDomainsInput {

    static func urlPathProvider(_ value: ListFirewallDomainsInput) -> Swift.String? {
        guard let firewallDomainListId = value.firewallDomainListId else {
            return nil
        }
        return "/firewall-domain-lists/\(firewallDomainListId.urlPercentEncoding())/domains"
    }
}

extension ListFirewallDomainsInput {

    static func queryItemProvider(_ value: ListFirewallDomainsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListFirewallRulesInput {

    static func urlPathProvider(_ value: ListFirewallRulesInput) -> Swift.String? {
        return "/firewall-rules"
    }
}

extension ListFirewallRulesInput {

    static func queryItemProvider(_ value: ListFirewallRulesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        guard let dnsViewId = value.dnsViewId else {
            let message = "Creating a URL Query Item failed. dnsViewId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let dnsViewIdQueryItem = Smithy.URIQueryItem(name: "dnsview_id".urlPercentEncoding(), value: Swift.String(dnsViewId).urlPercentEncoding())
        items.append(dnsViewIdQueryItem)
        if let filters = value.filters {
            let currentQueryItemNames = items.map({$0.name})
            filters.forEach { key0, value0 in
                if !currentQueryItemNames.contains(key0) {
                    value0.forEach { value1 in
                        let queryItem = Smithy.URIQueryItem(name: key0.urlPercentEncoding(), value: value1.urlPercentEncoding())
                        items.append(queryItem)
                    }
                }
            }
        }
        return items
    }
}

extension ListGlobalResolversInput {

    static func urlPathProvider(_ value: ListGlobalResolversInput) -> Swift.String? {
        return "/global-resolver"
    }
}

extension ListGlobalResolversInput {

    static func queryItemProvider(_ value: ListGlobalResolversInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListHostedZoneAssociationsInput {

    static func urlPathProvider(_ value: ListHostedZoneAssociationsInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/hosted-zone-associations/resource-arn/\(resourceArn.urlPercentEncoding(encodeForwardSlash: false))"
    }
}

extension ListHostedZoneAssociationsInput {

    static func queryItemProvider(_ value: ListHostedZoneAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListManagedFirewallDomainListsInput {

    static func urlPathProvider(_ value: ListManagedFirewallDomainListsInput) -> Swift.String? {
        guard let managedFirewallDomainListType = value.managedFirewallDomainListType else {
            return nil
        }
        return "/list-managed-firewall-domain-lists/\(managedFirewallDomainListType.urlPercentEncoding())"
    }
}

extension ListManagedFirewallDomainListsInput {

    static func queryItemProvider(_ value: ListManagedFirewallDomainListsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/get-all-tags"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tag-resource"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/untag-resource"
    }
}

extension UpdateAccessSourceInput {

    static func urlPathProvider(_ value: UpdateAccessSourceInput) -> Swift.String? {
        guard let accessSourceId = value.accessSourceId else {
            return nil
        }
        return "/access-sources/\(accessSourceId.urlPercentEncoding())"
    }
}

extension UpdateAccessTokenInput {

    static func urlPathProvider(_ value: UpdateAccessTokenInput) -> Swift.String? {
        guard let accessTokenId = value.accessTokenId else {
            return nil
        }
        return "/tokens/\(accessTokenId.urlPercentEncoding())"
    }
}

extension UpdateDNSViewInput {

    static func urlPathProvider(_ value: UpdateDNSViewInput) -> Swift.String? {
        guard let dnsViewId = value.dnsViewId else {
            return nil
        }
        return "/dns-views/\(dnsViewId.urlPercentEncoding())"
    }
}

extension UpdateFirewallDomainsInput {

    static func urlPathProvider(_ value: UpdateFirewallDomainsInput) -> Swift.String? {
        guard let firewallDomainListId = value.firewallDomainListId else {
            return nil
        }
        return "/firewall-domain-lists/\(firewallDomainListId.urlPercentEncoding())/domains"
    }
}

extension UpdateFirewallRuleInput {

    static func urlPathProvider(_ value: UpdateFirewallRuleInput) -> Swift.String? {
        guard let firewallRuleId = value.firewallRuleId else {
            return nil
        }
        return "/firewall-rules/\(firewallRuleId.urlPercentEncoding())"
    }
}

extension UpdateGlobalResolverInput {

    static func urlPathProvider(_ value: UpdateGlobalResolverInput) -> Swift.String? {
        guard let globalResolverId = value.globalResolverId else {
            return nil
        }
        return "/global-resolver/\(globalResolverId.urlPercentEncoding())"
    }
}

extension UpdateHostedZoneAssociationInput {

    static func urlPathProvider(_ value: UpdateHostedZoneAssociationInput) -> Swift.String? {
        guard let hostedZoneAssociationId = value.hostedZoneAssociationId else {
            return nil
        }
        return "/hosted-zone-associations/\(hostedZoneAssociationId.urlPercentEncoding())"
    }
}

extension AssociateHostedZoneInput {

    static func write(value: AssociateHostedZoneInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension BatchCreateFirewallRuleInput {

    static func write(value: BatchCreateFirewallRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["firewallRules"].writeList(value.firewallRules, memberWritingClosure: Route53GlobalResolverClientTypes.BatchCreateFirewallRuleInputItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDeleteFirewallRuleInput {

    static func write(value: BatchDeleteFirewallRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["firewallRules"].writeList(value.firewallRules, memberWritingClosure: Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleInputItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchUpdateFirewallRuleInput {

    static func write(value: BatchUpdateFirewallRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["firewallRules"].writeList(value.firewallRules, memberWritingClosure: Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleInputItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAccessSourceInput {

    static func write(value: CreateAccessSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cidr"].write(value.cidr)
        try writer["clientToken"].write(value.clientToken)
        try writer["dnsViewId"].write(value.dnsViewId)
        try writer["ipAddressType"].write(value.ipAddressType)
        try writer["name"].write(value.name)
        try writer["protocol"].write(value.`protocol`)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateAccessTokenInput {

    static func write(value: CreateAccessTokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["expiresAt"].writeTimestamp(value.expiresAt, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateDNSViewInput {

    static func write(value: CreateDNSViewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["dnssecValidation"].write(value.dnssecValidation)
        try writer["ednsClientSubnet"].write(value.ednsClientSubnet)
        try writer["firewallRulesFailOpen"].write(value.firewallRulesFailOpen)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateFirewallDomainListInput {

    static func write(value: CreateFirewallDomainListInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateFirewallRuleInput {

    static func write(value: CreateFirewallRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["blockOverrideDnsType"].write(value.blockOverrideDnsType)
        try writer["blockOverrideDomain"].write(value.blockOverrideDomain)
        try writer["blockOverrideTtl"].write(value.blockOverrideTtl)
        try writer["blockResponse"].write(value.blockResponse)
        try writer["clientToken"].write(value.clientToken)
        try writer["confidenceThreshold"].write(value.confidenceThreshold)
        try writer["description"].write(value.description)
        try writer["dnsAdvancedProtection"].write(value.dnsAdvancedProtection)
        try writer["dnsViewId"].write(value.dnsViewId)
        try writer["firewallDomainListId"].write(value.firewallDomainListId)
        try writer["name"].write(value.name)
        try writer["priority"].write(value.priority)
        try writer["qType"].write(value.qType)
    }
}

extension CreateGlobalResolverInput {

    static func write(value: CreateGlobalResolverInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["observabilityRegion"].write(value.observabilityRegion)
        try writer["regions"].writeList(value.regions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ImportFirewallDomainsInput {

    static func write(value: ImportFirewallDomainsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domainFileUrl"].write(value.domainFileUrl)
        try writer["operation"].write(value.operation)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateAccessSourceInput {

    static func write(value: UpdateAccessSourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cidr"].write(value.cidr)
        try writer["ipAddressType"].write(value.ipAddressType)
        try writer["name"].write(value.name)
        try writer["protocol"].write(value.`protocol`)
    }
}

extension UpdateAccessTokenInput {

    static func write(value: UpdateAccessTokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension UpdateDNSViewInput {

    static func write(value: UpdateDNSViewInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["dnssecValidation"].write(value.dnssecValidation)
        try writer["ednsClientSubnet"].write(value.ednsClientSubnet)
        try writer["firewallRulesFailOpen"].write(value.firewallRulesFailOpen)
        try writer["name"].write(value.name)
    }
}

extension UpdateFirewallDomainsInput {

    static func write(value: UpdateFirewallDomainsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["domains"].writeList(value.domains, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["operation"].write(value.operation)
    }
}

extension UpdateFirewallRuleInput {

    static func write(value: UpdateFirewallRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["blockOverrideDnsType"].write(value.blockOverrideDnsType)
        try writer["blockOverrideDomain"].write(value.blockOverrideDomain)
        try writer["blockOverrideTtl"].write(value.blockOverrideTtl)
        try writer["blockResponse"].write(value.blockResponse)
        try writer["clientToken"].write(value.clientToken)
        try writer["confidenceThreshold"].write(value.confidenceThreshold)
        try writer["description"].write(value.description)
        try writer["dnsAdvancedProtection"].write(value.dnsAdvancedProtection)
        try writer["name"].write(value.name)
        try writer["priority"].write(value.priority)
    }
}

extension UpdateGlobalResolverInput {

    static func write(value: UpdateGlobalResolverInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["observabilityRegion"].write(value.observabilityRegion)
    }
}

extension UpdateHostedZoneAssociationInput {

    static func write(value: UpdateHostedZoneAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension AssociateHostedZoneOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateHostedZoneOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateHostedZoneOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.hostedZoneId = try reader["hostedZoneId"].readIfPresent() ?? ""
        value.hostedZoneName = try reader["hostedZoneName"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BatchCreateFirewallRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateFirewallRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreateFirewallRuleOutput()
        value.failures = try reader["failures"].readListIfPresent(memberReadingClosure: Route53GlobalResolverClientTypes.BatchCreateFirewallRuleOutputItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.successes = try reader["successes"].readListIfPresent(memberReadingClosure: Route53GlobalResolverClientTypes.BatchCreateFirewallRuleOutputItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchDeleteFirewallRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteFirewallRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteFirewallRuleOutput()
        value.failures = try reader["failures"].readListIfPresent(memberReadingClosure: Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleOutputItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.successes = try reader["successes"].readListIfPresent(memberReadingClosure: Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleOutputItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchUpdateFirewallRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateFirewallRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateFirewallRuleOutput()
        value.failures = try reader["failures"].readListIfPresent(memberReadingClosure: Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleOutputItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.successes = try reader["successes"].readListIfPresent(memberReadingClosure: Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleOutputItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CreateAccessSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAccessSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAccessSourceOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.cidr = try reader["cidr"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.dnsViewId = try reader["dnsViewId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.ipAddressType = try reader["ipAddressType"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CreateAccessTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAccessTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAccessTokenOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.dnsViewId = try reader["dnsViewId"].readIfPresent() ?? ""
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension CreateDNSViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDNSViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDNSViewOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.dnssecValidation = try reader["dnssecValidation"].readIfPresent() ?? .sdkUnknown("")
        value.ednsClientSubnet = try reader["ednsClientSubnet"].readIfPresent() ?? .sdkUnknown("")
        value.firewallRulesFailOpen = try reader["firewallRulesFailOpen"].readIfPresent() ?? .sdkUnknown("")
        value.globalResolverId = try reader["globalResolverId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CreateFirewallDomainListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFirewallDomainListOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFirewallDomainListOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.domainCount = try reader["domainCount"].readIfPresent() ?? 0
        value.globalResolverId = try reader["globalResolverId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CreateFirewallRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFirewallRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFirewallRuleOutput()
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        value.blockOverrideDnsType = try reader["blockOverrideDnsType"].readIfPresent()
        value.blockOverrideDomain = try reader["blockOverrideDomain"].readIfPresent()
        value.blockOverrideTtl = try reader["blockOverrideTtl"].readIfPresent()
        value.blockResponse = try reader["blockResponse"].readIfPresent()
        value.confidenceThreshold = try reader["confidenceThreshold"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.dnsAdvancedProtection = try reader["dnsAdvancedProtection"].readIfPresent()
        value.dnsViewId = try reader["dnsViewId"].readIfPresent() ?? ""
        value.firewallDomainListId = try reader["firewallDomainListId"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.priority = try reader["priority"].readIfPresent() ?? 0
        value.queryType = try reader["queryType"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CreateGlobalResolverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGlobalResolverOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGlobalResolverOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.dnsName = try reader["dnsName"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.ipv4Addresses = try reader["ipv4Addresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.name = try reader["name"].readIfPresent() ?? ""
        value.observabilityRegion = try reader["observabilityRegion"].readIfPresent()
        value.regions = try reader["regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension DeleteAccessSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccessSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAccessSourceOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.cidr = try reader["cidr"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.dnsViewId = try reader["dnsViewId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.ipAddressType = try reader["ipAddressType"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension DeleteAccessTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccessTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAccessTokenOutput()
        value.deletedAt = try reader["deletedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.id = try reader["id"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteDNSViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDNSViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDNSViewOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.dnssecValidation = try reader["dnssecValidation"].readIfPresent() ?? .sdkUnknown("")
        value.ednsClientSubnet = try reader["ednsClientSubnet"].readIfPresent() ?? .sdkUnknown("")
        value.firewallRulesFailOpen = try reader["firewallRulesFailOpen"].readIfPresent() ?? .sdkUnknown("")
        value.globalResolverId = try reader["globalResolverId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension DeleteFirewallDomainListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFirewallDomainListOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFirewallDomainListOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DeleteFirewallRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFirewallRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteFirewallRuleOutput()
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        value.blockOverrideDnsType = try reader["blockOverrideDnsType"].readIfPresent()
        value.blockOverrideDomain = try reader["blockOverrideDomain"].readIfPresent()
        value.blockOverrideTtl = try reader["blockOverrideTtl"].readIfPresent()
        value.blockResponse = try reader["blockResponse"].readIfPresent()
        value.confidenceThreshold = try reader["confidenceThreshold"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.dnsAdvancedProtection = try reader["dnsAdvancedProtection"].readIfPresent()
        value.dnsViewId = try reader["dnsViewId"].readIfPresent() ?? ""
        value.firewallDomainListId = try reader["firewallDomainListId"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.priority = try reader["priority"].readIfPresent() ?? 0
        value.queryType = try reader["queryType"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension DeleteGlobalResolverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGlobalResolverOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteGlobalResolverOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.dnsName = try reader["dnsName"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.ipv4Addresses = try reader["ipv4Addresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.name = try reader["name"].readIfPresent() ?? ""
        value.observabilityRegion = try reader["observabilityRegion"].readIfPresent()
        value.regions = try reader["regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension DisableDNSViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisableDNSViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisableDNSViewOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.dnssecValidation = try reader["dnssecValidation"].readIfPresent() ?? .sdkUnknown("")
        value.ednsClientSubnet = try reader["ednsClientSubnet"].readIfPresent() ?? .sdkUnknown("")
        value.firewallRulesFailOpen = try reader["firewallRulesFailOpen"].readIfPresent() ?? .sdkUnknown("")
        value.globalResolverId = try reader["globalResolverId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension DisassociateHostedZoneOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateHostedZoneOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateHostedZoneOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.hostedZoneId = try reader["hostedZoneId"].readIfPresent() ?? ""
        value.hostedZoneName = try reader["hostedZoneName"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension EnableDNSViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> EnableDNSViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = EnableDNSViewOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.dnssecValidation = try reader["dnssecValidation"].readIfPresent() ?? .sdkUnknown("")
        value.ednsClientSubnet = try reader["ednsClientSubnet"].readIfPresent() ?? .sdkUnknown("")
        value.firewallRulesFailOpen = try reader["firewallRulesFailOpen"].readIfPresent() ?? .sdkUnknown("")
        value.globalResolverId = try reader["globalResolverId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetAccessSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccessSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccessSourceOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.cidr = try reader["cidr"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.dnsViewId = try reader["dnsViewId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.ipAddressType = try reader["ipAddressType"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetAccessTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAccessTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAccessTokenOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.dnsViewId = try reader["dnsViewId"].readIfPresent() ?? ""
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.globalResolverId = try reader["globalResolverId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension GetDNSViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDNSViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDNSViewOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.dnssecValidation = try reader["dnssecValidation"].readIfPresent() ?? .sdkUnknown("")
        value.ednsClientSubnet = try reader["ednsClientSubnet"].readIfPresent() ?? .sdkUnknown("")
        value.firewallRulesFailOpen = try reader["firewallRulesFailOpen"].readIfPresent() ?? .sdkUnknown("")
        value.globalResolverId = try reader["globalResolverId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetFirewallDomainListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFirewallDomainListOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFirewallDomainListOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.domainCount = try reader["domainCount"].readIfPresent() ?? 0
        value.globalResolverId = try reader["globalResolverId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetFirewallRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFirewallRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFirewallRuleOutput()
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        value.blockOverrideDnsType = try reader["blockOverrideDnsType"].readIfPresent()
        value.blockOverrideDomain = try reader["blockOverrideDomain"].readIfPresent()
        value.blockOverrideTtl = try reader["blockOverrideTtl"].readIfPresent()
        value.blockResponse = try reader["blockResponse"].readIfPresent()
        value.confidenceThreshold = try reader["confidenceThreshold"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.dnsAdvancedProtection = try reader["dnsAdvancedProtection"].readIfPresent()
        value.dnsViewId = try reader["dnsViewId"].readIfPresent() ?? ""
        value.firewallDomainListId = try reader["firewallDomainListId"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.priority = try reader["priority"].readIfPresent() ?? 0
        value.queryType = try reader["queryType"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetGlobalResolverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGlobalResolverOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGlobalResolverOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.dnsName = try reader["dnsName"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.ipv4Addresses = try reader["ipv4Addresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.name = try reader["name"].readIfPresent() ?? ""
        value.observabilityRegion = try reader["observabilityRegion"].readIfPresent()
        value.regions = try reader["regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetHostedZoneAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetHostedZoneAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetHostedZoneAssociationOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.hostedZoneId = try reader["hostedZoneId"].readIfPresent() ?? ""
        value.hostedZoneName = try reader["hostedZoneName"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetManagedFirewallDomainListOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetManagedFirewallDomainListOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetManagedFirewallDomainListOutput()
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.managedListType = try reader["managedListType"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension ImportFirewallDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportFirewallDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ImportFirewallDomainsOutput()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ListAccessSourcesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccessSourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccessSourcesOutput()
        value.accessSources = try reader["accessSources"].readListIfPresent(memberReadingClosure: Route53GlobalResolverClientTypes.AccessSourcesItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAccessTokensOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccessTokensOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccessTokensOutput()
        value.accessTokens = try reader["accessTokens"].readListIfPresent(memberReadingClosure: Route53GlobalResolverClientTypes.AccessTokenItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDNSViewsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDNSViewsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDNSViewsOutput()
        value.dnsViews = try reader["dnsViews"].readListIfPresent(memberReadingClosure: Route53GlobalResolverClientTypes.DNSViewSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFirewallDomainListsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFirewallDomainListsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFirewallDomainListsOutput()
        value.firewallDomainLists = try reader["firewallDomainLists"].readListIfPresent(memberReadingClosure: Route53GlobalResolverClientTypes.FirewallDomainListsItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFirewallDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFirewallDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFirewallDomainsOutput()
        value.domains = try reader["domains"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFirewallRulesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFirewallRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFirewallRulesOutput()
        value.firewallRules = try reader["firewallRules"].readListIfPresent(memberReadingClosure: Route53GlobalResolverClientTypes.FirewallRulesItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListGlobalResolversOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGlobalResolversOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGlobalResolversOutput()
        value.globalResolvers = try reader["globalResolvers"].readListIfPresent(memberReadingClosure: Route53GlobalResolverClientTypes.GlobalResolversItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListHostedZoneAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListHostedZoneAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListHostedZoneAssociationsOutput()
        value.hostedZoneAssociations = try reader["hostedZoneAssociations"].readListIfPresent(memberReadingClosure: Route53GlobalResolverClientTypes.HostedZoneAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListManagedFirewallDomainListsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListManagedFirewallDomainListsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListManagedFirewallDomainListsOutput()
        value.managedFirewallDomainLists = try reader["managedFirewallDomainLists"].readListIfPresent(memberReadingClosure: Route53GlobalResolverClientTypes.ManagedFirewallDomainListsItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAccessSourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccessSourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAccessSourceOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.cidr = try reader["cidr"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.dnsViewId = try reader["dnsViewId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.ipAddressType = try reader["ipAddressType"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension UpdateAccessTokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccessTokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAccessTokenOutput()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension UpdateDNSViewOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDNSViewOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDNSViewOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.dnssecValidation = try reader["dnssecValidation"].readIfPresent() ?? .sdkUnknown("")
        value.ednsClientSubnet = try reader["ednsClientSubnet"].readIfPresent() ?? .sdkUnknown("")
        value.firewallRulesFailOpen = try reader["firewallRulesFailOpen"].readIfPresent() ?? .sdkUnknown("")
        value.globalResolverId = try reader["globalResolverId"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension UpdateFirewallDomainsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFirewallDomainsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFirewallDomainsOutput()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension UpdateFirewallRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFirewallRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateFirewallRuleOutput()
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        value.blockOverrideDnsType = try reader["blockOverrideDnsType"].readIfPresent()
        value.blockOverrideDomain = try reader["blockOverrideDomain"].readIfPresent()
        value.blockOverrideTtl = try reader["blockOverrideTtl"].readIfPresent()
        value.blockResponse = try reader["blockResponse"].readIfPresent()
        value.confidenceThreshold = try reader["confidenceThreshold"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.dnsAdvancedProtection = try reader["dnsAdvancedProtection"].readIfPresent()
        value.dnsViewId = try reader["dnsViewId"].readIfPresent() ?? ""
        value.firewallDomainListId = try reader["firewallDomainListId"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.priority = try reader["priority"].readIfPresent() ?? 0
        value.queryType = try reader["queryType"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension UpdateGlobalResolverOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGlobalResolverOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGlobalResolverOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.dnsName = try reader["dnsName"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.ipv4Addresses = try reader["ipv4Addresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.name = try reader["name"].readIfPresent() ?? ""
        value.observabilityRegion = try reader["observabilityRegion"].readIfPresent()
        value.regions = try reader["regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension UpdateHostedZoneAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateHostedZoneAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateHostedZoneAssociationOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.hostedZoneId = try reader["hostedZoneId"].readIfPresent() ?? ""
        value.hostedZoneName = try reader["hostedZoneName"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

enum AssociateHostedZoneOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchCreateFirewallRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteFirewallRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUpdateFirewallRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAccessSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAccessTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDNSViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFirewallDomainListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFirewallRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGlobalResolverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccessSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccessTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDNSViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFirewallDomainListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFirewallRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGlobalResolverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisableDNSViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateHostedZoneOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum EnableDNSViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccessSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAccessTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDNSViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFirewallDomainListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFirewallRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGlobalResolverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetHostedZoneAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetManagedFirewallDomainListOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportFirewallDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccessSourcesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccessTokensOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDNSViewsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFirewallDomainListsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFirewallDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFirewallRulesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGlobalResolversOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListHostedZoneAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListManagedFirewallDomainListsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccessSourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccessTokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDNSViewOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFirewallDomainsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFirewallRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGlobalResolverOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateHostedZoneAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: Route53GlobalResolverClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension Route53GlobalResolverClientTypes.BatchCreateFirewallRuleOutputItem {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53GlobalResolverClientTypes.BatchCreateFirewallRuleOutputItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53GlobalResolverClientTypes.BatchCreateFirewallRuleOutputItem()
        value.firewallRule = try reader["firewallRule"].readIfPresent(with: Route53GlobalResolverClientTypes.BatchCreateFirewallRuleResult.read(from:))
        value.code = try reader["code"].readIfPresent() ?? 0
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension Route53GlobalResolverClientTypes.BatchCreateFirewallRuleResult {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53GlobalResolverClientTypes.BatchCreateFirewallRuleResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53GlobalResolverClientTypes.BatchCreateFirewallRuleResult()
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        value.blockOverrideDnsType = try reader["blockOverrideDnsType"].readIfPresent()
        value.blockOverrideDomain = try reader["blockOverrideDomain"].readIfPresent()
        value.blockOverrideTtl = try reader["blockOverrideTtl"].readIfPresent()
        value.blockResponse = try reader["blockResponse"].readIfPresent()
        value.clientToken = try reader["clientToken"].readIfPresent() ?? ""
        value.confidenceThreshold = try reader["confidenceThreshold"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.dnsAdvancedProtection = try reader["dnsAdvancedProtection"].readIfPresent()
        value.firewallDomainListId = try reader["firewallDomainListId"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.managedDomainListName = try reader["managedDomainListName"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.priority = try reader["priority"].readIfPresent()
        value.dnsViewId = try reader["dnsViewId"].readIfPresent() ?? ""
        value.queryType = try reader["queryType"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleOutputItem {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleOutputItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleOutputItem()
        value.firewallRule = try reader["firewallRule"].readIfPresent(with: Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleResult.read(from:))
        value.code = try reader["code"].readIfPresent() ?? 0
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleResult {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleResult()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleOutputItem {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleOutputItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleOutputItem()
        value.firewallRule = try reader["firewallRule"].readIfPresent(with: Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleResult.read(from:))
        value.code = try reader["code"].readIfPresent() ?? 0
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleResult {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleResult()
        value.action = try reader["action"].readIfPresent()
        value.blockOverrideDnsType = try reader["blockOverrideDnsType"].readIfPresent()
        value.blockOverrideDomain = try reader["blockOverrideDomain"].readIfPresent()
        value.blockOverrideTtl = try reader["blockOverrideTtl"].readIfPresent()
        value.blockResponse = try reader["blockResponse"].readIfPresent()
        value.clientToken = try reader["clientToken"].readIfPresent()
        value.confidenceThreshold = try reader["confidenceThreshold"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.description = try reader["description"].readIfPresent()
        value.dnsAdvancedProtection = try reader["dnsAdvancedProtection"].readIfPresent()
        value.firewallDomainListId = try reader["firewallDomainListId"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.priority = try reader["priority"].readIfPresent()
        value.dnsViewId = try reader["dnsViewId"].readIfPresent()
        value.queryType = try reader["queryType"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension Route53GlobalResolverClientTypes.AccessSourcesItem {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53GlobalResolverClientTypes.AccessSourcesItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53GlobalResolverClientTypes.AccessSourcesItem()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.cidr = try reader["cidr"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.id = try reader["id"].readIfPresent() ?? ""
        value.ipAddressType = try reader["ipAddressType"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent()
        value.dnsViewId = try reader["dnsViewId"].readIfPresent() ?? ""
        value.`protocol` = try reader["protocol"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension Route53GlobalResolverClientTypes.AccessTokenItem {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53GlobalResolverClientTypes.AccessTokenItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53GlobalResolverClientTypes.AccessTokenItem()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.dnsViewId = try reader["dnsViewId"].readIfPresent() ?? ""
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.globalResolverId = try reader["globalResolverId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension Route53GlobalResolverClientTypes.DNSViewSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53GlobalResolverClientTypes.DNSViewSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53GlobalResolverClientTypes.DNSViewSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent() ?? ""
        value.dnssecValidation = try reader["dnssecValidation"].readIfPresent() ?? .sdkUnknown("")
        value.ednsClientSubnet = try reader["ednsClientSubnet"].readIfPresent() ?? .sdkUnknown("")
        value.firewallRulesFailOpen = try reader["firewallRulesFailOpen"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.globalResolverId = try reader["globalResolverId"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension Route53GlobalResolverClientTypes.FirewallDomainListsItem {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53GlobalResolverClientTypes.FirewallDomainListsItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53GlobalResolverClientTypes.FirewallDomainListsItem()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.globalResolverId = try reader["globalResolverId"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension Route53GlobalResolverClientTypes.FirewallRulesItem {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53GlobalResolverClientTypes.FirewallRulesItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53GlobalResolverClientTypes.FirewallRulesItem()
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        value.blockOverrideDnsType = try reader["blockOverrideDnsType"].readIfPresent()
        value.blockOverrideDomain = try reader["blockOverrideDomain"].readIfPresent()
        value.blockOverrideTtl = try reader["blockOverrideTtl"].readIfPresent()
        value.blockResponse = try reader["blockResponse"].readIfPresent()
        value.confidenceThreshold = try reader["confidenceThreshold"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.dnsAdvancedProtection = try reader["dnsAdvancedProtection"].readIfPresent()
        value.firewallDomainListId = try reader["firewallDomainListId"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.priority = try reader["priority"].readIfPresent() ?? 0
        value.dnsViewId = try reader["dnsViewId"].readIfPresent() ?? ""
        value.queryType = try reader["queryType"].readIfPresent()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension Route53GlobalResolverClientTypes.GlobalResolversItem {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53GlobalResolverClientTypes.GlobalResolversItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53GlobalResolverClientTypes.GlobalResolversItem()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.clientToken = try reader["clientToken"].readIfPresent() ?? ""
        value.dnsName = try reader["dnsName"].readIfPresent() ?? ""
        value.observabilityRegion = try reader["observabilityRegion"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.regions = try reader["regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.ipv4Addresses = try reader["ipv4Addresses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension Route53GlobalResolverClientTypes.HostedZoneAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53GlobalResolverClientTypes.HostedZoneAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53GlobalResolverClientTypes.HostedZoneAssociationSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.hostedZoneId = try reader["hostedZoneId"].readIfPresent() ?? ""
        value.hostedZoneName = try reader["hostedZoneName"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension Route53GlobalResolverClientTypes.ManagedFirewallDomainListsItem {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53GlobalResolverClientTypes.ManagedFirewallDomainListsItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53GlobalResolverClientTypes.ManagedFirewallDomainListsItem()
        value.description = try reader["description"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.managedListType = try reader["managedListType"].readIfPresent() ?? ""
        return value
    }
}

extension Route53GlobalResolverClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53GlobalResolverClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53GlobalResolverClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension Route53GlobalResolverClientTypes.BatchCreateFirewallRuleInputItem {

    static func write(value: Route53GlobalResolverClientTypes.BatchCreateFirewallRuleInputItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["blockOverrideDnsType"].write(value.blockOverrideDnsType)
        try writer["blockOverrideDomain"].write(value.blockOverrideDomain)
        try writer["blockOverrideTtl"].write(value.blockOverrideTtl)
        try writer["blockResponse"].write(value.blockResponse)
        try writer["clientToken"].write(value.clientToken)
        try writer["confidenceThreshold"].write(value.confidenceThreshold)
        try writer["description"].write(value.description)
        try writer["dnsAdvancedProtection"].write(value.dnsAdvancedProtection)
        try writer["dnsViewId"].write(value.dnsViewId)
        try writer["firewallDomainListId"].write(value.firewallDomainListId)
        try writer["name"].write(value.name)
        try writer["priority"].write(value.priority)
        try writer["qType"].write(value.qType)
    }
}

extension Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleInputItem {

    static func write(value: Route53GlobalResolverClientTypes.BatchDeleteFirewallRuleInputItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["firewallRuleId"].write(value.firewallRuleId)
    }
}

extension Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleInputItem {

    static func write(value: Route53GlobalResolverClientTypes.BatchUpdateFirewallRuleInputItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["blockOverrideDnsType"].write(value.blockOverrideDnsType)
        try writer["blockOverrideDomain"].write(value.blockOverrideDomain)
        try writer["blockOverrideTtl"].write(value.blockOverrideTtl)
        try writer["blockResponse"].write(value.blockResponse)
        try writer["confidenceThreshold"].write(value.confidenceThreshold)
        try writer["description"].write(value.description)
        try writer["dnsAdvancedProtection"].write(value.dnsAdvancedProtection)
        try writer["firewallRuleId"].write(value.firewallRuleId)
        try writer["name"].write(value.name)
        try writer["priority"].write(value.priority)
    }
}

public enum Route53GlobalResolverClientTypes {}
