//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError

extension SigninClientTypes {

    /// OAuth 2.0 error codes returned by the server Standard OAuth 2.0 error codes used in error responses to indicate the specific type of error that occurred during token operations.
    package enum OAuth2ErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Authorization code has expired
        case authcodeExpired
        /// Insufficient permissions to perform this operation
        case insufficientPermissions
        /// The request is missing a required parameter, includes an invalid parameter value, or is otherwise malformed
        case invalidRequest
        /// Internal server error occurred
        case serverError
        /// Token has expired and needs to be refreshed
        case tokenExpired
        /// User credentials have been changed
        case userCredentialsChanged
        case sdkUnknown(Swift.String)

        public static var allCases: [OAuth2ErrorCode] {
            return [
                .authcodeExpired,
                .insufficientPermissions,
                .invalidRequest,
                .serverError,
                .tokenExpired,
                .userCredentialsChanged
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .authcodeExpired: return "AUTHCODE_EXPIRED"
            case .insufficientPermissions: return "INSUFFICIENT_PERMISSIONS"
            case .invalidRequest: return "INVALID_REQUEST"
            case .serverError: return "server_error"
            case .tokenExpired: return "TOKEN_EXPIRED"
            case .userCredentialsChanged: return "USER_CREDENTIALS_CHANGED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Error thrown for access denied scenarios with flexible HTTP status mapping Runtime HTTP Status Code Mapping:
///
/// * HTTP 401 (Unauthorized): TOKEN_EXPIRED, AUTHCODE_EXPIRED
///
/// * HTTP 403 (Forbidden): USER_CREDENTIALS_CHANGED, INSUFFICIENT_PERMISSIONS
///
///
/// The specific HTTP status code is determined at runtime based on the error enum value. Consumers should use the error field to determine the specific access denial reason.
package struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    package struct Properties: Swift.Sendable {
        /// OAuth 2.0 error code indicating the specific type of access denial Can be TOKEN_EXPIRED, AUTHCODE_EXPIRED, USER_CREDENTIALS_CHANGED, or INSUFFICIENT_PERMISSIONS
        /// This member is required.
        public internal(set) var error: SigninClientTypes.OAuth2ErrorCode? = nil
        /// Detailed message explaining the access denial Provides specific information about why access was denied
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public var message: Swift.String?
    public var requestID: Swift.String?

    public init(
        error: SigninClientTypes.OAuth2ErrorCode? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.error = error
        self.properties.message = message
    }
}

extension SigninClientTypes {

    /// AWS credentials structure containing temporary access credentials The scoped-down, 15 minute duration AWS credentials. Scoping down will be based on CLI policy (CLI team needs to create it). Similar to cloud shell implementation.
    package struct AccessToken: Swift.Sendable {
        /// AWS access key ID for temporary credentials
        /// This member is required.
        public var accessKeyId: Swift.String?
        /// AWS secret access key for temporary credentials
        /// This member is required.
        public var secretAccessKey: Swift.String?
        /// AWS session token for temporary credentials
        /// This member is required.
        public var sessionToken: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            secretAccessKey: Swift.String? = nil,
            sessionToken: Swift.String? = nil
        ) {
            self.accessKeyId = accessKeyId
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }
    }
}

extension SigninClientTypes.AccessToken: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

/// Error thrown when an internal server error occurs HTTP Status Code: 500 Internal Server Error Used for unexpected server-side errors that prevent request processing.
package struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    package struct Properties: Swift.Sendable {
        /// OAuth 2.0 error code indicating server error Will be SERVER_ERROR for internal server errors
        /// This member is required.
        public internal(set) var error: SigninClientTypes.OAuth2ErrorCode? = nil
        /// Detailed message explaining the server error May include error details for debugging purposes
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public var message: Swift.String?
    public var requestID: Swift.String?

    public init(
        error: SigninClientTypes.OAuth2ErrorCode? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.error = error
        self.properties.message = message
    }
}

/// Error thrown when rate limit is exceeded HTTP Status Code: 429 Too Many Requests Possible OAuth2ErrorCode values:
///
/// * INVALID_REQUEST: Rate limiting, too many requests, abuse prevention
///
///
/// Possible causes:
///
/// * Too many token requests from the same client
///
/// * Rate limiting based on client_id or IP address
///
/// * Abuse prevention mechanisms triggered
///
/// * Service protection against excessive token generation
package struct TooManyRequestsError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    package struct Properties: Swift.Sendable {
        /// OAuth 2.0 error code indicating the specific type of error Will be INVALID_REQUEST for rate limiting scenarios
        /// This member is required.
        public internal(set) var error: SigninClientTypes.OAuth2ErrorCode? = nil
        /// Detailed message about the rate limiting May include retry-after information or rate limit details
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsError" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public var message: Swift.String?
    public var requestID: Swift.String?

    public init(
        error: SigninClientTypes.OAuth2ErrorCode? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.error = error
        self.properties.message = message
    }
}

/// Error thrown when request validation fails HTTP Status Code: 400 Bad Request Used for request validation errors such as malformed parameters, missing required fields, or invalid parameter values.
package struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    package struct Properties: Swift.Sendable {
        /// OAuth 2.0 error code indicating validation failure Will be INVALID_REQUEST for validation errors
        /// This member is required.
        public internal(set) var error: SigninClientTypes.OAuth2ErrorCode? = nil
        /// Detailed message explaining the validation failure Provides specific information about which validation failed
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public var message: Swift.String?
    public var requestID: Swift.String?

    public init(
        error: SigninClientTypes.OAuth2ErrorCode? = nil,
        message: Swift.String? = nil
    ) {
        self.properties.error = error
        self.properties.message = message
    }
}

extension SigninClientTypes {

    /// Request body payload for CreateOAuth2Token operation The operation type is determined by the grant_type parameter:
    ///
    /// * grant_type=authorization_code: Requires code, redirect_uri, code_verifier
    ///
    /// * grant_type=refresh_token: Requires refresh_token
    package struct CreateOAuth2TokenRequestBody: Swift.Sendable {
        /// The client identifier (ARN) used during Sign-In onboarding Required for both authorization code and refresh token flows
        /// This member is required.
        public var clientId: Swift.String?
        /// The authorization code received from /v1/authorize Required only when grant_type=authorization_code
        public var code: Swift.String?
        /// PKCE code verifier to prove possession of the original code challenge Required only when grant_type=authorization_code
        public var codeVerifier: Swift.String?
        /// OAuth 2.0 grant type - determines which flow is used Must be "authorization_code" or "refresh_token"
        /// This member is required.
        public var grantType: Swift.String?
        /// The redirect URI that must match the original authorization request Required only when grant_type=authorization_code
        public var redirectUri: Swift.String?
        /// The refresh token returned from auth_code redemption Required only when grant_type=refresh_token
        public var refreshToken: Swift.String?

        public init(
            clientId: Swift.String? = nil,
            code: Swift.String? = nil,
            codeVerifier: Swift.String? = nil,
            grantType: Swift.String? = nil,
            redirectUri: Swift.String? = nil,
            refreshToken: Swift.String? = nil
        ) {
            self.clientId = clientId
            self.code = code
            self.codeVerifier = codeVerifier
            self.grantType = grantType
            self.redirectUri = redirectUri
            self.refreshToken = refreshToken
        }
    }
}

extension SigninClientTypes.CreateOAuth2TokenRequestBody: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOAuth2TokenRequestBody(clientId: \(Swift.String(describing: clientId)), code: \(Swift.String(describing: code)), codeVerifier: \(Swift.String(describing: codeVerifier)), grantType: \(Swift.String(describing: grantType)), redirectUri: \(Swift.String(describing: redirectUri)), refreshToken: \"CONTENT_REDACTED\")"}
}

/// Input structure for CreateOAuth2Token operation Contains flattened token operation inputs for both authorization code and refresh token flows. The operation type is determined by the grant_type parameter in the request body.
package struct CreateOAuth2TokenInput: Swift.Sendable {
    /// Flattened token operation inputs The specific operation is determined by grant_type in the request body
    /// This member is required.
    public var tokenInput: SigninClientTypes.CreateOAuth2TokenRequestBody?

    public init(
        tokenInput: SigninClientTypes.CreateOAuth2TokenRequestBody? = nil
    ) {
        self.tokenInput = tokenInput
    }
}

extension SigninClientTypes {

    /// Response body payload for CreateOAuth2Token operation The response content depends on the grant_type from the request:
    ///
    /// * grant_type=authorization_code: Returns all fields including refresh_token and id_token
    ///
    /// * grant_type=refresh_token: Returns access_token, token_type, expires_in, refresh_token (no id_token)
    package struct CreateOAuth2TokenResponseBody: Swift.Sendable {
        /// Scoped-down AWS credentials (15 minute duration) Present for both authorization code redemption and token refresh
        /// This member is required.
        public var accessToken: SigninClientTypes.AccessToken?
        /// Time to expiry in seconds (maximum 900) Present for both authorization code redemption and token refresh
        /// This member is required.
        public var expiresIn: Swift.Int?
        /// ID token containing user identity information Present only in authorization code redemption response (grant_type=authorization_code) Not included in token refresh responses
        public var idToken: Swift.String?
        /// Encrypted refresh token with cnf.jkt (SHA-256 thumbprint of presented jwk) Always present in responses (required for both flows)
        /// This member is required.
        public var refreshToken: Swift.String?
        /// Token type indicating this is AWS SigV4 credentials Value is "aws_sigv4" for both flows
        /// This member is required.
        public var tokenType: Swift.String?

        public init(
            accessToken: SigninClientTypes.AccessToken? = nil,
            expiresIn: Swift.Int? = nil,
            idToken: Swift.String? = nil,
            refreshToken: Swift.String? = nil,
            tokenType: Swift.String? = nil
        ) {
            self.accessToken = accessToken
            self.expiresIn = expiresIn
            self.idToken = idToken
            self.refreshToken = refreshToken
            self.tokenType = tokenType
        }
    }
}

extension SigninClientTypes.CreateOAuth2TokenResponseBody: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOAuth2TokenResponseBody(expiresIn: \(Swift.String(describing: expiresIn)), idToken: \(Swift.String(describing: idToken)), tokenType: \(Swift.String(describing: tokenType)), accessToken: \"CONTENT_REDACTED\", refreshToken: \"CONTENT_REDACTED\")"}
}

/// Output structure for CreateOAuth2Token operation Contains flattened token operation outputs for both authorization code and refresh token flows. The response content depends on the grant_type from the original request.
package struct CreateOAuth2TokenOutput: Swift.Sendable {
    /// Flattened token operation outputs The specific response fields depend on the grant_type used in the request
    /// This member is required.
    public var tokenOutput: SigninClientTypes.CreateOAuth2TokenResponseBody?

    public init(
        tokenOutput: SigninClientTypes.CreateOAuth2TokenResponseBody? = nil
    ) {
        self.tokenOutput = tokenOutput
    }
}

extension CreateOAuth2TokenInput {

    static func urlPathProvider(_ value: CreateOAuth2TokenInput) -> Swift.String? {
        return "/v1/token"
    }
}

extension CreateOAuth2TokenInput {

    static func write(value: CreateOAuth2TokenInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tokenInput"].write(value.tokenInput, with: SigninClientTypes.CreateOAuth2TokenRequestBody.write(value:to:))
    }
}

extension CreateOAuth2TokenOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOAuth2TokenOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOAuth2TokenOutput()
        value.tokenOutput = try reader.readIfPresent(with: SigninClientTypes.CreateOAuth2TokenResponseBody.read(from:))
        return value
    }
}

enum CreateOAuth2TokenOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "TooManyRequestsError": return try TooManyRequestsError.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.error = try reader["error"].readIfPresent() ?? .sdkUnknown("")
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.error = try reader["error"].readIfPresent() ?? .sdkUnknown("")
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsError {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsError {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsError()
        value.properties.error = try reader["error"].readIfPresent() ?? .sdkUnknown("")
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.error = try reader["error"].readIfPresent() ?? .sdkUnknown("")
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SigninClientTypes.CreateOAuth2TokenResponseBody {

    static func read(from reader: SmithyJSON.Reader) throws -> SigninClientTypes.CreateOAuth2TokenResponseBody {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SigninClientTypes.CreateOAuth2TokenResponseBody()
        value.accessToken = try reader["accessToken"].readIfPresent(with: SigninClientTypes.AccessToken.read(from:))
        value.tokenType = try reader["tokenType"].readIfPresent() ?? ""
        value.expiresIn = try reader["expiresIn"].readIfPresent() ?? 0
        value.refreshToken = try reader["refreshToken"].readIfPresent() ?? ""
        value.idToken = try reader["idToken"].readIfPresent()
        return value
    }
}

extension SigninClientTypes.AccessToken {

    static func read(from reader: SmithyJSON.Reader) throws -> SigninClientTypes.AccessToken {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SigninClientTypes.AccessToken()
        value.accessKeyId = try reader["accessKeyId"].readIfPresent() ?? ""
        value.secretAccessKey = try reader["secretAccessKey"].readIfPresent() ?? ""
        value.sessionToken = try reader["sessionToken"].readIfPresent() ?? ""
        return value
    }
}

extension SigninClientTypes.CreateOAuth2TokenRequestBody {

    static func write(value: SigninClientTypes.CreateOAuth2TokenRequestBody?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientId"].write(value.clientId)
        try writer["code"].write(value.code)
        try writer["codeVerifier"].write(value.codeVerifier)
        try writer["grantType"].write(value.grantType)
        try writer["redirectUri"].write(value.redirectUri)
        try writer["refreshToken"].write(value.refreshToken)
    }
}

package enum SigninClientTypes {}
